<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>万问居</title>
  
  
  <link href="https://qwertyu212.github.io/atom.xml" rel="self"/>
  
  <link href="https://qwertyu212.github.io/"/>
  <updated>2023-01-18T13:40:00.043Z</updated>
  <id>https://qwertyu212.github.io/</id>
  
  <author>
    <name>日月同错</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://qwertyu212.github.io/2023/01/18/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://qwertyu212.github.io/2023/01/18/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-18T12:29:54.000Z</published>
    <updated>2023-01-18T13:40:00.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-学习笔记"><a href="#Linux-学习笔记" class="headerlink" title="*Linux* 学习笔记"></a><em><strong>*Linux*</strong></em> 学习笔记</h1><h2 id="一、-常用命令"><a href="#一、-常用命令" class="headerlink" title="*一、* *常用命令*"></a><em><strong>*一、*</strong></em> <em><strong>*常用命令*</strong></em></h2><p>****LINUX****常用操作命令和命令行编辑快捷键 </p><p>终端快捷键： </p><p>Ctrl + a/Home 切换到命令行开始<br>Ctrl + e/End 切换到命令行末尾<br>Ctrl + l 清除屏幕内容，效果等同于 clear<br>Ctrl + u 清除剪切光标之前的内容<br>Ctrl + k 剪切清除光标之后的内容<br>Ctrl + y 粘贴刚才所删除的字符<br>Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了）<br>Ctrl + c 终止命令<br>ctrl + o 重复执行命令<br>Ctrl + d 退出 shell，logout<br>Ctrl + z 转入后台运行,但在当前用户退出后就会终止<br>Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符<br>Alt + t 交换当前与以前单词的位置<br>Alt + d 剪切光标之后的词<br>Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）<br>Ctrl+（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作<br>Ctrl+s 锁住终端<br>Ctrl+q 解锁终端<br>!! 重复执行最后一条命令<br>history 显示你所有执行过的编号+历史命令。这个可以配合!编辑来执行某某命令<br>!$ 显示系统最近的一条参数<br>最后这个比较有用，比如我先用 cat /etc/sysconfig/network-scripts/ifconfig-eth0，然后我想用 vim 编辑。一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命令。其实完全可以用 vim !$来代替。 </p><p>****gnome****快捷键 </p><p>Alt + F1 类似 Windows 下的 Win 键，在 GNOME 中打开”应用程序”菜单(Applications)<br>Alt + F2 类似 Windows 下的 Win + R 组合键，在 GNOME 中运行应用程序<br>Ctrl + Alt + D 类似 Windows 下的 Win + D 组合键，显示桌面<br>Ctrl + Alt + L 锁定桌面并启动屏幕保护程序<br>Alt + Tab 同 Windows 下的 Alt + Tab 组合键，在不同程序窗口间切换<br>PrintScreen 全屏抓图<br>Alt + PrintScreen 当前窗口抓图<br>Ctrl + Alt + → / ← 在不同工作台间切换<br>Ctrl + Alt + Shift + → / ← 移动当前窗口到不同工作台<br>Ctrl+Alt+Fn 终端 N 或模拟终端 N(n 和 N 为数字 1－6) </p><p>Ctrl+Alt+F7 返回桌面 </p><p>窗口操作快捷键 </p><p>Alt + F4 关闭窗口<br>Alt + F5 取消最大化窗口 (恢复窗口原来的大小)<br>Alt + F7 移动窗口 (注: 在窗口最大化的状态下无效)<br>Alt + F8 改变窗口大小 (注: 在窗口最大化的状态下无效)<br>Alt + F9 最小化窗口<br>Alt + F10 最大化窗口<br>Alt + 空格键 打开窗口的控制菜单 (点击窗口左上角图标出现的菜单） </p><p>文件浏览器 </p><p>​        Ctrl+N 新建窗口<br>​        Ctrl + Shift + W 关闭所有文件浏览器<br>​        Ctrl + 1/2 改变文件夹视图查看方式，图标视图/列表视图<br>​        Alt + → / ← 后退/前进<br>​        Alt + ↑/↓ 移动到父文件夹/选择的文件夹<br>​        Alt + Home 直接移动到主文件夹<br>​        F9 开关显示隐藏 Nautilus 侧边栏<br>​        Ctrl+H 显示隐藏文件（切换键）<br>​        Shift+Ctrl+N 新建文件夹， 很有用<br>​        Alt + Enter 查看选择文件/文件夹的属性，代替单击右键选择属性<br>​        Ctrl+Page Up 上一个标签<br>​        Ctrl+Page Down 下一个标签<br>​        Alt+N 切换到第 N 个标签（N 为数字） </p><p>关机和重启命令 </p><p> Shutdown<br> Reboot<br> Halt<br> poweroff </p><p>****grep****和管道符 </p><p>昨天的时候 leader 给我出了道问题：<br>找出文件夹下包含 “aaa” 同时不包含 “bbb”的文件，然后把他们重新生成一下。要求只能用一行命令。 我对 Linux 是个白痴，工作了之后才开始接触的，会用的命令只有那几个常用的。这个问题对我来说就有点难度，我只是大概知道查找文件用 grep ，其他的就不知道了。不过没关系，用 Google ，查找到 grep 的完整用法：<br>1、grep -l ‘boss’ * 显示所有包含 boss 的文件名。<br>2、grep -n ‘boss’ file 在匹配行之前加行号。<br>3、grep -i ‘boss’ file 显示匹配行，boss 不区分大小写。<br>4、grep -v ‘boss’ file 显示所有不匹配行。<br>5、grep -q ‘boss’ file 找到匹配行，但不显示，但可以检查 grep 的退出状态。（0 为匹配成功）<br>6、grep -c ‘boss’ file 只显示匹配行数（包括 0）。 </p><p>7、grep “$boss” file 扩展变量 boss 的值再执行命令。<br>8、ps -ef|grep “^<em>user1″ 搜索 user1 的命令，即使它前面有零个或多个空格。<br>9、ps -e|grep -E ‘grant_server|commsvr|tcpsvr|dainfo’ 查找多个字符串的匹配（grep -E 相当于 egrep） （来源：）<br>了解了 grep 的参数之后，问题就解决了一半了，因为可以搜索出符合条件的文件了。不过光有 grep 还是不行，因为要把搜索出来的文件名作为参数传给 generate 命令。OK，接下来该管道符出场了。 即使是像我这样对 Linux 只是有一点了解的人也经常用到管道符，比如“|”，示例： ls -a | more 。但是对于管道符的具体意义和它做了什么我就不知道了，没关系，Google 一下，找到一些资料：<br>利用 <em><strong>*Linux*</strong></em> 所提供的管道符</em>***“|”****将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。<br>所以查找的时候可以这样写：<br>grep -rl “aaa” * | grep -v “bbb” </p><p>这样右边的命令就可以从前面的结果中筛选了。然后还有 generate 命令，因为生成文件的命令格式是这样的：<br>generate 文件名<br>不过如果直接使用 generate grep -rl “aaa” * | grep -v “bbb” 的话会出错，因为命令会从左向右执行，这条命令就会把 grep 作为一个文件名来看待。怎么办呢？这个时候就要使用 · (键盘上数字键 1 旁边的那个符号，和“<del>”在一个按键上)来做命令替换了，用 · 把后面的 grep 命令包起来就好了，这样：<br>generate ·grep -rl “aaa” * | grep -v “bbb”·<br>然后就搞定了。<br>工作一段时间之后，越来越喜欢 Linux 的哲学了，它有很多命令，看起来功能都不是那么强劲，但是如果你开动脑筋把这些命令组合起来的话，就能实现 很多让你意想不到的功能，有时候你忍不住惊呼：实在是太 coooool 了！ 这对于像我这种被 Windows 的傻瓜式操作惯坏了的人来说，是个福音，以后要多多开动生锈了的大脑。如果单纯使用电脑的话，还是 Windows 好用，但 是对于程序员，最好还是多玩玩 Linux。 BTW，现在也越来越喜欢使用 VIM 了，虽然刚开始用的时候就觉得它是个记事本</del>囧~~ 以前总听说“真正的牛人编码都是用记事本编写的”，当时就觉得这些人实在太厉害了，代码提示和自动补全都不用，现在想想，可能是外行看到他们使用灵活+强 大的 VIM 或者 EMACS 了吧。^_^<br>我的补充:<br>查找包含 logField 又包含 open 的文件：<br>用 grep “logFileId” *.tbc|grep “open” </p><p><em><strong>*二、*</strong></em> <em><strong>*磁盘管理*</strong></em> </p><p>文件系统配置文件 </p><table><thead><tr><th>/etc/filesystems：系统指定的测试挂载文件系统类型  /proc/filesystems：Linux 系统已经加载的文件系统类型</th><th></th></tr></thead><tbody><tr><td>/lib/modules/2.6.18-274.el5/kernel/fs/</td><td>文件系统类型的驱动所在目录</td></tr><tr><td>/etc/fstab  /etc/mtab</td><td></td></tr></tbody></table><p><em><strong>*linux*</strong></em> 文件类型的颜色 </p><table><thead><tr><th></th><th>linux文件颜色的含义：蓝色代表目录 绿色代表可执行文件 红色表示压缩文件 浅蓝色表示链接文件 灰</th></tr></thead><tbody><tr><td>色表示其他文件 红色闪烁表示链接的文件有问题了 黄色表示设备文件</td><td></td></tr></tbody></table><p>蓝色文件———-目录<br>白色文件———-一般性文件，如文本文件，配置文件，源码文件等<br>浅蓝色文件———-链接文件，主要是使用 ln 命令建立的文件<br>绿色文件———-可执行文件，可执行的程序<br>红色文件———–压缩文件或者包文件<br>Linux 下用字符表示的文件类型<br>-：普通文件<br>d：目录文件<br>l：链接文件<br>b：块设备文件<br>c：字符设备文件<br>p：管道文件 </p><p>文件系统操作命令 </p><p>****df****：列出文件系统的整体磁盘使用情况 </p><p>[root@centos57 ~]# df -h<br>        文件系统       容量 已用 可用 已用% 挂载点<br>        /dev/mapper/VolGroup00-LogVol00<br>                 16G  4.2G  11G  28% /<br>        /dev/sda1        99M  13M  81M  14% /boot<br>        tmpfs         1005M   0 1005M  0% /dev/shm<br>[root@centos57 ~]# df -i<br>        文件系统        Inode (I)已用 (I)可用 (I)已用% 挂载点<br>        /dev/mapper/VolGroup00-LogVol00<br>             4186112  154441 4031671   4% /<br>        /dev/sda1        26104    36  26068   1% /boot<br>        tmpfs         257210    1  257209   1% /dev/shm<br>        .host:/           0    0    0   -  /mnt/hgfs </p><p>****du****：列出目录所占空间 </p><table><thead><tr><th>du -sh</th><th>显示当前目录大小</th></tr></thead><tbody><tr><td>du –sh / 显示/目录下的所有目录大小</td><td></td></tr></tbody></table><p>****dumpe2fs****：显示当前的磁盘状态 </p><p>****ln****：连接文件（快捷方式） </p><table><thead><tr><th></th><th>ln –sf 源文件 目标文件  不加任何参数就进行连接，就是 hard link，加上-s 就是 Symbolic link，hard link 不支持目录和跨文件系统。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><em><strong>*Fdisk*</strong></em> </p><table><thead><tr><th></th><th>Fdisk 不支持大于 2T 的磁盘</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>Fdisk –l 显示系统中的所有分区内容</td><td></td><td></td></tr><tr><td></td><td><em><strong>*[root@centos57 ~]# fdisk -l*</strong></em></td><td></td><td></td></tr><tr><td></td><td>Disk /dev/sda: 21.4 GB, 21474836480 bytes</td><td></td><td></td></tr><tr><td>255 heads, 63 sectors/track, 2610 cylinders</td><td></td><td>总扇区数，可以和下面的最后扇区数比较，看剩余</td><td></td></tr></tbody></table><table><thead><tr><th></th><th>Units = cylinders of 16065 * 512 = 8225280 bytes</th><th></th></tr></thead><tbody><tr><td>Device Boot    Start     End    Blocks  Id  System  /dev/sda1  *      1      13    104391  83  Linux  /dev/sda2        14     2610   20860402+  8e  Linux LVM  <em><strong>*[root@centos57 ~]# fdisk /dev/sda2*</strong></em></td><td></td><td></td></tr></tbody></table><p>****Parted*<em><strong>：</strong></em>*2T****以上磁盘分区工具 </p><table><thead><tr><th></th><th>支持大于 2T 的磁盘，2T 以下的最好还是用 Fdisk 来分区。       [root@centos57 aixi]# parted /dev/hda print              Model: VMware Virtual IDE Hard Drive (ide)              Disk /dev/hda: 2147MB              Sector size (logical/physical): 512B/512B              Partition Table: msdos</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>Number  Start  End   Size  Type   File system  标志<br> 1    32.3kB  101MB  101MB  主分区 ext3<br> <em><strong>*2*</strong></em>   101MB  357MB  256MB  主分区 linux-swap </p><table><thead><tr><th></th><th># parted /dev/hda rm <em><strong>*2*</strong></em></th><th>删除第 <em><strong>*2*</strong></em> 个分区</th><th>创建分区，<em><strong>*primary*</strong></em> 代表主分区，还可以是</th></tr></thead><tbody><tr><td></td><td><em><strong>*# parted /dev/hda mkpart primary ext3 120MB 200MB*</strong></em></td><td></td><td></td></tr></tbody></table><p><em><strong>*extended*</strong></em> 扩展分区，<em><strong>*logical*</strong></em> 逻辑分区<em><strong>*;ext3*</strong></em> 代表分区类型，<em><strong>*120MB*</strong></em> 是开始位置，最好是接上一分区的结束位置，<em><strong>*200M*</strong></em> 是结束位置 </p><p>****partprobe :*<em><strong>更新分区表</strong></em>*/****磁盘 </p><table><thead><tr><th></th><th>用于重读分区表，当出现删除文件后,出现仍然占用空间。可以 partprobe 在不重启的情况下重读分区 # partprobe   这个命令执行完毕之后不会输出任何返回信息，你可以使用 mke2fs 命令在新的分区上创建文件系统。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>****Mkfs:****磁盘格式化 </p><p><em><strong>*Mkfs –t*</strong></em> 文件系统格式 设备文件名（盘符） </p><table><thead><tr><th></th><th>[root@centos57 ~]# mkfs -t ext3 /dev/hda1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>****e2label****：设置磁盘卷标 </p><table><thead><tr><th></th><th>e2label 设备名称 新 label 名称，可以用 dumpe2fs 查看卷标   [root@centos57 ~]# e2label /dev/hda1 aixi</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>****Mount:****挂载磁盘 </p><table><thead><tr><th></th><th>命令格式：  mount [-t vfstype] [-o options] device dir</th></tr></thead><tbody><tr><td><em><strong>*mount –o remount,rw,auto /*</strong></em></td><td>重新挂载</td></tr><tr><td><em><strong>*mount –n –o remount,rw /*</strong></em></td><td>重新挂载根目录，设置为可读写</td></tr></tbody></table><p> 其中：<br> 1.-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有： 光盘或光盘镜像：iso9660<br> DOS fat16 文件系统：msdos<br> Windows 9x fat32 文件系统：vfat<br> Windows NT ntfs 文件系统：ntfs<br> Mount Windows 文件网络共享：smbfs </p><p> UNIX(LINUX) 文件网络共享：nfs<br> 2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：<br> loop：用来把一个文件当成硬盘分区挂接上系统<br> ro：采用只读方式挂接设备<br> rw：采用读写方式挂接设备<br> iocharset：指定访问文件系统所用字符集<br> 3.device 要挂接(mount)的设备。<br> 4.dir 设备在系统上的挂接点(mount point)。 </p><p>挂接光盘镜像文件 </p><p> 1、从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。<br> #cp /dev/cdrom /home/sunky/mydisk.iso 或<br> #dd if=/dev/cdrom of=/home/sunky/mydisk.iso </p><p>​     注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso  2、将文件和目录制作成光盘镜像文件，执行下面的命令。<br>​     #mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir </p><p>​             注：这条命令将/home/sunky/mydir 目录下所有的目录和文件制作成光盘镜像文件<br>/home/sunky/mydisk.iso，光盘卷标为：mydisk<br>​     3、光盘镜像文件的挂接(mount)<br>​             #mkdir /mnt/vcdrom<br>​             注：建立一个目录用来作挂接点(mount point)<br>​             <em><strong>*#mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom*</strong></em> </p><p> 注：使用/mnt/vcdrom 就可以访问盘镜像文件 mydisk.iso 里的所有文件了。 </p><p>挂接移动硬盘 </p><p>​     对 linux 系统而言，USB 接口的移动硬盘是当作 SCSI 设备对待的。插入移动硬盘之前，应先用 fdisk –l 或 more /proc/partitions 查看系统的硬盘和硬盘分区情况。<br>​     [root at pldyrouter /]# fdisk -l<br>​     Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes<br>​     255 heads, 63 sectors/track, 8924 cylinders<br>​     Units = cylinders of 16065 * 512 = 8225280 bytes<br>​     Device Boot Start End Blocks Id System<br>​     /dev/sda1 1 4 32098+ de Dell Utility<br>​     /dev/sda2 * 5 2554 20482875 7 HPFS/NTFS<br>​     /dev/sda3 2555 7904 42973875 83 Linux<br>​     /dev/sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br>​     /dev/sda5 7905 8924 8193118+ 82 Linux swap </p><p>​     在这里可以清楚地看到系统有一块 SCSI 硬盘/dev/sda 和它的四个磁盘分区/dev/sda1 – /dev/sda4, /dev/sda5 是分区/dev/sda4 的逻辑分区。接好移动硬盘后，再用 fdisk –l 或 more /proc/partitions 查看系统的硬盘和硬盘分区情况<br>​     [root at pldyrouter /]# fdisk -l<br>​     Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes<br>​     255 heads, 63 sectors/track, 8924 cylinders<br>​     Units = cylinders of 16065 * 512 = 8225280 bytes </p><p> Device Boot Start End Blocks Id System<br> /dev/sda1 1 4 32098+ de Dell Utility<br> /dev/sda2 * 5 2554 20482875 7 HPFS/NTFS<br> /dev/sda3 2555 7904 42973875 83 Linux<br> /dev/sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> /dev/sda5 7905 8924 8193118+ 82 Linux swap<br> Disk /dev/sdc: 40.0 GB, 40007761920 bytes<br> 255 heads, 63 sectors/track, 4864 cylinders<br> Units = cylinders of 16065 * 512 = 8225280 bytes<br> Device Boot Start End Blocks Id System<br> /dev/sdc1 1 510 4096543+ 7 HPFS/NTFS<br> /dev/sdc2 511 4864 34973505 f Win95 Ext’d (LBA)<br> /dev/sdc5 511 4864 34973473+ b Win95 FAT32 </p><p>​     大家应该可以发现多了一个 SCSI 硬盘/dev/sdc 和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc5是/dev/sdc2 分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1 和/dev/sdc5。<br>​         #mkdir -p /mnt/usbhd1<br>​         #mkdir -p /mnt/usbhd2<br>​         注：建立目录用来作挂接点(mount point)<br>​         #mount -t ntfs /dev/sdc1 /mnt/usbhd1<br>​         #mount -t vfat /dev/sdc5 /mnt/usbhd2<br>​         注：对 ntfs 格式的磁盘分区应使用-t ntfs 参数，对 fat32 格式的磁盘分区应使用-t vfat 参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式。<br>​         #mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1<br>​         #mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd2<br>​     linux 系统下使用 fdisk 分区命令和 mkfs 文件系统创建命令可以将移动硬盘的分区制作成 linux 系统所特有的 ext2、ext3 格式。这样，在 linux 下使用就更方便了。使用下面的命令直接挂接即可。<br>​         #mount /dev/sdc1 /mnt/usbhd1<br>​         </p><p>挂接****U****盘 </p><p>​     和 USB 接口的移动硬盘一样对 linux 系统而言 U 盘也是当作 SCSI 设备对待的。使用方法和移动硬盘完全一样。插入 U 盘之前，应先用 fdisk –l 或 more /proc/partitions 查看系统的硬盘和硬盘分区情况。  [root at pldyrouter root]# fdisk -l<br>​     Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes<br>​     255 heads, 63 sectors/track, 8924 cylinders<br>​     Units = cylinders of 16065 * 512 = 8225280 bytes<br>​     Device Boot Start End Blocks Id System<br>​     /dev/sda1 1 4 32098+ de Dell Utility<br>​     /dev/sda2 * 5 2554 20482875 7 HPFS/NTFS<br>​     /dev/sda3 2555 7904 42973875 83 Linux<br>​     /dev/sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br>​     /dev/sda5 7905 8924 8193118+ 82 Linux swap </p><p> 插入 U 盘后，再用 fdisk –l 或 more /proc/partitions 查看系统的硬盘和硬盘分区情况。<br> [root at pldyrouter root]# fdisk -l<br> Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes </p><p> 255 heads, 63 sectors/track, 8924 cylinders<br> Units = cylinders of 16065 * 512 = 8225280 bytes<br> Device Boot Start End Blocks Id System<br> /dev/sda1 1 4 32098+ de Dell Utility<br> /dev/sda2 * 5 2554 20482875 7 HPFS/NTFS<br> /dev/sda3 2555 7904 42973875 83 Linux<br> /dev/sda4 7905 8924 8193150 f Win95 Ext’d (LBA)<br> /dev/sda5 7905 8924 8193118+ 82 Linux swap<br> Disk /dev/sdd: 131 MB, 131072000 bytes<br> 9 heads, 32 sectors/track, 888 cylinders<br> Units = cylinders of 288 * 512 = 147456 bytes<br> Device Boot Start End Blocks Id System<br> /dev/sdd1 * 1 889 127983+ b Win95 FAT32<br> Partition 1 has different physical/logical endings:<br> phys=(1000, 8, 32) logical=(888, 7, 31) </p><p> 系统多了一个 SCSI 硬盘/dev/sdd 和一个磁盘分区/dev/sdd1,/dev/sdd1 就是我们要挂接的 U 盘。 #mkdir -p /mnt/usb<br> 注：建立一个目录用来作挂接点(mount point)<br> #mount -t vfat /dev/sdd1 /mnt/usb<br> 注：现在可以通过/mnt/usb 来访问 U 盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。 #mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb </p><p>挂接****Windows****文件共享 </p><p>​     Windows 网络共享的核心是 SMB/CIFS，在 linux 下要挂接(mount)windows 的磁盘共享，就必须安装和使用 samba 软件包。现在流行的 linux 发行版绝大多数已经包含了 samba 软件包，如果安装 linux 系统时未安装 samba 请首先安装 samba。当然也可以到 <a href="http://www.samba.org/">www.samba.org</a> 网站下载……新的版本是 3.0.10 版。<br>​     当 windows 系统共享设置好以后，就可以在 linux 客户端挂接(mount)了，具体操作如下：<br>​     # mkdir –p /mnt/samba<br>​     注：建立一个目录用来作挂接点(mount point)<br>​     # mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba<br>​     注：administrator 和 pldy123 是 ip 地址为 10.140.133.23 windows 计算机的一个用户名和密码，c$是这台计算机的一个磁盘共享<br>​     如此就可以在 linux 系统上通过/mnt/samba 来访问 windows 系统磁盘上的文件了。以上操作在 redhat as server 3、redflag server 4.1、suse server 9 以及 windows NT 4.0、windows 2000、windows xp、windows 2003环境下测试通过。 </p><p>挂接****UNIX*<em><strong>系统</strong></em>*NFS****文件共享 </p><p>​     类似于 windows 的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是 NFS(网络文件系统)，下面我们就以 SUN Solaris2.8 和 REDHAT as server 3 为例简单介绍一下在 linux 下如何 mount nfs 网络共享。  在 linux 客户端挂接(mount)NFS 磁盘共享之前，必须先配置好 NFS 服务端。<br>​     1、Solaris 系统 NFS 服务端配置方法如下：<br>​         (1)修改 /etc/dfs/dfstab, 增加共享目录<br>​             share -F nfs -o rw /export/home/sunky </p><p> (2)启动 nfs 服务<br>     # /etc/init.d/nfs.server start </p><p> (3)NFS 服务启动以后，也可以使用下面的命令增加新的共享<br> # share /export/home/sunky1<br> # share /export/home/sunky2 </p><p>​         注：/export/home/sunky 和/export/home/sunky1 是准备共享的目录<br> 2、linux 系统 NFS 服务端配置方法如下：<br>​         (1)修改 /etc/exports,增加共享目录<br> /export/home/sunky 10.140.133.23(rw)<br> /export/home/sunky1 *(rw)<br> /export/home/sunky2 linux-client(rw) </p><p>​     注：/export/home/目录下的 sunky、sunky1、sunky2 是准备共享的目录，10.140.133.23、*、 linux-client是被允许挂接此共享 linux 客户机的 IP 地址或主机名。如果要使用主机名 linux-client 必须在服务端主机 /etc/hosts 文件里增加 linux-client 主机 ip 定义。格式如下：<br>​     10.140.133.23 linux-client </p><p>​                     (2)启动与停止 NFS 服务<br>​                     /etc/rc.d/init.d/portmap start (在 REDHAT 中 PORTMAP 是默认启动的)<br>​                     /etc/rc.d/init.d/nfs start 启动 NFS 服务<br>​                     /etc/rc.d/init.d/nfs stop 停止 NFS 服务<br>​                     注：若修改/etc/export 文件增加新的共享，应先停止 NFS 服务，再启动 NFS 服务方能使新增加的共享起作用。使用命令 exportfs -rv 也可以达到同样的效果。<br>​         3、linux 客户端挂接(mount)其他 linux 系统或 UNIX 系统的 NFS 共享<br>​                     # mkdir –p /mnt/nfs<br>​                     注：建立一个目录用来作挂接点(mount point)<br>​                     #mount -t nfs -o rw 10.140.133.9:/export/home/sunky /mnt/nfs<br>​                     注：这里我们假设 10.140.133.9 是 NFS 服务端的主机 IP 地址，当然这里也可以使用主机名，但必须在本机/etc/hosts 文件里增加服务端 ip 定义。/export/home/sunky 为服务端共享的目录。<br>​         如此就可以在 linux 客户端通过/mnt/nfs 来访问其它 linux 系统或 UNIX 系统以 NFS 方式共享出来的文件了。以上操作在 redhat as server 3、redflag server4.1、suse server 9 以及 Solaris 7、Solaris 8、Solaris 9 for x86&amp;sparc 环境下测试通过。<br>权限问题：<br>假设 server 端的使用者 jack, user id 为 1818, gid 为 1818, client 端也有一个使用者 jack，但是 uid 及 gid 是 1818。client 端的 jack   希望能完全读写 server 端的 /home/jack 这个目录。server 端的 /etc/exports 是<br>​         这样写的：<br>​                         /home/jack <em>(rw,all_squash,anonuid=1818,anongid=1818)<br>​         这个的配置文件的意思是，所有 client 端的使用者存取 server 端 /home/jack 这<br>​         目录时，都会 map 成 server 端的 jack (uid,gid=1818)。我 mount 的结果是<br>​         1. client 端的 root 可以完全存取该目录, 包括读、写、杀……等<br>​         2. client 端的 jack (uid,gid=1818) 我可以做：<br>​                 rm -rf server_jack/</em><br>​                 cp something server_jack/<br>​                 mkdir server_jack/a </p><p>****umount****：将文件设备卸载 </p><table><thead><tr><th></th><th>[root@centos57 ~]# umount /dev/hda1</th><th>用设备文件名来卸载</th><th></th></tr></thead><tbody><tr><td></td><td>[root@centos57 ~]# umount /aixi</td><td></td><td>用挂载点来卸载</td></tr></tbody></table><table><thead><tr><th></th><th>umount: /aixi: device is busy</th><th></th><th>如果提示设备忙，不急可以使用如下命令卸载</th></tr></thead><tbody><tr><td>****#****umount -l /mnt/hda1</td><td>选项 –l 并不是马上 umount，而是在该目录空闲后再 umount。</td><td></td><td></td></tr><tr><td>如果比较急，可用如下命令：</td><td></td><td></td><td></td></tr><tr><td>****#****umount -f /mnt/hda1</td><td></td><td>-f 代表强制卸载</td><td></td></tr><tr><td>如果还不行，可使用 fuser -m –v /dev/hda1 来查询是哪些程序在占用，结束这些程序进程即可卸载</td><td></td><td></td><td></td></tr><tr><td>[root@centos57 aixi]# sync &amp;&amp; fuser -m /dev/hda1 –k</td><td></td><td>使用这条命令后一定可以卸载</td><td></td></tr></tbody></table><p>交换分区 </p><table><thead><tr><th></th><th>交换分区最大容量为 64G，最多只能建 32 个, 创建交换分区 #fdisk /dev/hdaànà+容量àpàt(修改系统 ID)à分区号à82àpàw</th><th></th></tr></thead><tbody><tr><td>#mkswap /dev/hda2（以上划分的分区号）</td><td>构建 swap 格式</td><td></td></tr><tr><td>#swapon /dev/hda2</td><td>加载即完成增加 swap</td><td></td></tr><tr><td>#swapon –s</td><td></td><td>显示目前使用的 Swap 设备</td></tr><tr><td>创建交换文件</td><td></td><td></td></tr><tr><td># dd if=/dev/hda1 of=/aixi/swap bs=1M count=64</td><td>创建大文件</td><td></td></tr><tr><td>#mkswap /aixi/swap</td><td></td><td></td></tr><tr><td>#swapon /aixi/swap</td><td>完成</td><td></td></tr><tr><td>取消交换分区或者交换文件</td><td></td><td></td></tr><tr><td>#swapon –s</td><td></td><td>显示目前使用的 Swap 设备</td></tr><tr><td>#swapoff /aixi/swap #swapoff /dev/hda2 #free –m 查看</td><td></td><td></td></tr></tbody></table><p><em><strong>*三、*</strong></em> <em><strong>*用户管理*</strong></em> </p><p>用户和用户组操作命令 </p><p><em><strong>*Id*</strong></em> </p><p><em><strong>*Finger*</strong></em> </p><p><em><strong>*Pwck*</strong></em> </p><table><thead><tr><th></th><th>检查/etc/passwd 配置文件内的信息与实际主文件夹是否存在，还可比较/etc/passwd 和/etc/shadow 的信</th></tr></thead><tbody><tr><td>息是否一致，另外如果/etc/passwd 中的数据字段错误也会提示。</td><td></td></tr></tbody></table><p><em><strong>*Grpck*</strong></em> </p><table><thead><tr><th></th><th>和 pwck 功能相近，这是检查用户组的。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>**<br>**</p><p><em><strong>*Groups*</strong></em> </p><p><em><strong>*newgrp*</strong></em> </p><p><em><strong>*useradd*</strong></em> </p><p><em><strong>*usermod*</strong></em> </p><p>usermod 不仅能改用户的 SHELL 类型，所归属的用户组，也能改用户密码的有效期，还能改登录名。usermod 如此看来就</p><p>是能做到用户帐号大转移；比如我把用户 A 改为新用户 B； </p><p>usermod  [-u uid [-o]] [-g group] [-G group,…] </p><p> [-d 主目录 [-m]] [-s shell] [-c 注释] [-l 新名称] </p><p> [-f 失效日] [-e 过期日] [-p 密码] [-L|-U] 用户名 </p><p>usermod 命令会参照你命令列上指定的部份修改系统帐号档。下列为 usermod 可选用的参数。 </p><p>-c comment </p><p> 更新用户帐号 password 档中的注解栏，一般是使用 chfn(1)来修改。 </p><p>-d home_dir </p><p> 更新用户新的登入目录。如果给定-m 选项，用户旧目录会搬到新的目录去，如旧目录不存在则建个新的。 </p><p>-e expire_date 加上用户帐号停止日期。日期格式为 MM/DD/YY. </p><p>-f inactive_days 帐号过期几日后永久停权。当值为 0 时帐号则立刻被停权。而当值为-1 时则关闭此功能。预设值为-1。 </p><p>-g initial_group 更新用户新的起始登入用户组。用户组名须已存在。用户组 ID 必须参照既有的的用户组。用户组 ID 预设</p><p>值为 1。 </p><p>-G group,[…] 定义用户为一堆 groups 的成员。每个用户组使用”,”区格开来，不可以夹杂空白字元。用户组名同-g 选项的</p><p>限制。如果用户现在的用户组不再此列，则将用户由该用户组中移除。 </p><p>-l login_name  变更用户 login 时的名称为 login_name。其它不变。特别是，用户目录名应该也会跟着更动成新的登入名。 </p><p>-s shell  指定新登入 shell。如此栏留白，系统将选用系统预设 shell。 </p><p>-u uid 用户 ID 值。必须为唯一的 ID 值，除非用-o 选项。数字不可为负值。预设为最小不得小于/etc/login.defs 中定义的</p><p>UID_MIN 值。0 到 UID_MIN 值之间是传统上保留给系统帐号使用。用户目录树下所有的档案目录其 userID 会自动改变。放在</p><p>用户目录外的档案则要自行手动更动。 </p><p>警告:usermod 不允许你改变正在线上的用户帐号名称。当 usermod 用来改变 userID,必须确认这名 user 没在电脑上执行任何</p><p>程序。你需手动更改用户的 crontab 档。也需手动更改用户的 at 工作档。采用 NISserver 须在 server 上更动相关的 NIS 设</p><p>定。 </p><p>举个简单的例子，我们在前面说了关于 useradd 的工具，而 usermod 工具和 useradd 的参数差不多；两者不同之处在于</p><p>useradd 是添加，usermod 是修改； </p><p>[root@localhost ~]# usermod -d /opt/linuxfish -m  -l fishlinux -U linuxfish </p><p>注：把 linuxfish 用户名改为 fishlinux ，并且把其家目录转移到 /opt/linuxfish ； </p><p>[root@localhost ~]# ls -la /opt/linuxfish/  注：查看用户 fishlinux 的家目录下的文件及属主； </p><p>总用量 48 </p><p>drwxr-xr-x  3 fishlinux linuxfish 4096 11 月  5 16:46 . </p><p>drwxrwxrwx  29 root    root    4096 11 月  5 16:48 .. </p><p>-rw-r–r–  1 fishlinux linuxfish  24 11 月  5 16:46 .bash_logout </p><p>-rw-r–r–  1 fishlinux linuxfish  191 11 月  5 16:46 .bash_profile </p><p>-rw-r–r–  1 fishlinux linuxfish  124 11 月  5 16:46 .bashrc </p><p>-rw-r–r–  1 fishlinux linuxfish 5619 11 月  5 16:46 .canna </p><p>-rw-r–r–  1 fishlinux linuxfish  438 11 月  5 16:46 .emacs </p><p>-rw-r–r–  1 fishlinux linuxfish  120 11 月  5 16:46 .gtkrc </p><p>drwxr-xr-x  3 fishlinux linuxfish 4096 11 月  5 16:46 .kde </p><p>-rw-r–r–  1 fishlinux linuxfish   0 11 月  5 16:46 mydoc.txt </p><p>-rw-r–r–  1 fishlinux linuxfish  658 11 月  5 16:46 .zshrc </p><p>[root@localhost ~]# more  /etc/passwd |grep fishlinux  注：查看有关 fishlinux 的记录； </p><p>fishlinux:x:512:512::/opt/linuxfish:/bin/bash </p><p>通过上面的例子，我们发现文件的用户组还没有变，如果您想改变为 fishlinux 用户组，如果想用通过 usermod 来修改，就要</p><p>先添加 fishlinux 用户组；然后用 usermod -g 来修改 ，也可以用 chown -R fishlinux:fishlinux /opt/finshlinux 来改； </p><p>警告： usermod 最好不要用它来改用户的密码，因为他在/etc/shadow 中显示的是明口令；修改用户的口令最好用 passwd ； </p><p>[root@localhost ~]# usermod -p 123456 fishlinux  注：修改 fishlinux 的口令是 123456 ； </p><p>[root@localhost ~]# more /etc/shadow |grep fishlinux  注：查询/etc/shadow 文件中 fishlinux 的口令；我们看到明显</p><p>是没有加密； </p><p>fishlinux:123456:13092:0:99999:7::: </p><p><em><strong>*userdel*</strong></em> </p><p>userdel 很简单，只有一个参数可选 -r ；如果加参数-r ，表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目</p><p>录或文件也一同删除；比如我们现在有两个用户 bnnb 和 lanhaitun，其家目录都位于/home 目录中，现在我们来删除这两个</p><p>用户； </p><p>[root@localhost ~]# userdel bnnb  注：删除用户 bnnb，但不删除其家目录及文件； </p><p>[root@localhost ~]# ls -ld /home/bnnb  注：查看其家目录是否存在； </p><p>drwxr-xr-x  14 501 501 4096  8 月 29 16:33 /home/bnnb   注：存在； </p><p>[root@localhost ~]# ls -ld /home/lanhaitun  注：查看 lanhaitun 家目录是否存在； </p><p>drwx——  4 lanhaitun lanhaitun 4096 11 月  5 14:50 /home/lanhaitun  注：存在； </p><p>[root@localhost ~]# userdel -r  lanhaitun  注：删除用户 lanhaitun，其家目录及文件一并删除； </p><p>[root@localhost ~]# ls -ld /home/lanhaitun  注：查看是否在删除 lanhaitun 用户的同时，也一并把其家目录和文件一</p><p>同删除； </p><p>ls: /home/lanhaitun: 没有那个文件或目录  注：已经删除； </p><p>警告： 请不要轻易用-r 参数；他会删除用户的同时删除用户所有的文件和目录，切记；如果用户目录下有重要的文件，在删</p><p>除前请备份； </p><p>其实也有最简单的办法，但这种办法有点不安全，也就是直接在/etc/passwd 中删除您想要删除用户的记录；但最好不要这样</p><p>做，/etc/passwd 是极为重要的文件，可能您一不小心会操作失误； </p><p><em><strong>*Groupadd*</strong></em> </p><p><em><strong>*groupmod*</strong></em> </p><p><em><strong>*groupdel*</strong></em> 是用来删除用户组的； </p><p>语法格式：groupdel 用户组 </p><p>比如： </p><p>[root@localhost ~]# groupdel lanhaitun </p><p>**<br>**</p><p><em><strong>*passwd*</strong></em> </p><p>passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被 root 用户锁</p><p>定；如果 root 用户运行 passwd ，可以设置或修改任何用户的密码； </p><p>passwd 命令后面不接任何参数或用户名，则表示修改当前用户的密码；请看下面的例子； </p><p>[root@localhost ~]# passwd  注：没有加任何用户，我是用 root 用户来执行的 passwd 表示修改 root 用户的密码；下面</p><p>也有提示； </p><p>Changing password for user root. </p><p>New UNIX password:  注：请输入新密码； </p><p>Retype new UNIX password:  注：验证新密码； </p><p>passwd: all authentication tokens updated successfully.  注：修改 root 密码成功； </p><p>如果是普通用户执行 passwd 只能修改自己的密码； </p><p>如果新建用户后，要为新用户创建密码，则用 <em><strong>*passwd*</strong></em> 用户名 ，注意要以 root 用户的权限来创建； </p><p>[root@localhost ~]# passwd beinan  注：更改或创建 beinan 用户的密码； </p><p>Changing password for user beinan. </p><p>New UNIX password:  注：请输入新密码； </p><p>Retype new UNIX password:  注：再输入一次； </p><p>passwd: all authentication tokens updated successfully.  注：成功； </p><p>普通用户如果想更改自己的密码，直接运行 passwd 即可；比如当前操作的用户是 beinan； </p><p>[beinan@localhost ~]$ passwd </p><p>Changing password for user beinan. 注：更改 beinan 用户的密码； </p><p>(current) UNIX password: 注：请输入当前密码； </p><p>New UNIX password: 注：请输入新密码； </p><p>Retype new UNIX password: 注：确认新密码； </p><p>passwd: all authentication tokens updated successfully.  注：更改成功；<br><em><strong>*passwd*</strong></em> 几个比较重要的参数； </p><p>[root@localhost beinan]# passwd –help </p><p>Usage: passwd [OPTION…] <accountName> </accountName></p><p> -k, –keep-tokens    keep non-expired authentication tokens  </p><p> 注：保留即将过期的用户在期满后能仍能使用； </p><p> -d, –delete       delete the password for the named account (root only) </p><p> 注：删除用户密码，仅能以 root 权限操作； </p><p> -l, –lock        lock the named account (root only) </p><p> 注：锁住用户无权更改其密码，仅能通过 root 权限操作； </p><p> -u, –unlock       unlock the named account (root only) </p><p> 注：解除锁定； </p><p> -f, –force       force operation  </p><p> 注：强制操作；仅 root 权限才能操作； </p><p> -x, –maximum=DAYS    maximum password lifetime (root only) 注：两次密码修正的最大天数，后面接数字；仅能</p><p>root 权限操作； </p><p> -n, –minimum=DAYS    minimum password lifetime (root only)  注：两次密码修改的最小天数，后面接数字，仅能</p><p>root 权限操作； </p><p> -w, –warning=DAYS    number of days warning users receives before  注：在距多少天提醒用户修改密码；仅能</p><p>root 权限操作； </p><p> password expiration (root only) </p><p> -i, –inactive=DAYS   number of days after password expiration when an  注：在密码过期后多少天，用户被禁</p><p>掉，仅能以 root 操作； </p><p> account becomes disabled (root only) </p><p> -S, –status       report password status on the named account (root  注：查询用户的密码状态，仅能 root</p><p>用户操作； </p><p> only) </p><p> –stdin         read new tokens from stdin (root only)  </p><p>比如我们让某个用户不能修改密码，可以用-l 参数来锁定： </p><p>[root@localhost ~]# passwd -l beinan  注：锁定用户 beinan 不能更改密码； </p><p>Locking password for user beinan. </p><p>passwd: Success      注：锁定成功； </p><p>[beinan@localhost ~]# su beinan  注：通过 su 切换到 beinan 用户； </p><p>[beinan@localhost ~]$ passwd  注：beinan 来更改密码； </p><p>Changing password for user beinan. </p><p>Changing password for beinan </p><p>(current) UNIX password: 注：输入 beinan 的当前密码； </p><p>passwd: Authentication token manipulation error  注：失败，不能更改密码； </p><p>再来一例： </p><p>[root@localhost ~]# passwd -d beinan  注：清除 beinan 用户密码； </p><p>Removing password for user beinan. </p><p>passwd: Success             注：清除成功； </p><p>[root@localhost ~]# passwd -S beinan  注：查询 beinan 用户密码状态； </p><p>Empty password.           注：空密码，也就是没有密码； </p><p>注意： 当我们清除一个用户的密码时，登录时就无需密码；这一点要加以注意； </p><p><em><strong>*chage*</strong></em> 修改用户密码有效期限的命令； </p><p>chage 用语法格式： </p><p>chage [-l] [-m 最小天数] [-M 最大天数] [-W 警告] [-I 失效日] [-E 过期日] [-d 最后日] 用户 </p><p>前面已经说的好多了，这个只是一笔带过吧，知道有这个命令就行，自己实践实践再说，大体和 psswd 有些参数的用法差不</p><p>多； </p><p><em><strong>*id*</strong></em> 工具<em><strong>*:*</strong></em> 查询用户所对应的<em><strong>*UID*</strong></em> 和<em><strong>*GID*</strong></em> 及****GID****所对应的用户组； </p><p>id 工具是用来查询用户信息，比如用户所归属的用户组，UID 和 GID 等；id 用法极为简单；我们举个例子说明一下； </p><p>语法格式： id  [参数]  [用户名] </p><p>至于有哪些参数，自己查一下 id –help 或 man id ；如果 id 后面不接任何参数和任何用户，默认显示当前操作用户的用户名、</p><p>所归属的用户组、UID 和 GID 等； </p><p>实例一：不加任何参数和用户名； </p><p>[beinan@localhost ~]$ id </p><p>uid=500(beinan) gid=500(beinan) groups=500(beinan) </p><p>注解：在没有加任何参数的情况下，查询的是当前操作用户的用户名、UID 、GID 和所处的主用户组和附属用户组；在本例</p><p>中，用户名是 beinan，UID 是 500,所归属的主用户组是 beinan，GID 是 500 ； </p><p>实例二： <em><strong>*id*</strong></em> 后面接用户名； </p><p>如果我们想查询系统中用户的 UID 和 GID 相应的内容，可以直接接用户名，但用户名必须是真实的 ，能在/etc/passwd 中查</p><p>到的； </p><p>[beinan@localhost ~]$ id linuxsir </p><p>uid=505(linuxsir) gid=502(linuxsir) groups=502(linuxsir),0(root),500(beinan) </p><p>注解：查询用户 linuxsir 的信息，用户 linuxsir ，UID 为 505，所归属的主用户组是 linuxsir，主用户组的 GID 是 502；同时</p><p>linuxsir 用户也是 GID 为 0 的 root 用户组成员，也是 GID 为 500 用户组 beinan 的成员； </p><p>这个例子和实例一在用户组方面有所不同，我们在 中有提到；用户和</p><p>用户组的对应关系，可以是一对一、一对多、多对一、或多对多的交叉关系，请参考之；另外您还需要掌握</p><p>一文；<br>、工具：用来查询用户信息，侧重用户家目录、登录 <em><strong>*SHELL*</strong></em> 等； </p><p>finger 工具侧重于用户信息的查询；查询的内容包括用户名（也被称为登录名 Login），家目录，用户真实的名字（Name）… … </p><p>办公地址、办公电话；也包括登录终端、写状态、空闭时间等； </p><p>我们最常用 finger 来查询用户家目录、用户真实名、所用 SHELL 类型、以及办公地址和电话，这是以参数 -l 长格式输出的；</p><p>而修改用户的家目录、真实名字、办公地址及办公电话，我们一般要能过 chfn 命令进行； </p><p>语法格式： </p><p>finger [参数选项] [用户名］ </p><p>-l 采用长格式（默认），显示由-s 选项所包含的所有信息，以及主目录、办公地址、办公电话、登录 SHELL、邮件状</p><p>态、.plan、.project 和.forward； </p><p>-m 禁止对用户真实名字进行匹配； </p><p>-p 把.plan 和.project 文件中的内容省略； </p><p>-s 显示短格式，用户名（也被称为登录名 Login）、真实名字（NAME）、在哪个终端登录（Tty）、写状态、空闲时间（Idle）、</p><p>登录时间（Login Time）、办公地点、办公电话等； </p><p>至于 finger 有哪些参数，您可以通过 finger –help 或 man finger 来获取，我们在本文中以实例讲述最常用的参数； </p><p>实例一：不接任何参数，也不指定查询用户名；默认为加了<em><strong>*-s*</strong></em> 参数； </p><p>[beinan@localhost ~]$ finger  </p><p>Login   Name       Tty    Idle  Login Time  Office   Office Phone </p><p>beinan   beinan sun   tty1   1:39  Nov  2 08:27 </p><p>linuxsir  linuxsir open  tty2     2  Nov  2 10:03 linuxsir o +1-389-866-771 </p><p>等价命令 </p><p>[beinan@localhost ~]$ finger  -s  </p><p>注解：不加任何参数，也没有指定查询哪个用户，finger 会以默认以短格-s 来输出登录本机的所有用户的用户名（也被称为</p><p>登录名 Login）、真实名字（NAME）、在哪个终端登录（Tty）、写状态、空闲时间（Idle）、登录时间（Login Time）、办公地</p><p>点、办公电话等； </p><p>在这个例子中，有 beinan 用户登录，真实名字是 beinan sun （这个名字是用户的真实名字，如果在添加用户时没有设置，</p><p>是不会显示的），在 tty1 终端登录，空闭时间是 1 分 39 秒，登录时间是 Nov /2/08:27 ，没有办公室名称，没有办公电话； </p><p>请对照本例中 beinan 用户记录的解说，我们来看看本例中的 linuxsir 用户信息；应该不难。 </p><p>关于写状态，如果在 Tty 后面 没有任何输出，表示正在写入，如果有*出现，表示没有写入或被禁止，比如下面的例子，ftp</p><p>用户没有通过终端登录系统，因为 Tty 是<em>，同时 Tty 后面还有一个</em> ，表示禁止写入或没有写入状态(当用户没有登录时）； </p><p>[beinan@localhost ~]$ finger -s ftp </p><p>Login   Name    Tty    Idle  Login Time  Office   Office Phone </p><p>ftp    FTP User   *   *  No logins </p><p>我们可以以短格式的来查询某个用户信息以短格式输出，比如下面的例子； </p><p>[beinan@localhost ~]$ finger  -s  beinan  </p><p>实例二：关于长格式的用户信息的输出 -l 参数的实例； </p><p>finger -l 如果不加用户名的情况下，可以列出所有通过 tty 登录的用户信息；如果您想查询某个用户，就直接指定用户，可以</p><p>指定一个或多个；什么是 tty 登录？如果您在全屏文本界面操作的话，您可以通过按 CTRL+F2 或 CTRL+F3 或 CTRL+F4 等， </p><p>以几个不同的用户登录到主机上，您就会看到，每个用户都有不同的 tty； </p><p>[beinan@localhost ~]$ finger -l </p><p>[beinan@localhost ~]$ finger -l  beinan linuxsir  注：可以同时查询几个用户信息，以长格式输出； </p><p>[beinan@localhost ~]$ finger beinan </p><p>Login: beinan              Name: beinan sun </p><p>Directory: /home/beinan         Shell: /bin/bash </p><p>On since Wed Nov  2 08:27 (CST) on tty1   2 hours 29 minutes idle </p><p>On since Wed Nov  2 10:50 (CST) on pts/0 from :0.0 </p><p>No mail. </p><p>No Plan. </p><p>在本例中，所查询的用户是 beinan，真实名字是 beinan sun ，家目录位于 /home/beinan ，所用 SHELL 类型是 bash ；然</p><p>后就是通过哪个终端登录的，登录时间，是不是有 mail ，有 Plan 等； </p><p>实例三：参数组合的例子； </p><p>[beinan@localhost ~]$ finger -lp  beinan </p><p>Login: beinan              Name: beinan sun </p><p>Directory: /home/beinan         Shell: /bin/bash </p><p>On since Wed Nov  2 08:27 (CST) on tty1   2 hours 36 minutes idle </p><p>On since Wed Nov  2 10:50 (CST) on pts/0 from :0.0 </p><p>No mail. </p><p>注解：查询 beinan 用户信息，以长格式输出，并且不输出.Plan 和.Project 的内容； </p><p>实例四： finger -s 和 w 及 who 的比较； </p><p>对于 finger 就说这么多吧，极为简单的工具，当用到-s 参数时，您最好和 w 和 who 工具对照，看看 finger -s 和 w 及 who</p><p>的输出有什么异同，w 和 who 是查询哪些用户登录主机的；而 finger -s 呢，无论是登录还是不登录的用户都可以查；但所查</p><p>到的内容侧重有所不同；自己看看例子； </p><p>[beinan@localhost ~]$ finger -s </p><p>Login   Name       Tty    Idle  Login Time  Office   Office Phone </p><p>beinan   beinan sun    tty1   3:03  Nov  2 08:27 </p><p>beinan   beinan sun    pts/0      Nov  2 10:50 (:0.0) </p><p>linuxsir  linuxsir open  tty2   1:26  Nov  2 10:03 linuxsir o +1-389-866-771 </p><p>[beinan@localhost ~]$ w </p><p>11:30:36 up  3:04,  3 users,  load average: 0.30, 0.15, 0.10 </p><p>USER   TTY    FROM        LOGIN@  IDLE  JCPU  PCPU WHAT </p><p>beinan  tty1   -         08:27   3:03m  2:52  0.00s /bin/sh /usr/X11R6/bin/startx </p><p>linuxsir tty2   -         10:03   1:26m  0.01s  0.01s -bash </p><p>beinan  pts/0   :0.0       10:50   0.00s  0.16s  0.00s w </p><p>[beinan@localhost ~]$ who </p><p>beinan  tty1     Nov  2 08:27 </p><p>linuxsir tty2     Nov  2 10:03 </p><p>beinan  pts/0     Nov  2 10:50 (:0.0)<br><em><strong>*3*<em><strong>、查询登录主机的用户工具：</strong></em>*w*</strong></em> 、<em><strong>*who*</strong></em> 、<em><strong>*users*</strong></em> </p><p>w、who 和 users 工具，是查询已登录当前主机的用户；另外 finger -s 也同样能查询；侧重点不一样；请自己对比着看；毕</p><p>竟简单，这里只是介绍 ； </p><p>[beinan@localhost ~]$ w </p><p>12:09:56 up  3:43,  7 users,  load average: 0.16, 0.10, 0.04 </p><p>USER   TTY    FROM        LOGIN@  IDLE  JCPU  PCPU WHAT </p><p>beinan  tty1   -         08:27   3:42m  3:09  0.00s /bin/sh /usr/X11R6/bin/startx </p><p>linuxsir tty2   -         10:03   2:06m  0.01s  0.01s -bash </p><p>beinan  pts/0   :0.0       11:36   1:09  0.15s  0.15s bash </p><p>beinan  pts/1   :0.0       11:37   1:12  0.21s  0.21s bash </p><p>beinan  pts/2   :0.0       12:02   6:52  0.09s  0.09s bash </p><p>beinan  pts/3   :0.0       12:05  12.00s  0.11s  0.06s ssh <a href="mailto:&#120;&#109;&#x62;&#110;&#110;&#x62;&#100;&#108;&#64;&#x6c;&#105;&#110;&#117;&#x78;&#x73;&#105;&#114;&#46;&#111;&#114;&#x67;">&#120;&#109;&#x62;&#110;&#110;&#x62;&#100;&#108;&#64;&#x6c;&#105;&#110;&#117;&#x78;&#x73;&#105;&#114;&#46;&#111;&#114;&#x67;</a> -p 17007 </p><p>beinan  pts/4   :0.0       12:06   0.00s  0.21s  0.00s w </p><p>[beinan@localhost ~]$ who </p><p>beinan  tty1     Nov  2 08:27 </p><p>linuxsir tty2     Nov  2 10:03 </p><p>beinan  pts/0     Nov  2 11:36 (:0.0) </p><p>beinan  pts/1     Nov  2 11:37 (:0.0) </p><p>beinan  pts/2     Nov  2 12:02 (:0.0) </p><p>beinan  pts/3     Nov  2 12:05 (:0.0) </p><p>beinan  pts/4     Nov  2 12:06 (:0.0) </p><p>[beinan@localhost ~]$ users </p><p>beinan beinan beinan beinan beinan beinan linuxsir<br><em><strong>*4*<em><strong>、</strong></em>*groups*</strong></em> 用户所归属的用户组查询； </p><p>groups 用法很简单，就是查询用户所归属哪个或哪些用户组； </p><p>语法格式：  groups  用户名  </p><p>实例： </p><p>[beinan@localhost ~]$ groups beinan  注：查询 beinan 所归属的用户组；  </p><p>beinan : beinan  注：beinan 是 beinan 用户组下的成员； </p><p>[beinan@localhost ~]$ groups linuxsir   注：查询 linuxsir 用户所归属的用户组； </p><p>linuxsir : linuxsir root beinan   注：linuxsir 用户是 linuxsir 用户组、beinan 用户组、root 用户组成员；  </p><p>groups 主要是查询用户所归属的用户组名，最好和 id 命令相对比；这样对这两个工具都有所了解 </p><p>相关配置文件 </p><p>/etc/passwd<br>/etc/shadow<br>/etc/gshadow<br>/etc/group </p><p>****Linux****用户密码策略 </p><p>​    Linux 用户密码的有效期,是否可以修改密码可以通过 login.defs 文件控制.对 login.defs 文件修只影响后续建立的用户,如果要改变以前建立的用户的有效期等可以使用 chage 命令. </p><table><thead><tr><th>Linux 用户密码的复杂度可以通过 pam pam_cracklib module 或 pam_passwdqc module 控制,两者不能同时使用. 个人感觉 pam_passwdqc 更好用.          /etc/login.defs 密码策略              PASS_MAX_DAYS  99999   #密码的最大有效期, 99999:永久有期              PASS_MIN_DAYS  0      #是否可修改密码,0 可修改,非 0 多少天后可修改              PASS_MIN_LEN   5      #密码最小长度,使用 pam_cracklib module,该参数不再有效              PASS_WARN_AGE  7     #密码失效前多少天在用户登录时通知用户修改密码          pam_cracklib 主要参数说明:              tretry=N:重试多少次后返回密码修改错误</th><th></th></tr></thead><tbody><tr><td></td><td>difok=N:新密码必需与旧密码不同的位数</td></tr><tr><td></td><td>dcredit=N: N &gt;= 0:密码中最多有多少个数字;N &lt; 0 密码中最少有多少个数字.</td></tr><tr><td></td><td>lcredit=N:小宝字母的个数</td></tr><tr><td></td><td>ucredit=N 大宝字母的个数</td></tr><tr><td></td><td>credit=N:特殊字母的个数</td></tr><tr><td></td><td>minclass=N:密码组成(大/小字母,数字,特殊字符)</td></tr><tr><td>pam_passwdqc 主要参数说明:          mix:设置口令字最小长度，默认值是 mix=disabled。          max:设置口令字的最大长度，默认值是 max=40。          passphrase:设置口令短语中单词的最少个数，默认值是 passphrase=3，如果为 0 则禁用口令短语。     atch:设置密码串的常见程序，默认值是 match=4。          similar:设置当我们重设口令时，重新设置的新口令能否与旧口令相似，它可以是 similar=permit 允        许相似或 similar=deny 不允许相似。          random:设置随机生成口令字的默认长度。默认值是 random=42。设为 0 则禁止该功能。     enforce:设置约束范围，enforce=none 表示只警告弱口令字，但不禁止它们使用；enforce=users 将        对系统上的全体非根用户实行这一限制；enforce=everyone 将对包括根用户在内的全体用户实行这        一限制。          non-unix:它告诉这个模块不要使用传统的 getpwnam 函数调用获得用户信息，          retry:设置用户输入口令字时允许重试的次数，默认值是 retry=3</td><td></td></tr></tbody></table><p>密码复杂度通过/etc/pam.d/system-auth 实施<br>        如:<br>        要使用 pam_cracklib 将注释去掉,把 pam_passwdqc.so 注释掉即可.<br>        #password   requisite   /lib/security/$ISA/pam_cracklib.so retry=3 difok=1<br>        password   requisite   /lib/security/$ISA/pam_passwdqc.so min=disabled,24,12,8,7 passphrase=3         password   sufficient   /lib/security/$ISA/pam_unix.so nullok use_authtok md5 shadow </p><pre><code>    #password   requisite   /lib/security/$ISA/pam_cracklib.so retry=3 difok=1     新密码至少有一位与原来的不同      PASS_MIN_DAYS 参数则设定了在本次密码修改后，下次允许更改密码之前所需的最少天数。</code></pre><p>PASS_WARN_AGE 的设定则指明了在口令失效前多少天开始通知用户更改密码（一般在用户刚刚登陆系统时就会收到警告通知）。<br>        你也会编辑/etc/default/useradd 文件，寻找 INACTIVE 和 EXPIRE 两个关键词：<br>        INACTIVE=14<br>        EXPIRE= </p><p>​         这会指明在口令失效后多久时间内，如果口令没有进行更改，则将账户更改为失效状态。在本例中，这个时间是 14 天。而 EXPIRE 的设置则用于为所有新用户设定一个密码失效的明确时间（具体格式为“年份-月份-日期”）。<br>​         显然，上述这些设定更改之后，只能影响到新建立的用户。要想修改目前已存在的用户具体设置，需要使用 chage 工具。<br>​    # chage -M 60 joe </p><p>​    这条命令将设置用户 joe 的 PASS_MAX_DAYS 为 60，并修改对应的 shadow 文件。<br>​         你可以使用 chage -l 的选项，列出当前的账户时效情况，而使用-m 选项是设置 PASS_MIN_DAYS，用-W则是设置 PASS_WARN_AGE，等等。chage 工具可以让你修改特定账户的所有密码时效状态。<br>​         注意，chage 仅仅适用于本地系统的账户，如果你在使用一个类似 LDAP 这样的认证系统时，该工具会失效。如果你在使用 LDAP 作为认证，而你又打算使用 chage，那么，哪怕仅仅是试图列出用户密码的时效信息，你也会发现 chage 根本不起作用。<br>​         制定一项策略，定义多长时间一个密码必须进行更改，然后强制执行该策略，是非常不错的一个做法。在解雇了某个雇员后，口令时效策略会保证该雇员不可能在被解雇 3 个月后发现他的口令依然可用。即使系统管理员忽略了删除他的帐号，该帐号也会因密码时效策略而被自动锁定。当然，这一点并不能成为不及时删除该雇员帐号的理由，但是这个策略的确提供了一层额外的安全防护，尤其是在过去常常忽视及时清理帐号的情况下。 </p><p>****ACL****权限设置 </p><p>​    ACL 是 Access Control List 的缩写，主要用于在提供传统的 owner、group、others 的 read、write、execute权限之外进行细部权限设置。 </p><p>启动<em><strong>*ACL*</strong></em> </p><table><thead><tr><th>让****/****目录支持 ****ACL****：  #mount –o remount ,acl /</th><th></th><th></th></tr></thead><tbody><tr><td>#mount |grep /</td><td></td><td>//查看是否有挂载</td></tr></tbody></table><p>开机启动 ****ACL****：<br>将要启动 ACL 的分区写入/etc/fstab 中：<br>#vi /etc/fstab<br>/dev/hda5    /         ext3     default,acl    1    2 </p><p>****ACL****相关命令 </p><p>​        ****Getfacl :*<em><strong>取得某个文件</strong></em>*/****目录的 <em><strong>*ACL*</strong></em> 权限；<br>​        ****Setfacl :*<em><strong>设置某个文件</strong></em>*/****目录的 <em><strong>*ACL*</strong></em> 权限；<br>​        setfacl [-bkndRLPvh] [{-m|-x} acl_spec] [{-M|-X} acl_file] file …<br>​        setfacl –restore=file<br>​        描述<br>​        setfacl 用来在命令行里设置 ACL。在命令行里，一系列的命令跟随以一系列的文件名。<br>​        选项-m 和-x 后边跟以 acl 规则。多条 acl 规则以逗号(,)隔开。选项-M 和-X 用来从文件或标准输入读取acl 规则。<br>​        选项–set 和–set-file 用来设置文件或目录的 acl 规则，先前的设定将被覆盖。<br>​        选项-m(–modify)和-M(–modify-file)选项修改文件或目录的 acl 规则。<br>​        选项-x(–remove)和-X(–remove-file)选项删除 acl 规则。<br>​        当使用-M，-X 选项从文件中读取规则时，setfacl 接受 getfacl 命令输出的格式。每行至少一条规则，以#开始的行将被视为注释。 </p><p>​    当在不支持 ACLs 的文件系统上使用 setfacl 命令时，setfacl 将修改文件权限位。如果 acl 规则并不完全匹配文件权限位，setfacl 将会修改文件权限位使其尽可能的反应 acl 规则，并会向 standard error 发送错误消息，以大于 0 的状态返回。<br>​    权限<br>​    文件的所有者以及有 CAP_FOWNER 的用户进程可以设置一个文件的 acl。（在目前的 linux 系统上，root用户是唯一有 CAP_FOWNER 能力的用户）<br>​    选项<br>​    -b,–remove-all </p><p>​     删除所有扩展的 acl 规则，基本的 acl 规则(所有者，群组，其他）将被保留。<br>-k,–remove-default </p><p>​     删除缺省的 acl 规则。如果没有缺省规则，将不提示。<br>-n，–no-mask<br>​     不要重新计算有效权限。setfacl 默认会重新计算 ACL mask，除非 mask 被明确的制定。 –mask </p><p>​             重新计算有效权限，即使 ACL mask 被明确指定。<br>​    -d，–default<br>​             设定默认的 acl 规则。<br>​    –restore=file<br>​             从文件恢复备份的 acl 规则（这些文件可由 getfacl -R 产生）。通过这种机制可以恢复整个目录树的 acl规则。此参数不能和除–test 以外的任何参数一同执行。<br>​    –test<br>​             测试模式，不会改变任何文件的 acl 规则，操作后的 acl 规格将被列出。<br>​    -R，–recursive<br>​             递归的对所有文件及目录进行操作。<br>​    -L，–logical<br>​             跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。<br>​    -P，–physical<br>​             跳过所有符号链接，包括符号链接文件。<br>​    –version<br>​             输出 setfacl 的版本号并退出。<br>​    –help<br>​             输出帮助信息。<br>​    – </p><p>​     标识命令行参数结束，其后的所有参数都将被认为是文件名<br>- </p><p> 如果文件名是-，则 setfacl 将从标准输入读取文件名。<br>ACL 规则<br>setfacl 命令可以识别以下的规则格式。<br>[d[efault]:] [u[ser]:]uid [:perms] </p><p>​     指定用户的权限，文件所有者的权限（如果 uid 没有指定）。<br>[d[efault]:] g[roup]:gid [:perms]<br>​     指定群组的权限，文件所有群组的权限（如果 gid 未指定）<br>[d[efault]:] m[ask][:] [:perms] </p><p> 有效权限掩码 </p><p>[d[efault]:] o[ther] [:perms] </p><p>​             其他的权限<br>​        恰当的 acl 规则被用在修改和设定的操作中。<br>​        对于 uid 和 gid，可以指定一个数字，也可指定一个名字。<br>​        perms 域是一个代表各种权限的字母的组合：读-r 写-w 执行-x，执行只适合目录和一些可执行的文件。pers 域也可设置为八进制格式。<br>​        自动创建的规则<br>​        最初的，文件目录仅包含 3 个基本的 acl 规则。为了使规则能正常执行，需要满足以下规则。     *3 个基本规则不能被删除。<br>​        *任何一条包含指定的用户名或群组名的规则必须包含有效的权限组合。<br>​        *任何一条包含缺省规则的规则在使用时，缺省规则必须存在。<br>​        用法举例如下：<br>​        acl 全称 Access Control Lists 翻译成中文叫”访问控制列表”,<br>​        传统的 Linux 文件系统的权限控制是通过 user、group、other 与 r(读)、w(写)、x(执行) 的不同组合来实现的。随着应用的发展，这些权限组合已不能适应现时复杂的文件系统权限控制要求。 例如，目录 /data 的权限为：drwxr-x—，所有者与所属组均为 root，在不改变所有者的前提下，要求用户 tom 对该目录有完全访问权限 (rwx).考虑以下 2 种办法 (这里假设 tom 不属于 root group)<br>​        (1) 给 /data 的 other 类别增加 rwx permission，这样由于 tom 会被归为 other 类别，那么他也将拥有 rwx 权限。<br>​        (2) 将 tom 加入到 root group，为 root group 分配 rwx 权限，那么他也将拥有 rwx 权限。     以上 2 种方法其实都不合适，所以传统的权限管理设置起来就力不从心了。<br>​        为了解决这些问题，Linux 开发出了一套新的文件系统权限管理方法，叫文件访问控制列表 (Access Control Lists, ACL)。简单地来说，ACL 就是可以设置特定用户或者用户组对于一个文件的操作权限。     ACL 有两种，一种是存取 ACL (access ACLs)，针对文件和目录设置访问控制列表。一种是默认 ACL (default ACLs)，只能针对目录设置。如果目录中的文件没有设置 ACL，它就会使用该目录的默认 ACL.<br>​        首先我来讲一下 getfacl ( 显示文件或目录的 ACL)<br>​        在我的电脑里首先有一个用户叫 NEU.我们学校的简称.同时还有一个用户,software,我的专业名称.         我以 neu 用户进行操作,在其目录下建立一个文件 fileofneu.<br>​        可以看到它的初始权限为-rw-rw-r–然后我把这个文件权限进行下修改.使用的命令为 chmod,修改后的文件权限为-rw-rw—-现在这个文件的权限就不允许其它用户访问了.<br>​        然后切换到 sofeware 用户,来证实这个文件的不可访问性.<br>​        下面我们就通过 getfacl 命令来查看.这时候得进入 neu 用户下操作了.其命令格式很简单:getfacl fileofneu         权限一目了然.不多介绍了,下面就要用 Setfacl 来进行修改了.使其在对于其它用户的权限里,只对software 用户只读只写. </p><p><em><strong>*setfacl -m u:softeware:rw- fileofneu*</strong></em> </p><p>​    <em><strong>*setfacl -R -m u:softeware:rw- fileofneu (-R*</strong></em> 一定要在<em><strong>*-m*</strong></em> 前面，表示目录下所有文件）<br>​    <em><strong>*setfacl -x u:softeware fileofneu*</strong></em>  （去掉单个权限）<br>​    <em><strong>*setfacl -b*</strong></em> （去掉所有 <em><strong>*acl*</strong></em> 权限）<br>​    如果我们希望在一个目录中新建的文件和目录都使用同一个预定的 ACL，那么我们可以使用默认(Default) ACL。在对一个目录设置了默认的 ACL 以后，每个在目录中创建的文件都会自动继承目录的默认 ACL 作为自己的 ACL。用 setfacl 的-d 选项就可以做到这一点：<br>​    [root@FC3-vm mnt]# setfacl -d –set g:testg1:rwx dir1<br>​    [root@FC3-vm mnt]# getfacl dir1 </p><p>​        然后用 getfacl 命令来进行查看.我们就可以看到多了一行 user:software:rw- 这说明其对用户 software 开放了读写的权限.<br>​        为了证实其可用性,再切换到 software 用户下访问这个文件,发现与前面不同的是,这回可以读写了.         今天就讲这一个吧,讲多了,大家也记不住.<br>​        对了,刚才我进行了一下这个操作,发现进不去,原来是我没有给 software 用户授与访问/home/neu 这个目录的进入的权力,所以,我们还得应用 setfacl 命令来使得 software 用户拥有进入这个目录的权力.其操作与上面基本一致。 </p><p>用户身份切换 </p><p><em><strong>*Su*</strong></em> </p><p>命令作用<br>    su 的作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。<br>使用方式<br>    su [-fmp] [-c command] [-s shell] [–help] [–version] [-] [USER [ARG]] </p><p>参数说明<br>        -f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于 csh 或 tcsh 两种 Shell。<br>        -l ， –login：加了这个参数之后，就好像是重新登陆一样，大部分环境变量(例如 HOME、SHELL和 USER 等)都是以该使用者(USER)为主，并且工作目录也会改变。如果没有指定 USER，缺省情况是 root。     -m， -p ，–preserve-environment：执行 su 时不改变环境变数。<br>        -c command：变更账号为 USER 的使用者，并执行指令（command）后再变回原来使用者。     –help 显示说明文件<br>        –version 显示版本资讯<br>        USER：欲变更的使用者账号，<br>        ARG:  传入新的 Shell 参数。<br>例子 </p><table><thead><tr><th><em><strong>*su -c ls root*</strong></em> 变更帐号为 <em><strong>*root*</strong></em> 并在执行 <em><strong>*ls*</strong></em> 指令后退出变回原使用者。</th><th></th></tr></thead><tbody><tr><td><em><strong>*[user1@centos6 ~]$ su - root -c “head -n 3 /etc/passwd”*</strong></em></td><td>对于命令参数要加上引号</td></tr></tbody></table><p>su [用户名]<br>a&gt;在 root 用户下, 输入 su 普通用户. 则切换至普通用户, 从 root 切换到变通用户不需要密码 b&gt;在普通用户下, 输入 su [用户名]<br>提示 password:<br>输入用户的 PASSWORD, 则切换至该用户 </p><p><em><strong>*Sudo*</strong></em> </p><table><thead><tr><th></th><th>/etc/sudoers 谁能作什么的一个列表，Sudo 能用需要在这个文件中定义</th><th></th></tr></thead><tbody><tr><td></td><td>#visudo</td><td>增加如下，加%代表用户组，ALL=(ALL)表示登录者的来源主机名，最后的 ALL 代表可执行</td></tr><tr><td>的命令。NOPASSWD 代表不需要密码直接可运行 Sudo,限制多命令一定要写绝对路径，用逗号分开，多行用‘\’，用！代表不能执行</td><td></td><td></td></tr><tr><td></td><td>%aixi      ALL=(ALL)    NOPASSWD: ALL</td><td></td></tr><tr><td></td><td>%aixi      ALL=(ALL)    NOPASSWD: /bin/ls,/bin/mkdir,/bin/rmdir,\</td><td></td></tr><tr><td>/usr/bin/who,!/usr/bin/passwd root</td><td></td><td></td></tr></tbody></table><p>查询用户命令 </p><p><em><strong>*W*</strong></em> </p><table><thead><tr><th></th><th>可显示开机多久，当前登录的所有用户，平均负载</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><em><strong>*Who*</strong></em> </p><table><thead><tr><th></th><th>显示当前登录的所有用户</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><em><strong>*Last*</strong></em> </p><table><thead><tr><th></th><th>显示每个用户最后的登录时间</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><em><strong>*Lastlog*</strong></em> </p><table><thead><tr><th></th><th>显示每个用户最后的登录时间</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><em><strong>*四、*</strong></em> <em><strong>*文件权限*</strong></em> </p><p>****1****、文件类型 </p><p>Linux 广泛的被很多用户所接受，它强大的功能受到很多人喜欢，Linux 文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具… …. 或 cp 工具等。Linux 文件的删除方式是用 rm 命令。<br>Linux 文件类型和 Linux 文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如 file.txt、file.tar.gz ，这些文件虽然要用不同的程序来打开，但放在 Linux 文件类型中衡量的话，大多是常规文件（也被称为普通文件）。<br>Linux 文件类型常见的有：普通文件、目录、字符设备文件、块设备文件、符号链接文件等；现在我们进行一个简要的说明；<br>1 普通文件<br>\1. [root@localhost ~]# ls -lh install.log<br>\2. -rw-r–r– 1 root root 53K 03-16 08:54 install.log<br>我 们用 ls -lh 来查看某个文件的属性，可以看到有类似 -rw-r–r– ，值得注意的是第一个符号是 - ，这样的文件在 Linux 中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具… …. 或 cp 工具等。这类文件的删除方式是用 rm 命令；<br>2 目录<br>\1. [root@localhost ~]# ls -lh </p><p>\2. 总计 14M<br>\3. -rw-r–r– 1 root root   2 03-27 02:00 fonts.scale<br>\4. -rw-r–r– 1 root root  53K 03-16 08:54 install.log<br>\5. -rw-r–r– 1 root root  14M 03-16 07:53 kernel-6.15-1.2025_FC5.i686.rpm<br>\6. drwxr-xr-x 2 1000 users 4.0K 04-04 23:30 mkuml-2004.07.17<br>\7. drwxr-xr-x 2 root root  4.0K 04-19 10:53 mydir<br>\8. drwxr-xr-x 2 root root  4.0K 03-17 04:25 Public<br>当 我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在 Linux 是一个比较特殊的文件。注意它的第一个字符是 d。创建目录的命令可以用 mkdir 命令，或 cp 命令，cp 可以把一个目录复制为另一个目录。删除用 rm 或 rmdir 命令。<br>3 字符设备或块设备文件 </p><p>如时您进入/dev 目录，列一下文件，会看到类似如下的；<br>\1. [root@localhost ~]# ls -la /dev/tty<br>\2. crw-rw-rw- 1 root tty 5, 0 04-19 08:29 /dev/tty<br>\3. [root@localhost ~]# ls -la /dev/hda1<br>\4. brw-r—– 1 root disk 3, 1 2006-04-19 /dev/hda1 </p><p>我们看到/dev/tty 的属性是 crw-rw-rw- ，注意前面第一个字符是 c ，这表示字符设备文件。比如猫等串口设备<br>我们看到 /dev/hda1 的属性是 brw-r—– ，注意前面的第一个字符是 b，这表示块设备，比如硬盘，光驱等设备；<br>这个种类的文件，是用 mknode 来创建，用 rm 来删除。目前在最新的 Linux 发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。<br>4 套接口文件<br>当我们启动 MySQL 服务器时，会产生一个 mysql.sock 的文件。<br>\1. [root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock<br>\2. srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock </p><p>注意这个文件的属性的第一个字符是 s。我们了解一下就行了。<br>5 符号链接文件<br>\1. [root@localhost ~]# ls -lh setup.log<br>\2. lrwxrwxrwx 1 root root 11 04-19 11:18 setup.log -<em><strong>*&gt;*</strong></em> install.log<br>当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是 l，这类文件是链接文件。是通过ln -s 源文件名 新文件名。上面是一个例子，表示 setup.log 是 install.log 的软链接文件。怎么理解呢？这和 Windows 操作系统中的快捷方式有点相似。<br>符号链接文件的创建方法举例；<br>\1. [root@localhost ~]# ls -lh kernel-6.15-1.2025_FC5.i686.rpm<br>\2. -rw-r–r– 1 root root 14M 03-16 07:53 kernel-6.15-1.2025_FC5.i686.rpm<br>\3. [root@localhost ~]# ln -s kernel-6.15-1.2025_FC5.i686.rpm  kernel.rpm<br>\4. [root@localhost ~]# ls -lh kernel*<br>\5. -rw-r–r– 1 root root 14M 03-16 07:53 kernel-6.15-1.2025_FC5.i686.rpm<br>\6. lrwxrwxrwx 1 root root  33 04-19 11:27 kernel.rpm -<em><strong>*&gt;*</strong></em> kernel-6.15-1.2025_FC5 </p><p>****2****、文件权限 </p><p>​     Linux 系统是一个典型的多用户系统，不同的用户处于不同的地位。为了保护系统的安全性，Linux系统对不同用户访问同一文件的权限做了不同的规定。<br>​     对于一个 Linux 系统中的文件来说，它的权限可以分为三种：读的权限、写的权限和执行的权限，分别用 r、w 和 x 表示。不同的用户具有不同的读、写和执行的权限。<br>​     对于一个文件来说，它都有一个特定的所有者，也就是对文件具有所有权的用户。同时，由于在Linux 系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其它用户。因此，Linux 系统按文件所有者、文件所有者同组用户和其它用户三类规定不同的文件访问权限。<br>​     权限的概念<br>​     Linux 文件系统安全模型是通过给系统中的文件赋予两个属性来起作用的，这两个赋予每个文件的属性称为所有者(ownership)和访问权限(access rights)。Linux 下的每一个文件必须严格地属于一个用户和一个组。<br>下图是在我机器上的/root 目录下运行 ls -l 命令的情况。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps1.jpg" alt="img"> </p><p>-rw-r–r– </p><p>​     这些符号用来描述文件的访问权限类别，也就是常说的文件权限。这些访问权限指导 Linux 根据文件的用户和组所有权来处理所有访问文件的用户请求。总共有 10 种权限属性，因此一个权限列表总是10 个字符的长度。它的格式遵循下列规则：<br>​     ◆ 第 1 个字符表示一种特殊的文件类型。其中字符可为 d(表示该文件是一个目录)、b(表示该文件是一个系统设备，使用块输入/输出与外界交互，通常为一个磁盘)、c(表示该文件是一个系统设备，使用连续的字符输入/输出与外界交互，如串口和声音设备)，“.”表示该文件是一个普通文件，没有特殊属性。<br>​     ◆ 2～4 个字符用来确定文件的用户(user)权限，5～7 个字符用来确定文件的组(group)权限，8～10个字符用来确定文件的其它用户(other user，既不是文件所有者，也不是组成员的用户)的权限。其中，2、5、8 个字符是用来控制文件的读权限的，该位字符为 r 表示允许用户、组成员或其它人可从该文件中读取数据。短线“-”则表示不允许该成员读取数据。与此类似，3、6、9 位的字符控制文件的写权限，该位若为 w 表示允许写，若为“-”表示不允许写。4、7、10 位的字符用来控制文件的制造权限，该位若为 x 表示允许执行，若为“-”表示不允许执行。<br>​     任何列在/etc/passwd 文件中的用户都可以是一个文件的所有者，也称为该文件的用户。同样任何列在/etc/group 文件中的组都可以是文件组的所有者，也简称为文件的组。<br>drwxrwxr– 2 root root 4096 2 月 11 10:36 guo<br>​     因为 guo 的第 1 个位置的字符是 d，所以由此知道 guo 是一个目录。第 2 至 4 位置上的属性是 rwx，表示用户 root 拥有权限列表显示 guo 中所有的文件、创建新文件或者删除 guo 中现有的文件，或者将guo 作为当前工作目录。第 5 至 7 个位置上的权限是 rwx，表示 root 组的成员拥有和 root 一样的权限。第 8 至 10 位上的权限仅是 r–，表示不是 root 的用户及不属于 root 组的成员只有对 guo 目录列表的权限。这些用户不能创建或者删除 guo 中的文件、执行 junk 中的可执行文件，或者将 junk 作为他们的当前工作目录。 </p><p>-rwxr-xr– 1 user admin 20480 11 月 11 09:23 Readme.txt<br>​     在该项中，第 1 个位置是短线“-”，表示该文件是一个普通文件，没有特殊属性。该文件对任何人都可读，只对 user 可写，user 和 admin 的组成员可以执行该文件。<br>​     另外需要注意的是，当用户访问一个文件时，权限检查是从左到右的。假设上述的 readme.txt 文件具有以下权限：<br>-r–rw-r–<br>​     那么即使 user 是属于 admin 组的一个成员，也不能对该文件进行写操作，因为已经被左边的写权限设置拒绝了。 </p><p>一般文件权限读（R），写(W)，执行（X）权限比较简单。一般材料上面都</p><p>有介绍。这里介绍一下一些特殊的文件权限——SUID，SGID，Stick bit。 </p><p> 如果你检查一下/usr/bin/passwd 和/tmp/的文件权限你就会发现和普</p><p>通的文件权限有少许不同，如下图所示： </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps2.jpg" alt="img"> </p><p> 这 里 就 涉及 到 SUID 和 Stick bit。 </p><p><em><strong>*SUID*</strong></em> 和 <em><strong>*SGID*</strong></em> </p><p>​     我们首先来谈一下 passwd 程序特殊的地方。大家都知道，<em><strong>*Linux*</strong></em> 把用户的密码信息存放在/etc/shadow 里面，该文件属性如下： </p><table><thead><tr><th><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps3.jpg" alt="img"></th><th>可以看到 Shadow</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>的只有所有者可读写，所有者是 root，所以该文件对普通用户是不可读写的。但是普通用户调用 passwd 程序是可以修改自己的密码的，这又是为什么呢？难道普通用户可以读写 shadow文件？难道 <em><strong>*Linux*</strong></em> 有漏洞？当然不是啦。password 可以修改 shadow 文件的原因是他设置了SUID 文件权限。 </p><p> SUID 文件权限作用于可执行文件。一般的可执行文件在执行期的所有者是当前用户，比如当前系统用户是 simon，simon 运行程序 a.out，a.out 执行期的所有者应该是 simon。但是如果我们给可执行文件设置了 SUID 权限，则该程序的执行期所有者，就是该文件所有者。还以 前面的 a.out 为例，假如 a.out 设置了 SUID，并且其所有者是 root，系统当前用户是 simon，当 simon 运行 a.out 的时 候，a.out 在运行期的所有者就是 root，这时 a.out 可以存取只有 root权限才能存取的资源，比如读写 shadow 文件。当 a.out 执行结束 的时候当前用户的权限又回到了 simon 的权限了。 </p><p> passwd 就是设置了 SUID 权限，并且 passwd 的所有者是 root，所以所有的用户都可以执行他，在 passwd 运行期，程序获得临时的 root 权限，这时其可以存取 shadow 文件。当 passwd运行完成，当前用户又回到普通权限。 </p><p>​     同理，设置程序的 SGID，可以使程序运行期可以临时获得所有者组的权限。在团队开发的时候，这个文件权限比较有用，一般系统用 SUID 比较多。 </p><p>​     SGID 可以用于目录，当目录设置了 SGID 之后，在该目录下面建立的所有文件和目录都具有和该目录相同的用户组。 </p><p><em><strong>*Stick bit(*<em><strong>粘贴位</strong></em>*)*</strong></em> </p><p> 对程序，该权限告诉系统在程序完成后在内存中保存一份运行程序的备份，如该程序常用，可为系统节省点时间，不用每次从磁盘加载到内存。<em><strong>*Linux*</strong></em> 当前对文件没有实现这个功能，一些其他的 UNIX 系统实现了这个功能。 </p><p> Stick bit 可以作用于目录，在设置了粘贴位的目录下面的文件和目录，只有所有者和 root可以删除他。现在我们可以回头去看看/tmp/目录的情况，这个目录 设置了粘贴位。所以说，并且所有人都可以对该目录读写执行（777），这样意味着所有人都可以在/tmp/下面创建临时</p><p>目录。因为设置 Stick bit 只有所有者和 root 才能删除目录。这样普通用户只能删除属于自己的文件，而不能删除其他人的文件。如下图所示： </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps4.jpg" alt="img"> </p><p>设置 <em><strong>*SUID*<em><strong>，</strong></em>*SGID*<em><strong>，</strong></em>*Stick bit*</strong></em> </p><p>​     前面介绍过 SUID 与 SGID 的功能，那么，如何打开文件使其成为具有 SUID 与 SGID 的权限呢？这就需要使用数字更改权限了。现在应该知道，使用数字 更改权限的方式为“3 个数字”的组合，那么，如果在这 3 个数字之前再加上一个数字，最前面的数字就表示这几个属性了（注：通常我们使用 chmod xyz filename 的方式来设置 filename 的属性时，则是假设没有SUID、SGID 及 Sticky bit）。<br>​     4 为 SUID<br>​     2 为 SGID<br>​     1 为 Sticky bit<br>​     假设要将一个文件属性改为“-rwsr-xr-x”，由于 s 在用户权限中，所以是 SUID，因此，在原先的 755 之前还要加上 4，也就是使用“chmod 4755 filename”来设置。 </p><p>​     SUID 也可以用“chmod u+s filename”来设置，“chmod u-s filename”来取消 SUID 设置；同样，SGID 可以用“chmod g+s filename”，“chmod g-s filename”来取消 SGID 设置。 </p><p>一般来说，使用过 Linux 的同学都知道，Linux 文件的权限有 rwx，所有者、所有组、其它用户的 rwx 权限是彼此独立的。为此，经常会听到如果某个 web 文件需要被修改的话，需要加上 777 的权限，这就是让所有用户可写。 </p><p> 但仔细一想，这样的权限未免有些想得比较天真，没有考滤特殊情况。例如/tmp 目录默认权限是 777，而且有些文件也是允许所有用户访问修改的，那么是不 是任何一个用户都可以将这些删除呢？再如/etc/shadow 保存的是用户密码文件，默认情况下它的权限是 640，那么只有 shadow 的 owner(root)才能修改它，按照常规理解，这是不可理解的，因为每个用户都可能修改密码，也就是会修改这个文件。 </p><p>​     为了把这些情况解释清楚，需要引入 Linux 特殊文件权限的概念。Linux 特殊文件权限有三个玩意：sticky bit、SGID、SUID，以下一一道来。 </p><p> sticky bit </p><p>​     sticky bit 只对目录有效，使目录下的文件，只有文件拥有者才能删除（如果他不属于 owner，仅属于group 或者 other，就算他有 w 权限，也不能删除文件）。 </p><p> 加 sticky bit 的方法： </p><p> chmod o+t /tmp 或者 </p><p> chmod 1777 /tmp </p><p> 查看是否加了 sticky bit，用 ls -l，可以看到有类似这样的权限：“-rwxrwxrwt”，t 就代表已经加上了 sticky bit，而且生效了，如果显示的是“-rwxrwxrwT”，说明也已经加上了 sticky bit，但没有生效（因为本来 other 就没有写的权限）。 </p><p> 看看/tmp 目录的权限，就是 drwxrwxrwt 吧 </p><p> SGID(The Set GroupID ) </p><p> 加上 SGID 的文件，表示运行这个程序时，是临时以这个文件的拥有组的身份运行的；加上 SGID 的文件夹，表示在这个目录下创建的文件属于目录所有的组，而不是创建人所在的组，在这个目录下创建的目录继承本目录的 SGID。 </p><p> 加 SGID 的方法： </p><p> chmod g+s /tmp 或 </p><p> chmod 2777 /tmp </p><p> 查看是否加了 SGID，用 ls -l，可以看到类似这样的权限“drwxrwsrwx”，s 就代表已经加上了 SGID，而且生效，如果显示“drwxrwSrwx”，说明已经加上了 SGID，但没有生效（因为本来 group 就没有执行的权限）。 </p><p> SUID(The Set UserID) </p><p> SUID 与 SGID 是一样的，惟一不同的是，运行时是以这个文件的拥有者身份来运行。 </p><p> 加 SUID 的方法： </p><p> chmod o+s /tmp 或 </p><p> chmod 4777 /tmp </p><p> 同样的，加了 SUID 的文件权限有这类似这两种：“drwsrwxrwx”、“drwSrwxrwx”。 </p><p>​     看看 passwd 命令的权限：ll /usr/bin/passwd，是”-rwsr-x-rx”，终于知道为什么执行 passwd 时，可以修改/etc/shadow 文件了吧 </p><p> SUID：置于 u 的 x 位，原位置有执行权限，就置为 s，没有了为 S .<br> SGID：置于 g 的 x 位，原位置有执行权限，就置为 s，没有了为 S .<br> STICKY：粘滞位，置于 o 的 x 位，原位置有执行权限，就置为 t ，否则为 T . </p><p>**<br>**</p><p>****3****、超级权限控制 </p><table><thead><tr><th></th><th>在 Linux 操作系统中，root 的权限是最高的，也被称为超级权限的拥有者。普通用户无法执行的操作，root 用户都能完</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>成，所以也被称之为超级管理用户。 </p><p>在系统中，每个文件、目录和进程，都归属于某一个用户，没有用户许可其它普通用户是无法操作的，但对 root 除外。root</p><p>用户的特权性还表现在 root 可以超越任何用户和用户组来对文件或目录进行读取、修改或删除（在系统正常的许可范围内）；</p><p>对可执行程序的执行、终止；对硬件设备的添加、创建和移除等；也可以对文件和目录进行属主和权限进行修改，以适合系</p><p>统管理的需要（因为 root 是系统中权限最高的特权用户）； </p><p>****3.1****、对超级用户和普通用户的理解 </p><p>****3.1.1****、什么是超级用户； </p><p>在所有 Linux 系统中，系统都是通过 UID 来区分用户权限级别的，而 UID 为 0 的用户被系统约定为是具有超级权限。超级用</p><p>户具有在系统约定的最高权限满园内操作，所以说超级用户可以完成系统管理的所有工具；我们可以通过/etc/passwd 来查得</p><p>UID 为 0 的用户是 root，而且只有 root 对应的 UID 为 0，从这一点来看，root 用户在系统中是无可替代的至高地位和无限制</p><p>权限。root 用户在系统中就是超级用户； </p><p>****3.1.2****、理解 <em><strong>*UID*</strong></em> 和用户的对应关系 </p><p>当系统默认安装时，系统用户和是一对一的对关系，也就是说一个 UID 对应一个用户。我们知道用户身份是通过 UID 来</p><p>确认的，我们在 中的 UID 的解说中有谈到“UID 是确认用户权限的标识，</p><p>用户登录系统所处的角色是通过 UID 来实现的，而非用户名；把几个用户共用一个 UID 是危险的，比如我们把普通用户的</p><p>UID 改为 0，和 root 共用一个 UID ，这事实上就造成了系统管理权限的混乱。如果我们想用 root 权限，可以通过 su 或 sudo</p><p>来实现；切不可随意让一个用户和 root 分享同一个 UID ；” </p><p>在系统中，能不能让 UID 和用户是一对多的关系？是可以的，比如我们可以把一个 UID 为 0 这个值分配给几个用户共同使用，</p><p>这就是 UID 和用户的一对多的关系。但这样做的确有点危险；相同 UID 的用户具有相同的身份和权限。比如我们在系统中把</p><p>beinan 这个普通用户的 UID 改为 0 后，事实上这个普通用户就具有了超级权限，他的能力和权限和 root 用户一样；用户 beinan</p><p>所有的操作都将被标识为 root 的操作，因为 beinan 的 UID 为 0,而 UID 为 0 的用户是 root ，是不是有点扰口？也可以理解为</p><p>UID 为 0 的用户就是 root ，root 用户的 UID 就是 0； </p><p>UID 和用户的一对一的对应关系 ，只是要求管理员进行系统管理时，所要坚守的准则，因为系统安全还是第一位的。所以我</p><p>们还是把超级权限保留给 root 这唯一的用户是最好的选择； </p><p>如果我们不把 UID 的 0 值的分享给其它用户使用，只有 root 用户是唯一拥有 UID=0 的话，root 用户就是唯一的超级权限用户； </p><p>****3.1.3****、普通用户和伪装用户 </p><p>与超级用户相对的就是普通用户和虚拟（也被称为伪装用户），普通和伪装用户都是受限用户；但为了完成特定的任务，普</p><p>通用户和伪装用户也是必须的；Linux 是一个多用户、多任务的操作系统，多用户主要体现在用户的角色的多样性，不同的用</p><p>户所分配的权限也不同；这也是 Linux 系统比 Windows 系统更为安全的本质所在，即使是现在最新版本的 Windows 2003 ，</p><p>也无法抹去其单用户系统的烙印； </p><p><em><strong>*3.2.*</strong></em> 超级用户（权限）在系统管理中的作用 </p><p>超级权限用户（<em><strong>*UID*</strong></em> 为 <em><strong>*0*</strong></em> 的用户）到底在系统管理中起什么作用呢？主要表现在以下两点； </p><p>****3.2.1****、对任何文件、目录或进程进行操作； </p><p>但值得注意的是这种操作是在系统最高许可范围内的操作；有些操作就是具有超级权限的 root 也无法完成； </p><p>比如/proc 目录，/proc 是用来反应系统运行的实时状态信息的，因此即便是 root 也无能为力；它的权限如下 </p><p>[root@localhost ~]# pwd </p><p>/root </p><p>[root@localhost ~]# cd / </p><p>[root@localhost /]# ls -ld  /proc/ </p><p>dr-xr-xr-x  134 root root 0 2005-10-27  /proc/ </p><p>就是这个目录，只能是读和执行权限，但绝对没有写权限的；就是我们把/proc 目录的写权限打开给 root，root 用户也是不能</p><p>进行写操作； </p><p>[root@localhost ~]# chmod 755 /proc </p><p>[root@localhost /]# ls -ld  /proc/ </p><p>drwxr-xr-x  134 root root 0 2005-10-27  /proc/ </p><p>[root@localhost /]# cd /proc/ </p><p>[root@localhost proc]# mkdir testdir </p><p>mkdir: 无法创建目录‘testdir’: 没有那个文件或目录<br>****3.2.2****、对于涉及系统全局的系统管理； </p><p>硬件管理、文件系统理解、用户管理以及涉及到的系统全局配置等等……如果您执行某个命令或工具时，提示您无权限，大多</p><p>是需要超级权限来完成； </p><p>比如用 adduser 来添加用户，这个只能用通过超级权限的用户来完成； </p><p>****3.2.3****、超级权限的不可替代性； </p><p>由于超级权限在系统管理中的不可缺少的重要作用，为了完成系统管理任务，我们必须用到超级权限；在一般情况下，为了</p><p>系统安全，对于一般常规级别的应用，不需要 root 用户来操作完成，root 用户只是被用来管理和维护系统之用；比如系统日</p><p>志的查看、清理，用户的添加和删除…… </p><p>在不涉及系统管理的工作的环境下，普通用户足可以完成，比如编写一个文件，听听音乐；用 gimp 处理一个图片等…… 基</p><p>于普通应用程序的调用，大多普通用户就可以完成； </p><p>当我们以普通权限的用户登录系统时，有些系统配置及系统管理必须通过超级权限用户完成，比如对系统日志的管理，添加</p><p>和删除用户。而如何才能不直接以 root 登录，却能从普通用户切换到 root 用户下才能进行操作系统管理需要的工作，这就涉</p><p>及到超级权限管理的问题； </p><p>获取超级权限的过程，就是切换普通用户身份到超级用户身份的过程；这个过程主要是通过 su 和 sudo 来解决； </p><p>****3.3****、使用 <em><strong>*su*</strong></em> 命令临时切换用户身份； </p><p><em><strong>*3.3.1*<em><strong>、</strong></em>*su*</strong></em> 的适用条件和威力 </p><p>su 命令就是切换用户的工具，怎么理解呢？比如我们以普通用户 beinan 登录的，但要添加用户任务，执行 useradd ，beinan</p><p>用户没有这个权限，而这个权限恰恰由 root 所拥有。解决办法无法有两个，一是退出 beinan 用户，重新以 root 用户登录，</p><p>但这种办法并不是最好的；二是我们没有必要退出 beinan 用户，可以用 su 来切换到 root 下进行添加用户的工作，等任务完</p><p>成后再退出 root。我们可以看到当然通过 su 切换是一种比较好的办法； </p><p>通过 su 可以在用户之间切换，如果超级权限用户 root 向普通或虚拟用户切换不需要密码，什么是权力？这就是！而普通用户</p><p>切换到其它任何用户都需要密码验证； </p><p><em><strong>*3.3.2*<em><strong>、</strong></em>*su*</strong></em> 的用法： </p><p>su [OPTION 选项参数] [用户] </p><p> -, -l, –login       登录并改变到所切换的用户环境； </p><p> -c, –commmand=COMMAND    执行一个命令，然后退出所切换到的用户环境； </p><p>至于更详细的，请参看 man su ； </p><p><em><strong>*3.3.3*<em><strong>、</strong></em>*su*</strong></em> 的范例： </p><p>su 在不加任何参数，默认为切换到 root 用户，但没有转到 root 用户家目录下，也就是说这时虽然是切换为 root 用户了，但</p><p>并没有改变 root 登录环境；用户默认的登录环境，可以在/etc/passwd 中查得到，包括家目录，SHELL 定义等； </p><p>[beinan@localhost ~]$ su </p><p>Password: </p><p>[root@localhost beinan]# pwd </p><p>/home/beinan </p><p>su 加参数 - ，表示默认切换到 root 用户，并且改变到 root 用户的环境； </p><p>[beinan@localhost ~]$ pwd </p><p>/home/beinan </p><p>[beinan@localhost ~]$ su - </p><p>Password: </p><p>[root@localhost ~]# pwd </p><p>/root </p><p>su 参数 - 用户名 </p><p>[beinan@localhost ~]$ su - root  注：这个和 su  - 是一样的功能； </p><p>Password: </p><p>[root@localhost ~]# pwd </p><p>/root </p><p>[beinan@localhost ~]$ su - linuxsir  注：这是切换到 linuxsir 用户 </p><p>Password:  注：在这里输入密码； </p><p>[linuxsir@localhost ~]$ pwd  注：查看用户当前所处的位置； </p><p>/home/linuxsir </p><p>[linuxsir@localhost ~]$ id  注：查看用户的 UID 和 GID 信息，主要是看是否切换过来了； </p><p>uid=505(linuxsir) gid=502(linuxsir) groups=0(root),500(beinan),502(linuxsir) </p><p>[linuxsir@localhost ~]$ </p><p>[beinan@localhost ~]$ su - -c ls  注：这是 su 的参数组合，表示切换到 root 用户，并且改变到 root 环境，然后列出</p><p>root 家目录的文件，然后退出 root 用户； </p><p>Password:  注：在这里输入 root 的密码； </p><p>anaconda-ks.cfg  Desktop  install.log  install.log.syslog  testgroup  testgroupbeinan  testgrouproot </p><p>[beinan@localhost ~]$ pwd  注：查看当前用户所处的位置； </p><p>/home/beinan </p><p>[beinan@localhost ~]$ id  注：查看当前用户信息； </p><p>uid=500(beinan) gid=500(beinan) groups=500(beinan)<br><em><strong>*3.3.4*<em><strong>、</strong></em>*su*</strong></em> 的优缺点； </p><p>su 的确为管理带来方便，通过切换到 root 下，能完成所有系统管理工具，只要把 root 的密码交给任何一个普通用户，他都</p><p>能切换到 root 来完成所有的系统管理工作； </p><p>但通过 su 切换到 root 后，也有不安全因素；比如系统有 10 个用户，而且都参与管理。如果这 10 个用户都涉及到超级权限</p><p>的运用，做为管理员如果想让其它用户通过 su 来切换到超级权限的 root，必须把 root 权限密码都告诉这 10 个用户；如果这</p><p>10 个用户都有 root 权限，通过 root 权限可以做任何事，这在一定程度上就对系统的安全造成了威协；想想 Windows 吧，简</p><p>直就是恶梦； </p><p>“没有不安全的系统，只有不安全的人”，我们绝对不能保证这 10 个用户都能按正常操作流程来管理系统，其中任何一人对系</p><p>统操作的重大失误，都可能导致系统崩溃或数据损失； </p><p>所以 su 工具在多人参与的系统管理中，并不是最好的选择，su 只适用于一两个人参与管理的系统，毕竟 su 并不能让普通用</p><p>户受限的使用； </p><p>超级用户 root 密码应该掌握在少数用户手中，这绝对是真理！所以集权而治的存在还是有一定道理的； </p><p><em><strong>*3.4*<em><strong>、</strong></em>*sudo*</strong></em> 授权许可使用的<em><strong>*su*<em><strong>，也是受限制的</strong></em>*su*</strong></em> </p><p><em><strong>*3.4.1. sudo*</strong></em> 的适用条件； </p><p>由于 su 对切换到超级权限用户 root 后，权限的无限制性，所以 su 并不能担任多个管理员所管理的系统。如果用 su 来切换</p><p>到超级用户来管理系统，也不能明确哪些工作是由哪个管理员进行的操作。特别是对于服务器的管理有多人参与管理时，最</p><p>好是针对每个管理员的技术特长和管理范围，并且有针对性的下放给权限，并且约定其使用哪些工具来完成与其相关的工作，</p><p>这时我们就有必要用到 sudo。 </p><p>通过 sudo，我们能把某些超级权限有针对性的下放，并且不需要普通用户知道 root 密码，所以 sudo 相对于权限无限制性的</p><p>su 来说，还是比较安全的，所以 sudo 也能被称为受限制的 su ；另外 sudo 是需要授权许可的，所以也被称为授权许可的</p><p>su； </p><p>sudo 执行命令的流程是当前用户切换到 root（或其它指定切换到的用户），然后以 root（或其它指定的切换到的用户）身份</p><p>执行命令，执行完成后，直接退回到当前用户；而这些的前提是要通过 sudo 的配置文件/etc/sudoers 来进行授权； </p><p><em><strong>*3.4.2*<em><strong>、从编写 <em><strong>*sudo*</strong></em> 配置文件</strong></em>*/etc/sudoers*</strong></em> 开始； </p><p>sudo 的配置文件是/etc/sudoers ，我们可以用他的专用编辑工具 visodu ，此工具的好处是在添加规则不太准确时，保存退</p><p>出时会提示给我们错误信息；配置好后，可以用切换到您授权的用户下，通过 sudo -l 来查看哪些命令是可以执行或禁止的； </p><p>/etc/sudoers 文件中每行算一个规则，前面带有#号可以当作是说明的内容，并不执行；如果规则很长，一行列不下时，可以</p><p>用\号来续行，这样看来一个规则也可以拥有多个行； </p><p>/etc/sudoers 的规则可分为两类；一类是别名定义，另一类是授权规则；别名定义并不是必须的，但授权规则是必须的； </p><p><em><strong>*3.4.3*<em><strong>、</strong></em>*/etc/sudoers*</strong></em> 配置文件中别名规则 </p><p>别名规则定义格式如下： </p><p>Alias_Type  NAME = item1, item2, … </p><p>或 </p><p>Alias_Type NAME = item1, item2, item3 : NAME = item4, item5 </p><p>别名类型（****Alias_Type****）：别名类型包括如下四种 </p><p><em><strong>*Host_Alias*</strong></em> 定义主机别名； </p><p><em><strong>*User_Alias*</strong></em> 用户别名，别名成员可以是用户，用户组（前面要加%号） </p><p><em><strong>*Runas_Alias*</strong></em> 用来定义 runas 别名，这个别名指定的是“目的用户”，即 sudo 允许切换至的用户； </p><p><em><strong>*Cmnd_Alias*</strong></em> 定义命令别名； </p><p><em><strong>*NAME*</strong></em> 就是别名了，NMAE 的命名是包含大写字母、下划线以及数字，但必须以一个大写字母开头，比如 SYNADM、SYN_ADM</p><p>或 SYNAD0 是合法的，sYNAMDA 或 1SYNAD 是不合法的； </p><p>**<br>**</p><p><em><strong>*item*</strong></em> 按中文翻译是项目，在这里我们可以译成成员，如果一个别名下有多个成员，成员与成员之间，通过半角,号分隔；成员</p><p>在必须是有效并事实存在的。什么是有效的呢？比如主机名，可以通过 w 查看用户的主机名（或 ip 地址），如果您只是本地</p><p>机操作，只通过 hostname 命令就能查看；用户名当然是在系统中存在的，在/etc/paswd 中必须存在；对于定义命令别名，</p><p>成员也必须在系统中事实存在的文件名（需要绝对路径）； </p><p>item 成员受别名类型 Host_Alias、User_Alias、Runas_Alias、Cmnd_Alias 制约，定义什么类型的别名，就要有什么类型的</p><p>成员相配。我们用 Host_Alias 定义主机别名时，成员必须是与主机相关相关联，比如是主机名（包括远程登录的主机名）、</p><p>ip 地址（单个或整段）、掩码等；当用户登录时，可以通过 w 命令来查看登录用户主机信息；用 User_Alias 和 Runas_Alias</p><p>定义时，必须要用系统用户做为成员；用 Cmnd_Alias 定义执行命令的别名时，必须是系统存在的文件，文件名可以用通配</p><p>符表示，配置 Cmnd_Alias 时命令需要绝对路径； </p><p>其中 Runas_Alias 和 User_Alias 有点相似，但与 User_Alias 绝对不是同一个概念，Runas_Alias 定义的是某个系统用户</p><p>可以 sudo 切换身份到 Runas_Alias 下的成员；我们在授权规则中以实例进行解说； </p><p>别名规则是每行算一个规则，如果一个别名规则一行容不下时，可以通过\来续行；同一类型别名的定义，一次也可以定义几</p><p>个别名，他们中间用:号分隔， </p><p>Host_Alias  HT01=localhost,st05,st04,10,0,0,4,255.255.255.0,192.168.1.0/24  注：定义主机别名 HT01，通过=号列</p><p>出成员 </p><p>Host_Alias  HT02=st09,st10  注：主机别名 HT02，有两个成员； </p><p>Host_Alias  HT01=localhost,st05,st04,10,0,0,4,255.255.255.0,192.168.1.0/24:HT02=st09,st10  注：上面的两条对</p><p>主机的定义，可以通过一条来实现，别名之间用:号分割； </p><p>注：我们通过 Host_Alias 定义主机别名时，项目可以是主机名、可以是单个 ip（整段 ip 地址也可以），也可以是网络掩码；</p><p>如果是主机名，必须是多台机器的网络中，而且这些机器得能通过主机名相互通信访问才有效。那什么才算是通过主机名相</p><p>互通信或访问呢？比如 ping 主机名，或通过远程访问主机名来访问。在我们局域网中，如果让计算机通过主机名访问通信，</p><p>必须设置/etc/hosts，/etc/resolv.conf ，还要有 DNS 做解析，否则相互之间无法通过主机名访问；在设置主机别名时，如果</p><p>项目是中某个项目是主机名的话，可以通过 hostname 命令来查看本地主机的主机名，通过 w 命令查来看登录主机是来源，</p><p>通过来源来确认其它客户机的主机名或 ip 地址；对于主机别名的定义，看上去有点复杂，其实是很简单。 </p><p>如果您不明白 Host_Alias 是怎么回事，也可以不用设置主机别名，在定义授权规则时通过 ALL 来匹配所有可能出现的主机情</p><p>况。如果您把主机方面的知识弄的更明白，的确需要多多学习。 </p><p>User_Alias   SYSAD=beinan,linuxsir,bnnnb,lanhaitun  注：定义用户别名，下有四个成员；要在系统中确实在存在的； </p><p>User_Alias   NETAD=beinan,bnnb  注：定义用户别名 NETAD ，我想让这个别名下的用户来管理网络，所以取了 NETAD 的</p><p>别名； </p><p>User_Alias   WEBMASTER=linuxsir   注：定义用户别名 WEBMASTER，我想用这个别名下的用户来管理网站； </p><p>User_Alias   SYSAD=beinan,linuxsir,bnnnb,lanhaitun:NETAD=beinan,bnnb:WEBMASTER=linuxsir  注：上面三行的别名</p><p>定义，可以通过这一行来实现，请看前面的说明，是不是符合？ </p><p>Cmnd_Alias  USERMAG=/usr/sbin/adduser,/usr/sbin/userdel,/usr/bin/passwd [A-Za-z]*,/bin/chown,/bin/chmod </p><p>注意：命令别名下的成员必须是文件或目录的绝对路径； </p><p>Cmnd_Alias   DISKMAG=/sbin/fdisk,/sbin/parted </p><p>Cmnd_Alias   NETMAG=/sbin/ifconfig,/etc/init.d/network </p><p>Cmnd_Alias   KILL = /usr/bin/kill </p><p>Cmnd_Alias   PWMAG = /usr/sbin/reboot,/usr/sbin/halt </p><p>Cmnd_Alias   SHELLS = /usr/bin/sh, /usr/bin/csh, /usr/bin/ksh, \ </p><p> /usr/local/bin/tcsh, /usr/bin/rsh,  \ </p><p> /usr/local/bin/zsh </p><p>注：这行定义命令别名有点长，可以通过 \ 号断行； </p><p>Cmnd_Alias   SU = /usr/bin/su,/bin,/sbin,/usr/sbin,/usr/bin  </p><p>在上面的例子中，有 KILL 和 PWMAG 的命令别名定义，我们可以合并为一行来写，也就是等价行； </p><p>Cmnd_Alias   KILL = /usr/bin/kill:PWMAG = /usr/sbin/reboot,/usr/sbin/halt  注：这一行就代表了 KILL 和 PWMAG</p><p>命令别名，把 KILL 和 PWMAG 的别名定义合并在一行写也是可以的； </p><p>Runas_Alias   OP = root, operator </p><p>Runas_Alias  DBADM=mysql:OP = root, operator  注：这行是上面两行的等价行；至于怎么理解 Runas_Alias ，我们必须</p><p>得通过授权规则的实例来理解；<br><em><strong>*3.4.4*<em><strong>、</strong></em>*/etc/sudoers*</strong></em> 中的授权规则： </p><p>授权规则是分配权限的执行规则，我们前面所讲到的定义别名主要是为了更方便的授权引用别名；如果系统中只有几个用户，</p><p>其实下放权限比较有限的话，可以不用定义别名，而是针对系统用户直接直接授权，所以在授权规则中别名并不是必须的； </p><p>授权规则并不是无章可寻，我们只说基础一点的，比较简单的写法，如果您想详细了解授权规则写法的，请参看 man sudoers </p><p>授权用户  主机=命令动作  </p><p>这三个要素缺一不可，但在动作之前也可以指定切换到特定用户下，在这里指定切换的用户要用( )号括起来，如果不需要密</p><p>码直接运行命令的，应该加 NOPASSWD:参数，但这些可以省略；举例说明； </p><p>实例一： </p><p>beinan ALL=/bin/chown,/bin/chmod  </p><p>如果我们在/etc/sudoers 中添加这一行，表示 beinan 可以在任何可能出现的主机名的系统中，可以切换到 root 用户下执行 </p><p>/bin/chown 和/bin/chmod 命令，通过 sudo -l 来查看 beinan 在这台主机上允许和禁止运行的命令； </p><p>值得注意的是，在这里省略了指定切换到哪个用户下执行/bin/shown 和/bin/chmod 命令；在省略的情况下默认为是切换到 root</p><p>用户下执行；同时也省略了是不是需要 beinan 用户输入验证密码，如果省略了，默认为是需要验证密码。 </p><p>为了更详细的说明这些，我们可以构造一个更复杂一点的公式； </p><p>授权用户 主机<em><strong>*=[(*<em><strong>切换到哪些用户或用户组</strong></em>*)] [*<em><strong>是否需要密码验证</strong></em>*]*</strong></em> 命令 <em><strong>*1,[(*<em><strong>切换到哪些用户或用户组</strong></em>*)] [*<em><strong>是否需要密码验证</strong></em>*]*</strong></em> </p><p>****[****命令 ****2],[(*<em><strong>切换到哪些用户或用户组</strong></em>*)] [*<em><strong>是否需要密码验证</strong></em>*] [****命令 <em><strong>*3]……*</strong></em> </p><p>注解： </p><p>凡是[ ]中的内容，是可以省略；命令与命令之间用,号分隔；通过本文的例子，可以对照着看哪些是省略了，哪些地方需要有</p><p>空格； </p><p>在[(切换到哪些用户或用户组)] ，如果省略，则默认为 root 用户；如果是 ALL ，则代表能切换到所有用户；注意要切换到的</p><p>目的用户必须用()号括起来，比如(ALL)、(beinan) </p><p>实例二： </p><p>beinan  ALL=(root)   /bin/chown, /bin/chmod  </p><p>如果我们把第一个实例中的那行去掉，换成这行；表示的是 beinan 可以在任何可能出现的主机名的主机中，可以切换到 root</p><p>下执行 /bin/chown ，可以切换到任何用户招执行/bin/chmod 命令，通过 sudo -l 来查看 beinan 在这台主机上允许和禁止运</p><p>行的命令； </p><p>实例三： </p><p>beinan  ALL=(root)  NOPASSWD:   /bin/chown,/bin/chmod  </p><p>如果换成这个例子呢？表示的是 beinan 可以在任何可能出现的主机名的主机中，可以切换到 root 下执行 /bin/chown ，不需</p><p>要输入 beinan 用户的密码；并且可以切换到任何用户下执行/bin/chmod 命令，但执行 chmod 时需要 beinan 输入自己的密</p><p>码；通过 sudo -l 来查看 beinan 在这台主机上允许和禁止运行的命令； </p><p>关于一个命令动作是不是需要密码，我们可以发现在系统在默认的情况下是需要用户密码的，除非特加指出不需要用户需要</p><p>输入自己密码，所以要在执行动作之前加入 NOPASSWD: 参数； </p><p>有可能有的弟兄对系统管理的命令不太懂，不知道其用法，这样就影响了他对 sudoers 定义的理解，下面我们再举一个最简</p><p>单，最有说服务力的例子； </p><p>实例四： </p><p>比如我们想用 beinan 普通用户通过 more /etc/shadow 文件的内容时，可能会出现下面的情况； </p><p>[beinan@localhost ~]$ more /etc/shadow </p><p>/etc/shadow: 权限不够 </p><p>这时我们可以用 sudo more /etc/shadow 来读取文件的内容；就就需要在/etc/soduers 中给 beinan 授权； </p><p>于是我们就可以先 su 到 root 用户下通过 visudo 来改/etc/sudoers ；（比如我们是以 beinan 用户登录系统的） </p><p>[beinan@localhost ~]$ su </p><p>Password:   注：在这里输入 root 密码 </p><p>下面运行 visodu； </p><p>[root@localhost beinan]# visudo   注：运行 visudo 来改 /etc/sudoers  </p><p>加入如下一行，退出保存；退出保存，在这里要会用 vi，visudo 也是用的 vi 编辑器；至于 vi 的用法不多说了； </p><p>beinan ALL=/bin/more  表示 beinan 可以切换到 root 下执行 more 来查看文件； </p><p>退回到 beinan 用户下，用 exit 命令； </p><p>[root@localhost beinan]# exit </p><p>exit </p><p>[beinan@localhost ~]$ </p><p>查看 beinan 的通过 sudo 能执行哪些命令？ </p><p>[beinan@localhost ~]$ sudo -l </p><p>Password:  注：在这里输入 beinan 用户的密码 </p><p>User beinan may run the following commands on this host:  注：在这里清晰的说明在本台主机上，beinan 用户可以以</p><p>root 权限运行 more ；在 root 权限下的 more ，可以查看任何文本文件的内容的； </p><p> (root) /bin/more </p><p>最后，我们看看是不是 beinan 用户有能力看到/etc/shadow 文件的内容； </p><p>[beinan@localhost ~]$ sudo more /etc/shadow </p><p>beinan 不但能看到 /etc/shadow 文件的内容，还能看到只有 root 权限下才能看到的其它文件的内容，比如； </p><p>[beinan@localhost ~]$ sudo more /etc/gshadow </p><p>对于 beinan 用户查看和读取所有系统文件中，我只想把/etc/shadow 的内容可以让他查看；可以加入下面的一行； </p><p>beinan ALL=/bin/more  /etc/shadow </p><p>题外话：有的弟兄会说，我通过 su 切换到 root 用户就能看到所有想看的内容了，哈哈，对啊。但咱们现在不是在讲述 sudo</p><p>的用法吗？如果主机上有多个用户并且不知道 root 用户的密码，但又想查看某些他们看不到的文件，这时就需要管理员授权</p><p>了；这就是 sudo 的好处； </p><p>实例五：练习用户组在<em><strong>*/etc/sudoers*</strong></em> 中写法； </p><p>如果用户组出现在/etc/sudoers 中，前面要加%号，比如%beinan ，中间不能有空格； </p><p>%beinan  ALL=/usr/sbin/<em>,/sbin/</em> </p><p>如果我们在 /etc/sudoers 中加上如上一行，表示 beinan 用户组下的所有成员，在所有可能的出现的主机名下，都能切换到</p><p>root 用户下运行 /usr/sbin 和/sbin 目录下的所有命令； </p><p>实例六：练习取消某类程序的执行； </p><p>取消程序某类程序的执行，要在命令动作前面加上!号； 在本例中也出现了通配符的*的用法； </p><p>beinan  ALL=/usr/sbin/<em>,/sbin/</em>,!/usr/sbin/fdisk   注：把这行规则加入到/etc/sudoers 中；但您得有 beinan 这个用</p><p>户组，并且 beinan 也是这个组中的才行； </p><p>本规则表示 beinan 用户在所有可能存在的主机名的主机上运行/usr/sbin 和/sbin 下所有的程序，但 fdisk 程序除外； </p><p>[beinan@localhost ~]$ sudo -l </p><p>Password: 注：在这里输入 beinan 用户的密码； </p><p>User beinan may run the following commands on this host: </p><p>(root) /usr/sbin/* </p><p>(root) /sbin/* </p><p>(root) !/sbin/fdisk </p><p>[beinan@localhost ~]$ sudo /sbin/fdisk -l </p><p>Sorry, user beinan is not allowed to execute ‘/sbin/fdisk -l’ as root on localhost. </p><p>注：不能切换到 root 用户下运行 fdisk 程序； </p><p>实例七：别名的运用的实践； </p><p>假如我们就一台主机 localhost，能通过 hostname 来查看，我们在这里就不定义主机别名了，用 ALL 来匹配所有可能出现的</p><p>主机名；并且有 beinan、linuxsir、lanhaitun 用户；主要是通过小例子能更好理解；sudo 虽然简单好用，但能把说的明白的</p><p>确是件难事；最好的办法是多看例子和 man soduers ； </p><p>User_Alias  SYSADER=beinan,linuxsir,%beinan </p><p>User_Alias  DISKADER=lanhaitun </p><p>Runas_Alias  OP=root </p><p>Cmnd_Alias   SYDCMD=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd </p><p>root </p><p>Cmnd_Alias   DSKCMD=/sbin/parted,/sbin/fdisk  注：定义命令别名 DSKCMD，下有成员 parted 和 fdisk ； </p><p>SYSADER   ALL= SYDCMD,DSKCMD </p><p>DISKADER  ALL=(OP)  DSKCMD </p><p>注解： </p><p>第一行：定义用户别名 SYSADER 下有成员 beinan、linuxsir 和 beinan 用户组下的成员，用户组前面必须加%号； </p><p>第二行：定义用户别名 DISKADER ，成员有 lanhaitun </p><p>第三行：定义 Runas 用户，也就是目标用户的别名为 OP，下有成员 root </p><p>第四行：定义 SYSCMD 命令别名，成员之间用,号分隔，最后的!/usr/bin/passwd root 表示不能通过 passwd 来更改 root 密</p><p>码； </p><p>第五行：定义命令别名 DSKCMD，下有成员 parted 和 fdisk ； </p><p>第六行： 表示授权 SYSADER 下的所有成员，在所有可能存在的主机名的主机下运行或禁止 SYDCMD 和 DSKCMD 下定义</p><p>的命令。更为明确遥说，beinan、linuxsir 和 beinan 用户组下的成员能以 root 身份运行 chown 、chmod 、adduser、passwd，</p><p>但不能更改 root 的密码；也可以以 root 身份运行 parted 和 fdisk ，本条规则的等价规则是； </p><p>beinan,linuxsir,%beinan  ALL=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd </p><p>[A-Za-z]*,!/usr/bin/passwd root,/sbin/parted,/sbin/fdisk  </p><p>第七行：表示授权 DISKADER 下的所有成员，能以 OP 的身份，来运行 DSKCMD ，不需要密码；更为明确的说 lanhaitun </p><p>能以 root 身份运行 parted 和 fdisk 命令；其等价规则是： </p><p>lanhaitun  ALL=(root) /sbin/parted,/sbin/fdisk  </p><p>可能有的弟兄会说我想不输入用户的密码就能切换到root并运行SYDCMD和DSKCMD 下的命令，那应该把把NOPASSWD:</p><p>加在哪里为好？理解下面的例子吧，能明白的； </p><p>SYSADER   ALL= NOPASSWD:  SYDCMD, NOPASSWD: DSKCMD<br><em><strong>*3.4.5*<em><strong>、</strong></em>*/etc/sudoers*</strong></em> 中其它的未尽事项； </p><p>在授权规则中，还有 NOEXEC:和 EXEC 的用法，自己查 man sudoers 了解；还有关于在规则中通配符的用法，也是需要了</p><p>解的。这些内容不多说了，毕竟只是一个入门性的文档。soduers 配置文件要多简单就有多简单，要多难就有多难，就看自己</p><p>的应用了。 </p><p><em><strong>*3.4.6*<em><strong>、</strong></em>*sudo*</strong></em> 的用法； </p><p>我们在前面讲的/etc/sudoers 的规则写法，最终的目的是让用户通过 sudo 读取配置文件中的规则来实现匹配和授权，以便替</p><p>换身份来进行命令操作，进而完成在其权限下不可完成的任务； </p><p>我们只说最简单的用法；更为详细的请参考 man sudo </p><p>sudo [参数选项] 命令 </p><p>-l 列出用户在主机上可用的和被禁止的命令；一般配置好/etc/sudoers 后，要用这个命令来查看和测试是不是配置正确的； </p><p>-v 验证用户的时间戳；如果用户运行 sudo 后，输入用户的密码后，在短时间内可以不用输入口令来直接进行 sudo 操作；</p><p>用-v 可以跟踪最新的时间戳； </p><p>-u 指定以以某个用户执行特定操作； </p><p>-k 删除时间戳，下一个 sudo 命令要求用求提供密码； </p><p>举列： </p><p>首先我们通过 visudo 来改/etc/sudoers 文件，加入下面一行； </p><p>beinan,linuxsir,%beinan  ALL=/bin/chown,/bin/chmod,/usr/sbin/adduser,/usr/bin/passwd </p><p>[A-Za-z]*,!/usr/bin/passwd root,/sbin/parted,/sbin/fdisk </p><p>然后列出 beinan 用户在主机上通过 sudo 可以切换用户所能用的命令或被禁止用的命令； </p><p>[beinan@localhost ~]$ sudo -l  注：列出用户在主机上能通过切换用户的可用的或被禁止的命令； </p><p>Password:  注：在这里输入您的用户密码； </p><p>User beinan may run the following commands on this host: </p><p> (root) /bin/chown  注：可以切换到 root 下用 chown 命令； </p><p> (root) /bin/chmod  注：可以切换到 root 下用 chmod 命令； </p><p> (root) /usr/sbin/adduser 注：可以切换到 root 下用 adduser 命令； </p><p> (root) /usr/bin/passwd  [A-Za-z]* 注：可以切换到 root 下用 passwd 命令； </p><p> (root) !/usr/bin/passwd root  注：可以切换到 root 下，但不能执行 passwd root 来更改 root 密码； </p><p> (root) /sbin/parted   注：可以切换到 root 下执行 parted ； </p><p> (root) /sbin/fdisk  注：可以切换到 root 下执行 fdisk ； </p><p>通过上面的 sudo -l 列出可用命令后，我想通过 chown 命令来改变/opt 目录的属主为 beinan ； </p><p>[beinan@localhost ~]$ ls -ld /opt  注：查看/opt 的属主； </p><p>drwxr-xr-x  26 root root 4096 10 月 27 10:09 /opt  注：得到的答案是归属 root 用户和 root 用户组； </p><p>[beinan@localhost ~]$ sudo chown beinan:beinan /opt  注：通过 chown 来改变属主为 beinan 用户和 beinan 用户组； </p><p>[beinan@localhost ~]$ ls -ld /opt  注：查看/opt 属主是不是已经改变了； </p><p>drwxr-xr-x  26 beinan beinan 4096 10 月 27 10:09 /opt </p><p>我们通过上面的例子发现 beinan 用户能切换到 root 后执行改变用户口令的 passwd 命令；但上面的 sudo -l 输出又明文写着</p><p>不能更改 root 的口令；也就是说除了 root 的口令，beinan 用户不能更改外，其它用户的口令都能更改。下面我们来测试； </p><p>对于一个普通用户来说，除了更改自身的口令以外，他不能更改其它用户的口令。但如果换到 root 身份执行命令，则可以更</p><p>改其它用户的口令； </p><p>比如在系统中有 linuxsir 这个用户, 我们想尝试更改这个用户的口令， </p><p>[beinan@localhost ~]$ passwd linuxsir  注：不通过 sudo 直接运行 passwd 来更改 linuxsir 用户的口令； </p><p>passwd: Only root can specify a user name.  注：失败，提示仅能通过 root 来更改； </p><p>[beinan@localhost ~]$ sudo passwd linuxsir  注：我们通过/etc/sudoers 的定义，让 beinan 切换到 root 下执行 passwd </p><p>命令来改变 linuxsir 的口令； </p><p>Changing password for user linuxsir. </p><p>New UNIX password:  注：输入新口令； </p><p>Retype new UNIX password:  注：再输入一次； </p><p>passwd: all authentication tokens updated successfully.  注：改变成功； </p><p>后记： </p><p>本文是用户管理的文档的重要组成部份，我计划在明天开始写用户管理控制工具，比如 useradd、userdel、usermod ，也就</p><p>是管理用户的工具介绍；当然我还会写用户查询工具等与用户管理相关的 </p><p>****4****、权限命令 </p><p><em><strong>*4.1*<em><strong>、</strong></em>*chmod*</strong></em> </p><p>​        文件或者目录的用户能够使用 chmod 命令修改文件的权限。Chmod 命令有两种方式：一种是字符方式，使用字符来修改文件的权限；另外一种是数字方式，使用 3 个数字的组合来修改文件的权限。 使用方式 : chmod [-cfvR] [–help] [–version] mode file…<br>​    说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以借以控制档    案如何被他人所调用。<br>​    参数 :<br>​    mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]，其中<br>​    u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表    示这三者皆是。<br>​    + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>​    r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定    过为可执行。<br>​    -c : 若该档案权限确实已经更改，才显示其更改动作 </p><table><thead><tr><th>-f : 若该档案权限无法被更改也不要显示错误讯息  -v : 显示权限变更的详细资料  -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)  –help : 显示辅助说明  –version : 显示版本  范例 :  将档案 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt  将档案 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt  将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt  将 ex1.py 设定为只有该档案拥有者可以执行 : chmod u+x ex1.py  将目前目录下的所有档案与子目录皆设为任何人可读取 : chmod -R a+r *       数字方式的基本语法是：chmod nnn 文件  其中第 1、2、3 个 n 分别表示用户、组成员和所有其它用户。各个位置上的 n 要么是一个 0，或者是一个由赋予权限的相关值相加得到的单个阿拉伯数字之和。这些数字的意义如表 1 所示。  值    表示的意义  4    表示文件或者目录的读权限</th><th></th></tr></thead><tbody><tr><td>2</td><td>表示文件或者目录的写权限</td></tr><tr><td>1     表示文件或者目录的执行权限  很显然，当使用数字方式时，这 3 个数字必须为 0 至 7 中的一个。  若要 rwx 属性则 4+2+1=7；  若要 rw-属性则 4+2=6；  若要 r-x 属性则 4+1=7。  范例：  chmod a=rwx file 和 chmod 777 file 效果相同  chmod ug=rwx,o=x file 和 chmod 771 file 效果相同  若用 chmod 4755 filename 可使此程序具有 root 的权限</td><td></td></tr></tbody></table><p><em><strong>*4.2*<em><strong>、</strong></em>*umask*</strong></em> </p><p>​    很显然，系统中各种文件的权限设置对特定用户的数据安全有很大影响。但是要求用户逐一明确设置系统中每个文件的权限也是不现实的，为此，需要使用 umask 命令，该命令可以为用户账号中新文件的创建进行缺省设置。系统管理员必须要为你设置一个合理的 u m a s k 值，以确保你创建的文件具有所希望的缺省权限，防止其他非同组用户对你的文件具有写权限。具体来说，umask 是用来设置权限掩码的，权限掩码由 3 个数字组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时默认的权限。 语  法：umask [-S][权限掩码]<br>​    补充说明：umask 可用来设定[权限掩码]。[权限掩码]是由 3 个八进制的数字所组成，将现有的存    取权限减掉权限掩码后，即可产生建立文件时预设的权限。<br>​    参  数：<br>​    -S  以文字的方式来表示权限掩码。<br>​    登录之后，可以按照个人的偏好使用 u m a s k 命令来改变文件创建的缺省权限。相应的改变直到退出该 s h e l l 或使用另外的 u m a s k 命令之前一直有效。一般来说，u m a s k 命令是在/ e t c / p r o f i l e文件中设置的，每个用户在登录时都会引用这个文件，所以如果希望改变所有用户的 u m a s k，可以在该文件中加入相应的条目。如果希望永久性地设置自己的 u m a s k 值，那么就把它放在自己$ H O M E目录下的. p r o f i l e 或. b a s h _ p r o f i l e 文件中。<br>​    如何计算 umask 值 </p><p>​    u m a s k 命令允许你设定文件创建时的缺省模式，对应每一类用户(文件属主、同组用户、其他用户)存在一个相应的 u m a s k 值中的数字。对于文件来说，这一数字的最大值分别是 6。系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用 c h m o d 命令增加这一权限。目录则允许设置执行权限，这样针对目录来说， u m a s k 中各个数字最大可以到 7。该命令的一般形式为： umask nnn </p><table><thead><tr><th>其中 n n n 为 u m a s k 置 0 0 0 - 7 7 7。      计算 u m a s k 值：可以有几种计算 u m a s k 值的方法，通过设置 u m a s k 值，可以为新创建的文件和目录设置缺省权限。      例如，对于 u m a s k 值 0 0 2，相应的文件和目录缺省创建权限是什么呢？      第一步，我们首先写下具有全部权限的模式，即 7 7 7 (所有用户都具有读、写和执行权限)。 第二步，在下面一行按照 u m a s k 值写下相应的位，在本例中是 0 0 2。      第三步，在接下来的一行中记下上面两行中没有匹配的位。这就是目录的缺省创建权限。稍加练习就能够记住这种方法。      第四步，对于文件来说，在创建时不能具有文件权限，只要拿掉相应的执行权限比特即可。 这就是上面的例子，其中 u m a s k 值为 0 0 2：      1) 文件的最大权限 rwx rwx rwx (777)      2) umask 值为 0 0 2 - - - - - - -w-      3) 目录权限 rwx rwx r-x (775) 这就是目录创建缺省权限      4) 文件权限 rw- rw- r– (664) 这就是文件创建缺省权限      系统默认的 umask 码是 0022 也就是：目录 755(rwx,rx,rx) ，文件：644(rw,r,r) 。      umask 码的换算      0022 + 0755 = 0777  对应默认目录权限 反之 0777 - 0755 = 0022      0022 + 0644 +0111 = 0777 对应默认文件权限 反之 0777 - 0111 - 0644 = 0022      哈哈~~ 简单吧！假如我们要将默认目录权限设置为 744 那么对应的 umask 是 0777 - 0744 = 0033 ，然后执行 umask 0033 命令就将 umask 码改成 0033 了。      下面是另外一个例子，假设这次 u m a s k 值为 0 2 2：      1) 文件的最大权限 rwx rwx rwx (777)      2 ) u m a s k 值为 0 2 2 - - - -w- -w-      3) 目录权限 rwx r-x r-x (755) 这就是目录创建缺省权限      4) 文件权限 rw- r– r– (644) 这就是文件创建缺省权限      下面是常用的 u m a s k 值及对应的文件和目录权限      umask 值  目录  文件</th><th></th><th></th></tr></thead><tbody><tr><td>0 2 2</td><td>7 5 5</td><td>6 4 4</td></tr><tr><td>0 2 7</td><td>7 5 0</td><td>6 4 0</td></tr><tr><td>0 0 2</td><td>7 7 5</td><td>6 6 4</td></tr><tr><td>0 0 6</td><td>7 7 1</td><td>6 6 0</td></tr><tr><td>0 0 7</td><td>7 7 0</td><td>6 6 0</td></tr><tr><td>如果想知道当前的 umask 值，可以使用 u m a s k 命令：如果想要改变 u m a s k 值，只要使用 u m a s k 命令设置一个新的值即可：      $ umask 002      确认一下系统是否已经接受了新的 u m a s k 值：在使用 u m a s k 命令之前一定要弄清楚到底希望具有什么样的文件/目录创建缺省权限。否则可能会得到一些非常奇怪的结果；例如，如果将 u m a s k值设置为 6 0 0，那么所创建的文件/目录的缺省权限就是 0 6 6！除非你有特殊需要，否则没有必要去管他，系统默认的值“022”umask 是用的掩码，至于掩码的概念，从基础学吧，这里不说了。</td><td></td><td></td></tr></tbody></table><p>​    linux 中的文件/目录许可是用 4 位八进制数表示的。其中第一个八进制数用来表示特殊许可设置，第二个数字用来设置文件所有者的许可，第三个数字用来设置组许可，第四个数字用来设置所有人的许可。<br>​    例如，root 的权限为 777，若权限掩码设为 022，那么两都相减后可得 755。下面是在我的系统更改 umask 的一些情况：<br>[root@linuxserver root]# umask<br>022 </p><p>上述命令显示表示我的系统的 umask 值为 022。<br>[root@linuxserver root]# umask -S<br>u=rwx,g=rx,o=rx </p><p>当 umask 值为 022 时，默认情况下各用户的权限。注意这里的参数“S”是大写。<br>[root@linuxserver root]# umask 177<br>[root@linuxserver root]# umask -S<br>u=rw,g=,o= </p><p>​    上述两行命令把 umask 值改为 177，结果只有文件所有者具有读写文件的权限，其它用户不能访问该文件。这显然是一种非常安全的状态。 </p><p><em><strong>*4.3*<em><strong>、</strong></em>*chown*</strong></em> </p><p>​    chown 命令用途更改与文件关联的所有者或组。<br>​    语法 chown[  -f ] [ -h] [  -R ] Owner [ :Group ] { File … | Directory … }<br>​    描述 chown 命令将 File 参数指定的文件的所有者更改为 Owner 参数指定的用户。Owner 参数的值可以是可在 /etc/passwd 文件中找到的用户标识或登录名。还可以选择性地指定组。Group 参数的值可以是可在 /etc/group 文件中找到的组标识或组名。<br>​    只有 root 用户可以更改文件的所有者。只在您是 root 用户或拥有该文件的情况下才可以更改文件的组。如果拥有文件但不是 root 用户，则只可以将组更改为您是其成员的组。<br>​    虽然 -H、-L 和 -P 标志是互斥的，指定不止一个也不认为是错误。指定的最后一个标志确定命令拟稿将演示的操作。<br>​    参数：<br>​    -f 禁止除用法消息之外的所有错误消息。<br>​    -h 更改遇到的符号链接的所有权，而非符号链接指向的文件或目录的所有权。 当遇到符号链接而您未    指定 -h 标志时，chown 命令更改链接指向的文件或目录的所有权，而非链接本身的所有权。如果指定 -R 标志，chown 命令递归地降序指定的目录。-H 如果指定了 -R 选项，并且引用类型目录的文件的符    号链接在命令行上指定，chown 变量会更改由符号引用的目录的用户标识（和组标识，如果已指定）    和所有在该目录下的文件层次结构中的所有文件。<br>​    -L 如果指定了 -R 选项，并且引用类型目录的文件的符号在命令行上指定或在遍历文件层次结构期间遇    到，chown 命令会更改由符号链接引用的目录的用户标识（和组标识，如果已指定）和在该目录之下    的文件层次结构中的所有文件。<br>​    -P 如果指定了 -R 选项并且符号链接在命令行上指定或者在遍历文件层次结构期间遇到，则如果系统    支持该操作，则 chown 命令会更改符号链接的所有者标识（和组标识，如果已指定）。chown 命令不    会执行至文件层次结构的任何其它部分的符号链接。<br>​    -R 递归地降序目录，更改每个文件的所有权。当遇到符号链接并且链接指向目录时，更改该目录的所    有权，但不进一步遍历目录。不过 -h、-H、-L or -P 标志也未指定，则当遇到符号链接并且该链接指向    到目录时，该目录的组所有权更改但不会进一步遍历目录。 安全性访问控制：此程序应该作为“可信计    算基”中的正常用户程序安装。退出状态该命令返回以下出口值：0 命令执行成功并已执行所有请求的    更改。 &gt;0 发生错误。 </p><table><thead><tr><th></th><th>示例：  要更改文件 program.c 的所有者： chown jim program.cprogram.c 的用户访问权限现在应用到 jim。作为所有者，jim 可以使用 chmod 命令允许或拒绝其他用户访问 program.c。  要将目录 /tmp/src 中所有文件的所有者和组更改为用户 john 和组 build： chown -R john:build /tmp/src 文件  将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :  chown jessie:users file1.txt</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport :<br>chmod -R lamport:users * </p><p><em><strong>*4.4*<em><strong>、</strong></em>*chgrp*</strong></em> </p><p>功能说明：变更文件或目录的所属群组。<br>语  法：chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br>补充说明：在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。<br>参  数：<br> -c 或–changes  效果类似”-v”参数，但仅回报更改的部分。<br> -f 或–quiet 或–silent  不显示错误信息。<br> -h 或–no-dereference  只对符号连接的文件作修改，而不更动其他任何相关文件。<br> -R 或–recursive  递归处理，将指定目录下的所有文件及子目录一并处理。<br> -v 或–verbose  显示指令执行过程。<br> –help  在线帮助。<br> –reference=&lt;参考文件或目录&gt;  把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。<br> –version  显示版本信息。<br>    范例：<br>    [root@linux ~]# chgrp users install.log<br>    [root@linux ~]#ls –l<br>    -rw-r–r–  1  root  users 28490  Jun 25 08:53  install.log<br>    [root@linux ~]#chgrp  testing  install.log<br>    chgrp:invalid group name ‘testing’  &lt;==出现错误信息～找不到这个用户组名～<br>    发现了吗？文件的用户组被改成了 users 了，但要改成 testing 的时候，就会发生错误。注意，出现错误信    息后，要检查错误信息的内容。 </p><p><em><strong>*五、*</strong></em> <em><strong>*目录结构*</strong></em> </p><p>目录结构及主要内容“/”根目录部分有以下子目录：<br>◆/usr 目录包含所有的命令、程序库、文档和其它文件。这些文件在正常操作中不会被改变的。这个目录也包含你的 Linux 发行版本的主要的应用程序，譬如，Netscape。<br>◆/var 目录包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。这个目录中存放着那些不断在扩充着的东西，为了保持/usr 的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log 目录中。 </p><p>◆/home 目录包含用户的文件：参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等。这个目录在系统省级时应该保留。<br>◆/proc 目录整个包含虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用 ls –l 可以显示它们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统 ◆/bin 系统启动时需要的执行文件（二进制），这些文件可以被普通用户使用。<br>◆/sbin 系统执行文件（二进制），这些文件不打算被普通用户使用。（普通用户仍然可以使用它们，但要指定目录。）<br>◆/etc 操作系统的配置文件目录。<br>◆/root 系统管理员（也叫超级用户或根用户）的 Home 目录。<br>◆/dev 设备文件目录。LINUX 下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目 录。这些设备的内容会出现在独立的子目录下。LINUX 没有所谓的驱动符。<br>◆/lib 根文件系统目录下程序和核心模块的共享库。<br>◆/boot 用于自举加载程序（LILO 或 GRUB）的文件。当计算机启动时（如果有多个操作系统，有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX核（压缩文件vmlinuz），但 LINUX 核也可以存在别处，只要配置 LILO 并且 LILO 知道 LINUX 核在哪儿。<br>◆/opt 可选的应用程序，譬如，REDHAT 5.2 下的 KDE （REDHAT 6.0 下，KDE 放在其它的 XWINDOWS 应用程序中，主执行程序在/usr/bin 目录下）<br>◆/tmp 临时文件。该目录会被自动清理干净。<br>◆/lost+found 在文件系统修复时恢复的文件<br>◆/usr 目录下比较重要的部分有：<br>◆/usr/X11R6 X-WINDOWS 系统（version 11, release 6)<br>◆/usr/X11 同/usr/X11R6 （/usr/X11R6 的符号连接）<br>◆/usr/X11R6/bin 大量的小 X-WINDOWS 应用程序（也可能是一些在其它子目录下大执行文件的符号连接）。<br>◆/usr/doc LINUX 的文档资料（在更新的系统中，这个目录移到/usr/share/doc）。<br>◆/usr/share 独立与你计算机结构的数据，譬如，字典中的词。<br>◆/usr/bin 和/usr/sbin 类似与“/”根目录下对应的目录（/bin 和/sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。<br>◆/usr/local 本地管理员安装的应用程序（也可能每个应用程序有单独的子目录）。在“main”安装后，这个目录可能是空的。这个目录下的内容在重安装或升级操作系统后应该存在。<br>◆/usr/local/bin 可能是用户安装的小的应用程序，和一些在/usr/local 目录下大应用程序的符号连接。 ◆/proc 目录的内容：<br>◆/proc/cpuinfo 关于处理器的信息，如类型、厂家、型号和性能等。<br>◆/proc/devices 当前运行内核所配置的所有设备清单。<br>◆/proc/dma 当前正在使用的 DMA 通道。/proc/filesystems 当前运行内核所配置的文件系统。 ◆/proc/interrupts 正在使用的中断，和曾经有多少个中断。<br>◆/proc/ioports 当前正在使用的 I/O 端口。<br>举例，使用下面的命令能读出系统的 CPU 信息。<br>cat /proc/cpuinfo </p><table><thead><tr><th>/bin</th><th>bin 是 binary 的缩写。这个目录沿袭了 UNIX 系统的结构，存放着使用者最经常使用的命令。例如 cp、ls、cat，等等。</th></tr></thead><tbody><tr><td>/boot</td><td>这里存放的是启动 Linux 时使用的一些核心文件。</td></tr></tbody></table><table><thead><tr><th>/dev</th><th>dev 是 device（设备）的缩写。这个目录下是所有 Linux 的外部设备，其功能类似DOS 下的.sys 和 Win 下的.vxd。在 Linux 中设备和文件是用同种方法访问的。例如：/dev/hda 代表第一个物理 IDE 硬盘。</th></tr></thead><tbody><tr><td>/etc</td><td>这个目录用来存放系统管理所需要的配置文件和子目录。</td></tr><tr><td>/home</td><td>用户的主目录，比如说有个用户叫 wang，那他的主目录就是/home/wang 也可以用~wang 表示。</td></tr><tr><td>/lib</td><td>这个目录里存放着系统最基本的动态链接共享库，其作用类似于 Windows 里的.dll文件。几乎所有的应用程序都须要用到这些共享库。</td></tr><tr><td>/lost+found</td><td>这个目录平时是空的，当系统不正常关机后，这里就成了一些无家可归的文件的避难所。对了，有点类似于 DOS 下的.chk 文件。</td></tr><tr><td>/mnt</td><td>这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。</td></tr><tr><td>/proc</td><td>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。</td></tr><tr><td>/root</td><td>系统管理员（也叫超级用户）的主目录。作为系统的拥有者，总要有些特权啊！比如单独拥有一个目录。</td></tr><tr><td>/sbin</td><td>s 就是 Super User 的意思，也就是说这里存放的是系统管理员使用的管理程序。</td></tr><tr><td>/tmp</td><td>这个目录不用说，一定是用来存放一些临时文件的地方了。</td></tr><tr><td>/usr</td><td>这是最庞大的目录，我们要用到的应用程序和文件几乎都存放在这个目录下。其中包含以下子目录；</td></tr><tr><td>/usr/X11R6</td><td>存放 X-Window 的目录；</td></tr><tr><td>/usr/bin</td><td>存放着许多应用程序；</td></tr><tr><td>/usr/sbin</td><td>给超级用户使用的一些管理程序就放在这里；</td></tr><tr><td>/usr/doc</td><td>这是 Linux 文档的大本营；</td></tr><tr><td>/usr/include</td><td>Linux 下开发和编译应用程序需要的头文件，在这里查找；</td></tr><tr><td>/usr/lib</td><td>存放一些常用的动态链接共享库和静态档案库；</td></tr><tr><td>/usr/local</td><td>这是提供给一般用户的/usr 目录，在这里安装软件最适合；</td></tr><tr><td>/usr/man</td><td>man 在 Linux 中是帮助的同义词，这里就是帮助文档的存放目录；</td></tr><tr><td>/usr/src</td><td>Linux 开放的源代码就存在这个目录，爱好者们别放过哦！</td></tr><tr><td>/var</td><td>这个目录中存放着那些不断在扩充着的东西，为了保持/usr 的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log 目录中。</td></tr></tbody></table><p>总结来说：<br>◆用户应该将文件存在/home/user_login_name 目录下(及其子目录下)。<br>◆本地管理员大多数情况下将额外的软件安装在/usr/local 目录下并符号连接在/usr/local/bin 下的主执行程序。<br>◆系统的所有设置在/etc 目录下。<br>◆不要修改根目录（“/”）或/usr 目录下的任何内容，除非真的清楚要做什么。这些目录最好和 LINUX发布时保持一致。 </p><p>◆大多数工具和应用程序安装在目录：/bin, /usr/sbin, /sbin, /usr/x11/bin,/usr/local/bin。<br>◆所有的文件在单一的目录树下。没有所谓的“驱动符”。 </p><p><em><strong>*六、*</strong></em> <em><strong>*软件安装*</strong></em> </p><p><em><strong>*RPM*</strong></em> </p><p>​    RPM 软件的安装、删除、更新只有 root 权限才能使用；对于查询功能任何用户都可以操作；如果普通用户拥有安装目录的权限，也可以进行安装。 </p><p>​    初始化 rpm 数据库<br>​    通过 rpm 命令查询一个 rpm 包是否安装了，也是要通过 rpm 数据库来完成的；所以我们要经常用下面的两个命令来初始化 rpm 数据库； </p><p>​    [root@localhost beinan]# rpm –initdb<br>​    [root@localhost beinan]# rpm –rebuilddb  注：这个要花好长时间；<br>​    注：这两个参数是极为有用，有时 rpm 系统出了问题，不能安装和查询，大多是这里出了问题；/var/lib/rpm 目录下的数据库记录所有软件的升级需求，记录已经安装的所有软件，数字证书记录等，这个目录下的文件非常重要。 </p><p>****RPM****软件包管理的查询功能： </p><p>命令格式<br>rpm {-q|–query} [select-options] [query-options]<br>RPM 的查询功能是极为强大，是极为重要的功能之一；举几个常用的例子，更为详细的具体的，请参考#man rpm </p><p>****1****、查询系统已安装的软件； </p><p>语法：rpm -q 软件名<br>举例：<br>[root@localhost beinan]# rpm –q gaim<br>gaim-1.3.0-1.fc4<br>-q 就是 –query ，中文意思是“问”，此命令表示的是，是不是系统安装了 gaim ；如果已安装会有信息输出；如果没有安装，会输出 gaim 没有安装的信息；查看系统中所有已经安装的包，要加 -a 参数；<br>[root@localhost RPMS]# rpm -qa<br>如果分页查看，再加一个管道 |和 more 命令；<br>[root@localhost RPMS]# rpm -qa |more<br>在所有已经安装的软件包中查找某个软件，比如说 gaim ；可以用 grep 抽取出来；<br>[root@localhost RPMS]# rpm -qa |grep gaim<br>上面这条的功能和 rpm -q gaim 输出的结果是一样的；<br>等 37448 </p><p>****2****、查询一个已经安装的文件属于哪个软件包； </p><p>语法 rpm -qf 文件名  注：文件名所在的绝对路径要指出举例：<br>[root@localhost RPMS]# rpm -qf /usr/lib/libacl.la<br>libacl-devel-2.2.23-8 </p><p>****3****、查询已安装软件包都安装到何处； </p><p>语法：rpm -ql  软件名  或 rpm rpmquery -ql  软件名 </p><p>举例：<br>[root@localhost RPMS]# rpm -ql lynx<br>[root@localhost RPMS]# rpmquery -ql  lynx </p><p>****4****、查询一个已安装软件包的信息 </p><p>语法格式： rpm -qi 软件名<br>举例：<br>[root@localhost RPMS]# rpm -qi lynx </p><p>****5****、查看一下已安装软件的配置文件； </p><p>语法格式：rpm -qc 软件名<br>举例：<br>[root@localhost RPMS]# rpm -qc lynx </p><p>****6****、查看一个已经安装软件的文档安装位置： </p><p>语法格式： rpm -qd 软件名<br>举例：<br>[root@localhost RPMS]# rpm -qd lynx </p><p>****7****、查看一下已安装软件所依赖的软件包及文件； </p><p>语法格式： rpm -qR 软件名<br>举例：<br>[root@localhost beinan]# rpm -qR  rpm-python<br>查询已安装软件的总结：对于一个软件包已经安装，我们可以把一系列的参数组合起来用；比如 rpm -qil ；比如：<br>[root@localhost RPMS]# rpm -qil lynx<br>对已安装软件包查询的一点补充； </p><p>[root@localhost RPMS]# updatedb<br>[root@localhost RPMS]#  locate 软件名或文件名<br>通过 updatedb，我们可以用 locate 来查询一些软件安装到哪里了；系统初次安装时要执行 updatedb ，每隔一段时间也要执行一次；以保持已安装软件库最新；updatedb 是 slocate 软件包所有；如果您没有这个命令，就得安装 slocate ；举例：<br>[root@localhost RPMS]#  locate gaim </p><p>对于未安装的软件包的查看： </p><p>查看的前提是您有一个.rpm 的文件，也就是说对既有软件 file.rpm 的查看等； </p><p>****1****、查看一个软件包的用途、版本等信息； </p><p>语法： rpm -qpi file.rpm<br>举例：<br>[root@localhost RPMS]# rpm -qpi lynx-2.8.5-23.i386.rpm </p><p>****2****、查看一件软件包所包含的文件； </p><p>语法： rpm -qpl  file.rpm<br>举例：<br>[root@localhost RPMS]# rpm -qpl  lynx-2.8.5-23.i386.rpm </p><p>**<br>**</p><p>****3****、查看软件包的文档所在的位置； </p><p>语法： rpm -qpd  file.rpm<br>举例：<br>[root@localhost RPMS]# rpm -qpd  lynx-2.8.5-23.i386.rpm </p><p>****4****、查看一个软件包的配置文件； </p><p>语法： rpm -qpc  file.rpm<br>举例：<br>[root@localhost RPMS]# rpm -qpc  lynx-2.8.5-23.i386.rpm </p><p>****5****、查看一个软件包的依赖关系 </p><p>语法： rpm -qpR  file.rpm<br>举例：<br>[root@localhost archives]# rpm -qpR yumex_0.42-3.0.fc4_noarch.rpm<br>/bin/bash<br>/usr/bin/python<br>config(yumex) = 0.42-3.0.fc4<br>pygtk2<br>pygtk2-libglade<br>rpmlib(CompressedFileNames) &lt;= 3.0.4-1<br>rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1<br>usermode<br>yum &gt;= 2.3.2 </p><p>软件包的安装、升级、删除等； </p><p><em><strong>*1*<em><strong>、安装和升级一个</strong></em>*rpm*</strong></em> 包； </p><p>[root@localhost beinan]#rpm -vih file.rpm 注：这个是用来安装一个新的 rpm 包；<br>[root@localhost beinan]#rpm -Uvh file.rpm 注：这是用来升级一个 rpm 包；<br>如果有依赖关系的，请解决依赖关系，其实软件包管理器能很好的解决依赖关系，请看前面的软件包管理器的介绍；如果您在软件包管理器中也找不到依赖关系的包；那只能通过编译他所依赖的包来解决依赖关系，或者强制安装；语法结构：<br>[root@localhost beinan]# rpm -ivh file.rpm –nodeps –force<br>[root@localhost beinan]# rpm -Uvh file.rpm –nodeps –force<br>更多的参数，请查看 man rpm 举例应用：<br>[root@localhost RPMS]# rpm -ivh lynx-2.8.5-23.i386.rpm<br>Preparing…         ########################################### [100%]<br>     1:lynx          ########################################### [100%]<br>[root@localhost RPMS]# rpm -ivh –replacepkgs  lynx-2.8.5-23.i386.rpm<br>Preparing…         ########################################### [100%]<br>     1:lynx          ########################################### [100%]<br>注： –replacepkgs 参数是以已安装的软件再安装一次；有时没有太大的必要；测试安装参数 –test ，用来检查依赖关系；并不是真正的安装；<br>[root@localhost RPMS]# rpm -ivh –test  gaim-1.3.0-1.fc4.i386.rpm<br>Preparing…         ########################################### [100%] </p><p>由新版本降级为旧版本，要加 –oldpackage 参数；<br>[root@localhost RPMS]# rpm -qa gaim<br>gaim-1.5.0-1.fc4<br>[root@localhost RPMS]# rpm -Uvh –oldpackage gaim-1.3.0-1.fc4.i386.rpm<br>Preparing…         ########################################### [100%]<br>     1:gaim          ########################################### [100%]<br>[root@localhost RPMS]# rpm -qa gaim<br>gaim-1.3.0-1.fc4<br>为软件包指定安装目录：要加 -relocate 参数；下面的举例是把 gaim-1.3.0-1.fc4.i386.rpm 指定安装在 /opt/gaim 目录中；<br>[root@localhost RPMS]# rpm -ivh  –relocate /=/opt/gaim  gaim-1.3.0-1.fc4.i386.rpm<br>Preparing…         ########################################### [100%]<br>     1:gaim          ########################################### [100%]<br>[root@localhost RPMS]# ls /opt/<br>gaim<br>为软件包指定安装目录：要加 -relocate 参数；下面的举例是把 lynx-2.8.5-23.i386.rpm 指定安装在 /opt/lynx 目录中；<br>[root@localhost RPMS]# rpm -ivh –relocate /=/opt/lynx –badreloc lynx-2.8.5-23.i386.rpm Preparing… ########################################### [100%]<br>1:lynx ########################################### [100%]<br>我们安装在指定目录中的程序如何调用呢？一般执行程序，都放在安装目录的 bin 或者 sbin 目录中；看下面的例子；如果有错误输出，就做相应的链接，用 ln -s ；<br>[root@localhost RPMS]# /opt/lynx/usr/bin/lynx<br>Configuration file /etc/lynx.cfg is not available.<br>[root@localhost RPMS]# ln -s /opt/lynx/etc/lynx.cfg /etc/lynx.cfg<br>[root@localhost RPMS]# /opt/lynx/usr/bin/lynx <a href="http://www.linuxsir.org/">www.linuxsir.org</a><br>RPM 管理包管理器支持网络安装和查询；<br>比如我们想通过 Fedora Core 4.0 的一个镜像查询、安装软件包；地址：<br><a href="http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/">http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/</a> 举例：命令格式：<br>rpm 参数 rpm 包文件的 http 或者 ftp 的地址<br># rpm -qpi <a href="http://mirrors.kernel.org/fedora/core/4/i386/os/">http://mirrors.kernel.org/fedora/core/4/i386/os/</a><br>Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm<br># rpm  -ivh <a href="http://mirrors.kernel.org/fedora/core/4/i386/os/">http://mirrors.kernel.org/fedora/core/4/i386/os/</a><br>Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm </p><p><em><strong>*2*<em><strong>、删除一个</strong></em>*rpm*</strong></em> 包； </p><p>首先您要学会查询 rpm 包 ；请看前面的说明； [root@localhost beinan]#rpm -e 软件包名 举例：我想移除 lynx 包，完整的操作应该是：<br>[root@localhost RPMS]# rpm -e lynx<br>如果有依赖关系，您也可以用–nodeps 忽略依赖的检查来删除。但尽可能不要这么做，最好用软件包管理器 systerm-config-packages 来删除或者添加软件；<br>[root@localhost beinan]# rpm -e lynx –nodeps </p><p>****RPM****验证与数字证书： </p><p>导入签名： </p><table><thead><tr><th>[root@localhost RPMS]# rpm –import 签名文件 举例：</th><th></th><th></th></tr></thead><tbody><tr><td>[root@localhost fc40]# rpm –import RPM-GPG-KEY</td><td></td><td></td></tr><tr><td>[root@localhost fc40]# rpm –import RPM-GPG-KEY-fedora</td><td></td><td></td></tr><tr><td>RPM 验证作用是使用/var/lib/rpm 下面的数据库内容来比较目前 linux 系统的环境下的所有软件文件，也就是说当你有数据不小心丢失，或者不小心修改到某个软件的文件内容，就用这个简单的方法验证一下原本的文件系统</td><td></td><td></td></tr><tr><td>#rpm –Va</td><td></td><td>列出目前系统上面所有可能被改动过的文件</td></tr></tbody></table><p>从****rpm****软件包抽取文件； </p><p>命令格式：  rpm2cpio file.rpm |cpio -div<br>举例：<br>[root@localhost RPMS]# rpm2cpio gaim-1.3.0-1.fc4.i386.rpm |cpio -div<br>抽取出来的文件就在当用操作目录中的 usr 和 etc 中；其实这样抽到文件不如指定安装目录来安装软件来的方便；也一样可以抽出文件；为软件包指定安装目录：要加 -relocate 参数；下面的举例是把gaim-1.3.0-1.fc4.i386.rpm 指定安装在 /opt/gaim 目录中；<br>[root@localhost RPMS]# rpm -ivh  –relocate /=/opt/gaim  gaim-1.3.0-1.fc4.i386.rpm<br>Preparing…         ########################################### [100%]<br>     1:gaim          ########################################### [100%]<br>[root@localhost RPMS]# ls /opt/<br>gaim<br>这样也能一目了然；gaim 的所有文件都是安装在 /opt/gaim 中，我们只是把 gaim 目录备份一下，然后卸掉 gaim；这样其实也算提取文件的一点用法； </p><p>****RPM****的配置文件； </p><p>RPM 包管理，的配置文件是 rpmrc ，我们可以在自己的系统中找到；比如 Fedora Core 4.0 中的 rpmrc 文件位于；<br>[root@localhost RPMS]# locate rpmrc<br>/usr/lib/rpm/rpmrc<br>/usr/lib/rpm/redhat/rpmrc </p><p>我们可以通过 rpm –showrc 查看；具体的还得我们自己来学习。呵。。。不要问我，我也不懂；只要您看了这篇文章，认为对您有用，您的水平就和我差不多；咱们水平是一样的，所以我不能帮助您了；请理解。 </p><p><em><strong>*YUM*</strong></em> </p><p>****YUM****配置文件 </p><p>创建容器，位置在<em><strong>*/etc/yum.repos.d*<em><strong>，扩展名必须是</strong></em>*.repo*</strong></em> </p><p>#cd  /etc/yum.repos.d </p><table><thead><tr><th>#vim yum.repo</th><th>新建一个仓库文件，名字可以随便定义，在文件中写如下内容</th><th></th></tr></thead><tbody><tr><td>[base]</td><td></td><td>#代表容器名称，中括号一定要存在，里面的名字可随便取</td></tr><tr><td>name=base</td><td>#说明这个容器的意义，随便写都可以</td><td></td></tr><tr><td>baseurl=<a href="ftp://192.168.0.6/pub/Server">ftp://192.168.0.6/pub/Server</a></td><td>#192. 168. 0. 6 是你的 YUM 源地址，这个很重要。</td><td></td></tr><tr><td>enabled=1</td><td>#是否启动，=0 则不启动，不启动就无法使用该源</td><td></td></tr><tr><td>gpgcheck=0</td><td>#是否验证. 可不要</td><td></td></tr><tr><td>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release ＃验证的密钥. 可不要</td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>命令<em><strong>*:#yum repolist all*</strong></em></th><th>显示目前所使用的容器有哪些</th></tr></thead><tbody><tr><td>如果查询出来的容器，status 为 disabled，要将配置文件，如上 enabled=1</td><td></td><td></td></tr></tbody></table><p><em><strong>*/etc/yum.conf*</strong></em> </p><table><thead><tr><th></th><th><em><strong>*yum.conf*</strong></em> 这个配置文件主要是 <em><strong>*yum*</strong></em> 客户端使用，里面主要规定了要去用的 <em><strong>*rpm*</strong></em> 包的 <em><strong>*yum*</strong></em> 服务器的信</th></tr></thead><tbody><tr><td>息。</td><td></td></tr><tr><td></td><td>[main]  #main 开头的块用于对客户端进行配置，在 main 后也可以指定 yum 源（不推荐这样做），与</td></tr><tr><td>/etc/yum.repo.d 中指定 yum 源相同      cachedir=/var/cache/yum</td><td></td></tr></tbody></table><p>#cachedir：yum 缓存的目录，yum 在此存储下载的 rpm 包和数据库，一般是/var/cache/yum。 keepcache=0 #0 表示不保存下载的文件，1 表示保存下载的文件，默认为不保存<br>debuglevel=2 </p><table><thead><tr><th>#debuglevel：除错级别，0──10,默认是 2 貌似只记录安装和删除记录</th><th></th><th></th></tr></thead><tbody><tr><td>logfile=/var/log/yum.log</td><td>#指定 yum 的日志文件</td><td></td></tr><tr><td>pkgpolicy=newest</td><td>#包的策略，如果配置多了 yum 源，同一软件在不同的 yum 源中有不同版本，</td><td></td></tr><tr><td>newest 则安装最新版本，该值为 lastest，则 yum 会将服务器上 ID 按照字母序排列，选择最后那个服务器上的软件安装      distroverpkg=centos-release      #指定一个软件包，yum 会根据这个包判断你的发行版本，默认是 redhat-release，也可以是安装的任何针对自己发行版的 rpm 包。      tolerant=1      #tolerent，也有 1 和 0 两个选项，表示 yum 是否容忍命令行发生与软件包有关的错误，比如你要安装1,2,3 三个包，而其中 3 此前已经安装了，如果你设为 1,则 yum 不会出现错误信息。默认是 0。      exactarch=1      #exactarch，有两个选项 1 和 0,代表是否只升级和你安装软件包 cpu 体系一致的包，如果设为 1，则如你安装了一个 i386 的 rpm，则 yum 不会用 i686 的包来升级。      retries=20      #retries，网络连接发生错误后的重试次数，如果设为 0，则会无限重试。      obsoletes=1      gpgcheck=1      #gpgchkeck= 有 1 和 0 两个选择，分别代表是否是否进行 gpg 校验，如果没有这一项，默认是检查的。</td><td></td><td></td></tr><tr><td>plugins = 1</td><td></td><td>#是否启用插件，默认 1 为允许，0 表示不允许</td></tr><tr><td>reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo 后缀文件          #默认都会被 include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少个[name]最后其实都被整合到 一个里面看就是了 重复的[name]应该是前面覆盖后面的–还是后面的覆盖前面的呢？enabled 测试是后面覆盖前面          exclude=xxx</td><td></td><td></td></tr></tbody></table><p>​    #exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。<br>​    keepcache=[1 or 0]<br>​    #设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存<br>​    reposdir=[包含 .repo 文件的目录的绝对路径]<br>​    #该选项用户指定 .repo 文件的绝对路径。.repo 文件包含软件仓库的信息 (作用与 /etc/yum.conf 文件中的 [repository] 片段相同)。中 </p><p>**<br>**</p><p>****YUM****命令 </p><p>用 YUM 安装删除软件 yum install xxx，yum 会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。<br>删除的命令是，yum remove xxx，同安装一样，yum 也会查询数据库，给出解决依赖关系的提示。 </p><p>****YUM****安装软件包 </p><p>命令：yum install </p><p>****YUM****删除软件包 </p><p>命令：yum remove<br>    用 YUM 查询软件信息，我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时 yum 的查询功能就起作用了。你可以用 yum search keyword 这样的命令来进行搜索，比如我们要则安装一个 Instant Messenger，但又不知到底有哪些，这时不妨用 yum search messenger这样的指令进行搜索，yum 会搜索所有可用 rpm 的描述，列出所有描述中和 messeger 有关的 rpm 包，于是我们可能得到 gaim，kopete 等等，并从中选择。有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用 yum info packagename 这个指令来获取信息。<br>1.使用 YUM 查找软件包<br>命令：yum search<br>2.列出所有可安装的软件包<br>命令：yum list<br>3.列出所有可更新的软件包<br>命令：yum list updates<br>4.列出所有已安装的软件包<br>命令：yum list installed<br>5.列出所有已安装但不在 Yum Repository 內的软件包<br>命令：yum list extras<br>6.列出所指定的软件包<br>命令：yum list<br>7.使用 YUM 获取软件包信息<br>命令：yum info<br>8.列出所有软件包的信息<br>命令：yum info<br>9.列出所有可更新的软件包信息<br>命令：yum info updates<br>10.列出所有已安裝的软件包信息<br>命令：yum info installed<br>11.列出所有已安裝但不在 Yum Repository 內的软件包信息<br>命令：yum info extras<br>12.列出软件包提供哪些文件<br>命令：yum provides </p><p>清除****YUM****缓存 </p><p>yum 会把下载的软件包和 header 存储在 cache 中，而不会自动删除。如果我们觉得它们占用了磁盘空间，可以使用 yum clean 指令进行清除，更精确的用法是 yum clean headers 清除 header，yum clean packages 清除下载的 rpm 包，yum clean all 一股脑儿端<br>1.清除缓存目录(/var/cache/yum)下的软件包<br>命令：yum clean packages<br>2.清除缓存目录(/var/cache/yum)下的 headers<br>命令：yum clean headers<br>3.清除缓存目录(/var/cache/yum)下旧的 headers<br>命令：yum clean<br>Oldheaders </p><p>4.清除缓存目录(/var/cache/yum)下的软件包及旧的 headers<br>命令：yum clean, yum clean<br>all (= yum clean packages; yum clean oldheaders) </p><p><em><strong>*七、*</strong></em> <em><strong>*时间管理*</strong></em> </p><p>****1****、 ****Linux****时间介绍： </p><p>​    Linux 时钟分为系统时钟（System Clock）和硬件（Real Time Clock，简称 RTC）时钟。系统时钟是指当前 Linux Kernel 中的时钟，而硬件时钟则是主板上由电池供电的时钟，这个硬件时钟可以在BIOS 中进行设置。当 Linux 启动时，硬件时钟会去读取系统时钟的 设置，然后系统时钟就会独立于硬件运作。<br>​         Linux 中的所有命令（包括函数）都是采用的系统时钟设置。在 Linux 中，用于时钟查看和设置的命令主要有 date、hwclock 和 clock。其中，clock 和 hwclock 用法相近，只用一个就行，只不过 clock 命令除了支持 x86 硬 件体系外，还支持 Alpha 硬件体系。 </p><p>****2*<em><strong>、</strong></em>*Linux****时间设置命令 </p><p><em><strong>*2.1*<em><strong>、</strong></em>*date:*</strong></em> </p><table><thead><tr><th>语法格式：date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]  说明：可用来设置系统日期与时间。只有管理员才有设置日期与时间的权限，一般用户只能用date 命令显示时间。若不加任何参数，data 会显示目前的日期与时间。  例 ****1****：显示当前系统时间</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[root@Test2 ~]# date</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2010 年 06 月 17 日 星期四 00:00:04 CST  例 ****2****：设置日期和时间为 <em><strong>*2010*</strong></em> 年 <em><strong>*6*</strong></em> 月 <em><strong>*18*</strong></em> 号 <em><strong>*12:00*</strong></em>  [root@Test2 ~]# date -s “20100618 12:00:00”  2010 年 06 月 18 日 星期五 12:00:00 CST  例 ****3****：设置日期为 <em><strong>*2010*</strong></em> 年年 <em><strong>*6*</strong></em> 月 <em><strong>*18*</strong></em> 号  [root@Test2 ~]# date -s 20100618</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>2010 年 06 月 18 日 星期五 00:00:00 CST<br>例 ****4****：设置时间为 <em><strong>*12:00:00*</strong></em> </p><p>[root@Test2 ~]# date 12:00:00<br>date: invalid date “12:00:00” </p><p>例 ****5****：显示时区<br>[root@Test2 ~]# date -R<br>Thu, 17 Jun 2010 00:01:36 +0800 </p><p>或者：<br>[root@Test2 ~]# cat /etc/sysconfig/clock<br># The ZONE parameter is only evaluated by system-config-date.<br># The timezone of the system is defined by the contents of /etc/localtime.<br>ZONE=”Asia/Shanghai”<br>UTC=true<br>ARC=false </p><p><em><strong>*2.2*<em><strong>、</strong></em>*hwclock/clock*</strong></em> </p><p>​        语法格式：hwclock [–adjust][–debug][–directisa][–hctosys][–show][–systohc][–test]<br>​        [–utc][–version][–set –date=&lt;日期与时间&gt;]<br>​        参数：<br>–adjust  hwclock 每次更改硬件时钟时，都会记录在/etc/adjtime 文件中。使用–adjust 参数，可使 hwclock根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟。<br>​        –debug  显示 hwclock 执行时详细的信息。<br>–directisa  hwclock 预设从/dev/rtc 设备来存取硬件时钟。若无法存取时，可用此参数直接以 I/O 指令来存取硬件时钟。<br>​        –hctosys  将系统时钟调整为与目前的硬件时钟一致。<br>​        –set –date=&lt;日期与时间&gt;  设定硬件时钟。<br>​        –show  显示硬件时钟的时间与日期。<br>​        –systohc  将硬件时钟调整为与目前的系统时钟一致。<br>​        –test  仅测试程序，而不会实际更改硬件时钟。<br>​        –utc  若要使用格林威治时间，请加入此参数，hwclock 会执行转换的工作。<br>​        –version  显示版本信息。<br>​        例 ****1****：查看硬件时间<br>​        # hwclock –show </p><p>或者<br># clock –show<br>例 ****2****：设置硬件时间<br># hwclock –set –date=”07/07/06 10:19” （月/日/年 时:分:秒）<br>或者<br># clock –set –date=”07/07/06 10:19” （月/日/年 时:分:秒）<br>例 ****3****：硬件时间和系统时间的同步 </p><p>按照前面的说法，重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用 hwclock 或 clock 命令实现同步。<br>    硬件时钟与系统时钟同步：<br>    # hwclock –hctosys（hc 代表硬件时间，sys 代表系统时间）<br>    或者<br>    # clock –hctosys </p><p>例 ****4****：系统时钟和硬件时钟同步： </p><p># hwclock –systohc </p><p>或者<br># clock –systohc<br>例 ****5****：强制将系统时间写入 ****CMOS****，使之永久生效，避免系统重启后恢复成原时间 # clock –w </p><p>或者<br># hwclock -w </p><p>****2.3****、时区的设置 </p><p># tzselect<br>Please identify a location so that time zone rules can be set correctly.<br>Please select a continent or ocean.<br>\1) Africa<br>\2) Americas<br>\3) Antarctica<br>\4) Arctic Ocean<br>\5) Asia<br>\6) Atlantic Ocean<br>\7) Australia<br>\8) Europe<br>\9) Indian Ocean<br>\10) Pacific Ocean<br>\11) none - I want to specify the time zone using the Posix TZ format.<br>#? 输入 5，亚洲<br>Please select a country.<br>\1) Afghanistan       18) Israel         35) Palestine<br>\2) Armenia          19) Japan         36) Philippines<br>\3) Azerbaijan        20) Jordan         37) Qatar<br>\4) Bahrain          21) Kazakhstan     38) Russia<br>\5) Bangladesh       22) Korea (North)    39) Saudi Arabia<br>\6) Bhutan          23) Korea (South)    40) Singapore<br>\7) Brunei           24) Kuwait         41) Sri Lanka<br>\8) Cambodia        25) Kyrgyzstan      42) Syria<br>\9) China           26) Laos          43) Taiwan<br>\10) Cyprus          27) Lebanon       44) Tajikistan<br>\11) East Timor        28) Macau         45) Thailand<br>\12) Georgia          29) Malaysia       46) Turkmenistan<br>\13) Hong Kong        30) Mongolia       47) United Arab Emirates<br>\14) India            31) Myanmar (Burma) 48) Uzbekistan<br>\15) Indonesia         32) Nepal          49) Vietnam<br>\16) Iran             33) Oman          50) Yemen<br>\17) Iraq             34) Pakistan<br>#? 输入 9，中国<br>Please select one of the following time zone regions.<br>\1) east China - Beijing, Guangdong, Shanghai, etc. </p><p>\2) Heilongjiang<br>\3) central China - Gansu, Guizhou, Sichuan, Yunnan, etc.<br>\4) Tibet &amp; most of Xinjiang Uyghur<br>\5) southwest Xinjiang Uyghur </p><p>#? 输入 1，北京时间<br>The following information has been given:<br>     China<br>     east China - Beijing, Guangdong, Shanghai, etc.<br>Therefore TZ=’Asia/Shanghai’ will be used.<br>Local time is now:    Fri Jul  7 10:32:18 CST 2006.<br>Universal Time is now:  Fri Jul  7 02:32:18 UTC 2006.<br>Is the above information OK?<br>\1) Yes<br>\2) No </p><p>#? 输入 1，确认<br>如果不用 tzselect 命令，可以修改文件变更时区。<br># vi /etc/sysconfig/clock<br>Z/Shanghai（查/usr/share/zoneinfo 下面的文件）<br>UTC=false<br>ARC=false<br># rm /etc/localtime<br># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>重新启动即可。 </p><p><em><strong>*2.4*<em><strong>、图形界面设置时区命令</strong></em>*timeconfig*</strong></em> </p><p>****2.5****、时间同步 </p><p> 例 ****1****：同步时间 </p><table><thead><tr><th># ntpdate 210.72.145.44</th><th>（210.72.145.44 是中国国家授时中心的官方服务器）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>​    例 ****2****：定时同步时间<br>​    # crontab –e 添加脚本例子如下：<br>​    <em>/20 * * * *    /usr/sbin/ntpdate 210.72.145.44      //每 20 分钟执行一次<br>​    30 5 * * *     /usr/sbin/ntpdate 210.72.145.44      //每天早晨 5 点半执行<br>※ 前面五个</em>号代表五个数字，数字的取值范围和含义如下：分钟（0-59） 小時（0-23） 日期（1-31） 月份（1-12） 星期（0-6）//0 代表星期天设定完毕后，可使用# crontab –l 查看上面的设定。 </p><p><em><strong>*八、*</strong></em> <em><strong>*启动引导*</strong></em> </p><p>****1*<em><strong>、</strong></em>*Linux****的启动流程 </p><p>\1) BIOS 自检<br>\2) 启动 GRUB/LILO<br>\3) 运行 Linux kernel 并检测硬件<br>\4) 挂载根文件系统<br>\5) 运行 Linux 系统的第一个进程 init(其 PID 永远为 1，是所有其它进程的父进程)<br>\6) init 读取系统引导配置文件 /etc/inittab 中的信息进行初始化 </p><p>\7) 执行系统初始化脚本－ /etc/rc.d/rc.sysinit，执行系统初始化(包括很多内容)<br>\8) 根据指定的运行级别(runlevel)来运行服务器脚本程序，再执行脚本 /etc/rc.d/rc.local 9) 运行一些其他的特别服务，一般为 /sbin/mingetty 和 /etc/X11/prefdm<br>\10) Linux 控制台(console)提示用户输入用户名、密码进行登陆。<br>总结：BIOS 初始化à检查外围设备à检查启动设备à读区 MBR </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps5.jpg" alt="img"> </p><p><em><strong>*2*<em><strong>、在</strong></em>*Linux*<em><strong>中常用的启动引导工具：</strong></em>*grub*<em><strong>和</strong></em>*lilo*</strong></em> </p><p>​    在 Linux 和 WINDOWS 两系统并存时就需要安装 GRUB（Grand Unified Bootloader），GRUB 被广泛地用于替代 lilo,GRUB 支持在启动时使用命令行模式,支持 md5 加密保护 还可以从 ext2/ext3、ReiseFS、JFS、FAT、minix 及 FFS 文件系统上启动其配置文件为/boot/grub/grub.conf,更改 grub.conf 即可立时生效如果硬盘上的 MBR 被更动过，可以用/sbin/grub-install /dev/hda 来重安装 grub 现在我们打开<br>/boot/grub/grub.conf 查看一下<br>​    # vim /boot/grub/grub.conf<br>​    内容如下： </p><p># grub.conf generated by anaconda </p><p># </p><p># Note that you do not have to rerun grub after making changes to this file </p><p># NOTICE:  You have a /boot partition.  This means that </p><p>#      all kernel and initrd paths are relative to /boot/, eg. </p><p>#      root (hd0,0) </p><p>#      kernel /vmlinuz-version ro root=/dev/sda2 </p><p>#      initrd /initrd-version.img </p><p>#boot=/dev/sda </p><p><em><strong>*default=0*</strong></em> </p><p>#default=0 表示默认启动第一个系统,如果系统有两个系统是用什么做为分隔符的呢？title 就是系统的分</p><p>隔符,第一个 title 后面就是第一个系统,用 0 表示。 </p><p><em><strong>*timeout=5*</strong></em> </p><p>#timout=5，就是默认在启动选择界面停留的时间，单位是秒。等待 5 秒自动进入默认操作系统 </p><p><em><strong>*splashimage=(hd0,0)/grub/splash.xpm.gz*</strong></em> </p><p>#splashimage 是 grub 启动背景画面，如果是自己写 grub.conf 文件，这个可以不用写。 </p><p><em><strong>*hiddenmenu*</strong></em> </p><p><em><strong>*title Red Hat Enterprise Linux Server (2.6.18-53.el5)*</strong></em> </p><p>#title 后面就是系统在启动时候显示的名字 </p><p> <em><strong>*root (hd0,0)*</strong></em>  </p><p>#root 启动文件所在位置 </p><p> <em><strong>*kernel /vmlinuz-2.6.18-53.el5 ro root=LABEL=/ rhgb quiet*</strong></em>  </p><p>#kernel 内核所在位置和名字 </p><p> <em><strong>*initrd /initrd-2.6.18-53.el5.img*</strong></em>  </p><p>#initrd 内核镜象的名字 </p><p><em><strong>*grub.conf*</strong></em> 的范例： </p><p>timeout=10    #等待 10 秒自动进入默认操作系统 </p><p>splashimage=(hd0,0)/grub/splash.xpm.gz #grub 启动背景画面 </p><p>default=0    #默认进入第一个标题 </p><p>title Red Hat Linux (2.4.20-18)  #Red Hat Linux 标题 </p><p>root (hd0,0)    #根文件系统位置 </p><p>kernel  /vmlinuz-2.4.20-18 ro root=LABEL=/ #核心位置与核心加载参数 </p><p>initrd  /initrd-2.4.20-18.img  #启动 initrd ram 盘 </p><p>title windows    #另一个操作系统的标题 </p><p>rootnoverify (hd0,1)   #操作系统存放在 hd0,1 上，不要在 grub 里 mount </p><p>chainloader +1   #从 hd0,1 的第一个扇面启动 </p><p><em><strong>*九、*</strong></em> <em><strong>*运行级别*</strong></em> </p><p><em><strong>*1*<em><strong>、</strong></em>*Linux*</strong></em> 系统的运行级别<em><strong>*(runlevel)*</strong></em> </p><p>Linux 系统有 7 个运行级别，Linux 系统任何时候都运行在一个指定的运行级别上，不同的运行级</p><p>别所运行的程序和服务不尽相同，所要完成的工作和要达到的目的也不相同 </p><p>· 运行级别 0 系统停机(halt)状态，系统的默认运行级别不能设为 0，否则不能正常启动 </p><p>· 运行级别 1 单用户工作(single user)状态，root 权限，用于系统维护，禁止远程登陆 </p><p>· 运行级别 2 多用户(multiuser)状态 (没有 NFS) </p><p>· 运行级别 3 完全的多用户(multiuser)状态 (有 NFS)，登陆后进入控制台命令行模式 </p><p>· 运行级别 4 系统未使用，保留 </p><p>· 运行级别 5 X11 控制台 (xdm、gdm、kdm)，登陆后进入图形 GUI 模式 </p><p>· 运行级别 6 系统正常关闭并重启(reboot)，默认运行级别不能设为 6，否则不能正常启动 </p><p>****2****、运行级别的原理 </p><table><thead><tr><th></th><th>在目录 /etc/rc.d/init.d 下有许多服务器脚本程序，一般称为服务(service)， 在 /etc/rc.d 下</th></tr></thead><tbody><tr><td>有 7 个名为 rcN.d 的目录，其中 N=0-6，对应于系统的 7 个运行级别， rcN.d 目录下，都是一些符号链接文件，这些链接文件都指向 init.d 目录下的 service 脚本文件，这些链接文件的命名规则是 “K+nn+服务名” 或 “S+nn+服务名”，其中 nn 为 2 位数字：  例: rc3.d 目录下的链接文件 S80sendmail 就指向 service 脚本文件 ../init.d/sendmail  系统会根据指定的 runlevel 进入对应的 rcN.d 目录，并按照文件名顺序检索目录下的链接文件 • 对于以 K 为开头的链接文件，系统将终止对应的服务  • 对于以 S 为开头的链接文件，系统将启动对应的服务  通过这种方式来实现 “不同的运行级别运行不同的程序和服务”</td><td></td></tr></tbody></table><p>****3*<em><strong>、</strong></em>*/etc/inittab****配置文件详解 </p><p> init 的进程号是 1，从这一点就能看出，init 进程是系统所有进程的起点，Linux 在完成核内引导以后，就开始运行 init 程序，init 程序需要读取设置文件/etc/inittab。inittab 是个不可执行的文本文件，他有若干行指令所组成。在 Redhat 系统中，inittab 的内容如下所示(以“###”开始的中注释为笔者增加的)：  （如果你改变了 <em><strong>*inittab*</strong></em> 文件，那么要使他立即生效，需要使用一个命令：****init q****） </p><p>#<br># inittab    This file describes how the INIT process should set up<br>#        the system in a certain run-level.<br>#<br># Author:    Miquel van Smoorenburg, <a href="mailto:&#x6d;&#105;&#113;&#x75;&#101;&#108;&#115;&#x40;&#x64;&#x72;&#x69;&#x6e;&#x6b;&#x65;&#108;&#46;&#x6e;&#x6c;&#x2e;&#109;&#x75;&#x67;&#110;&#101;&#x74;&#46;&#111;&#114;&#103;">&#x6d;&#105;&#113;&#x75;&#101;&#108;&#115;&#x40;&#x64;&#x72;&#x69;&#x6e;&#x6b;&#x65;&#108;&#46;&#x6e;&#x6c;&#x2e;&#109;&#x75;&#x67;&#110;&#101;&#x74;&#46;&#111;&#114;&#103;</a><br>#        Modified for RHS Linux by Marc Ewing and Donnie Barnes<br>#<br># Default runlevel. The runlevels used by RHS are:<br>#  0 - halt (Do NOT set initdefault to this)<br>#  1 - Single user mode<br>#  2 - Multiuser, without NFS (The same as 3, if you do not have networking)<br>#  3 - Full multiuser mode<br>#  4 - unused<br>#  5 - X11<br>#  6 - reboot (Do NOT set initdefault to this)<br>#  </p><p> ###表示当前缺省运行级别为 5(initdefault)；<br> id:5:initdefault: </p><p> ###启动时自动执行/etc/rc.d/rc.sysinit 脚本(sysinit)<br> # System initialization.<br> si::sysinit:/etc/rc.d/rc.sysinit </p><p> l0:0:wait:/etc/rc.d/rc 0<br> l1:1:wait:/etc/rc.d/rc 1<br> l2:2:wait:/etc/rc.d/rc 2 </p><p> l3:3:wait:/etc/rc.d/rc 3<br> l4:4:wait:/etc/rc.d/rc 4 </p><p> ###当运行级别为 5 时，以 5 为参数运行/etc/rc.d/rc 脚本，init 将等待其返回(wait)<br> l5:5:wait:/etc/rc.d/rc 5<br> l6:6:wait:/etc/rc.d/rc 6 </p><p> ###在启动过程中允许按 CTRL-ALT-DELETE 重启系统<br> # Trap CTRL-ALT-DELETE<br> ca::ctrlaltdel:/sbin/shutdown -t3 -r now </p><p> # When our UPS tells us power has failed, assume we have a few minutes<br> # of power left. Schedule a shutdown for 2 minutes from now.<br> # This does, of course, assume you have powerd installed and your<br> # UPS connected and working correctly.<br> pf::powerfail:/sbin/shutdown -f -h +2 “Power Failure; System Shutting Down” </p><p> # If power was restored before the shutdown kicked in, cancel it.<br> pr:12345:powerokwait:/sbin/shutdown -c “Power Restored; Shutdown Cancelled” </p><p> ###在 2、3、4、5 级别上以 ttyX 为参数执行/sbin/mingetty 程序，打开 ttyX 终端用于用户登录， ###如果进程退出则再次运行 mingetty 程序(respawn)<br> # Run gettys in standard runlevels<br> 1:2345:respawn:/sbin/mingetty tty1<br> 2:2345:respawn:/sbin/mingetty tty2<br> 3:2345:respawn:/sbin/mingetty tty3<br> 4:2345:respawn:/sbin/mingetty tty4<br> 5:2345:respawn:/sbin/mingetty tty5<br> 6:2345:respawn:/sbin/mingetty tty6 </p><p>​     ###在 5 级别上运行 xdm 程序，提供 xdm 图像方式登录界面，并在退出时重新执行(respawn)      # Run xdm in runlevel 5<br>​     x:5:respawn:/etc/X11/prefdm -nodaemon<br>​<br>​     以上面的 inittab 文件为例，来说明一下 inittab 的格式。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：<br>​<br>​     id:runlevel:action:process<br>​     </p><p> 对上面各项的周详解释如下： </p><p> \1. id </p><p>​     id 是指入口标识符，他是个字符串，对于 getty 或 mingetty 等其他 login 程序项，需求 id 和 tty 的编号相同，否则 getty 程序将不能正常工作。 </p><p> \2. runlevel </p><p>​     runlevel 是 init 所处于的运行级别的标识，一般使用 0－6 及 S 或 s。0、1、6 运行级别被系统保留：其中 0 作为 shutdown 动作，1 作为重启至单用户模式，6 为重启；S 和 s 意义相同，表示单用户模式，且无需 inittab 文件，因此也不在 inittab 中出现，实际上，进入单用户模式时，init 直接在控制台（/dev/console）上运行/sbin/sulogin。在一般的系统实现中，都使用了 2、3、4、5 几个级别，在 Redhat系统中，2 表示无 NFS 支持的多用户模式，3 表示完全多用户模式（也是最常用的级别），4 保留给用户自定义，5 表示 XDM 图像登录方式。7－ 9 级别也是能使用的，传统的 Unix 系统没有定义这几个级别。runlevel 能是并列的多个值，以匹配多个运行级别，对大多数 action 来说，仅当 runlevel 和当前运行级别匹配成功才会执行。<br>​<br>​     3. action<br>​     </p><p>​         action 是描述其后的 process 的运行方式的。action 可取的值包括：initdefault、sysinit、boot、bootwait等：<br>​<br>  initdefault是个特别的 action 值，用于标识缺省的启动级别；当 init 由核心激活以后，他将读取 inittab中的 initdefault 项，取得其中的 runlevel，并作为当前的运行级别。如果没有 inittab 文件，或其中没有initdefault 项， init 将在控制台上请求输入 runlevel。<br>​<br>​         sysinit、boot、bootwait 等 action 将在系统启动时无条件运行，而忽略其中的 runlevel。<br>​<br>​         其余的 action（不含 initdefault）都和某个 runlevel 相关。各个 action 的定义在 inittab 的 man 手册中有周详的描述。<br>​<br>​         4. process<br>​<br>​         process 为具体的执行程序。程序后面能带参数。<br>​<br>​         第三部分：系统初始化<br>​<br>​         在 init 的设置文件中有这么一行：<br>​<br>​         si::sysinit:/etc/rc.d/rc.sysinit<br>​<br>​         他调用执行了/etc/rc.d/rc.sysinit，而 rc.sysinit 是个 bash shell 的脚本，他主要<br>在 init 的设置文件中有这么一行：<br>si::sysinit:/etc/rc.d/rc.sysinit </p><p>他 调用执行了/etc/rc.d/rc.sysinit，而 rc.sysinit 是个 bash shell 的脚本，他主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。他主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块及其他一些需要优先执行任务。 </p><p>rc.sysinit 约有 850 多行，不过每个单一的功能还是比较简单，而且带有注释，建议有兴趣的用户能自行阅读自己机器上的该文件，以了解系统初始化所周详情况。由于此文件较长，所以不在本文中列出来，也不做具体的介绍。<br>当 rc.sysinit 程序执行完毕后，将返回 init 继续下一步。<br>第四部分：启动对应运行级别的守护进程<br>在 rc.sysinit 执行后，将返回 init 继续其他的动作，通常接下来会执行到/etc/rc.d/rc 程序。以运行级别 5为例，init 将执行设置文件 inittab 中的以下这行：<br>l5:5:wait:/etc/rc.d/rc 5 </p><p>这一行表示以 5 为参数运行/etc/rc.d/rc，/etc/rc.d/rc 是个 Shell 脚本，他接受 5 作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的 rc 启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些 rc 启动脚本有着类似的用法，他们一般能接受 start、stop、 restart、status 等参数。<br>/etc/rc.d/rc5.d/中的 rc 启动脚本通常是 K 或 S 开头的链接文件，对于以以 S 开头的启动脚本，将以 start参数来运行。而如果发现存在相应的脚本也存在 K 打头的链接，而且已处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以 stop 为参数停止这些已启动了的守护进程，然后再重新运行。这样做是为了确保是当 init 改动运行级别时，所有相关的守护进程都将重启。<br>至于在每个运行级中将运行哪些守护进程，用户能通过 chkconfig 或 setup 中的”System Services”来自行设定。常见的守护进程有：<br>amd：自动安装 NFS 守护进程<br>     apmd:高级电源管理守护进程<br>     arpwatch：记录日志并构建一个在 LAN 接口上看到的以太网地址和 IP 地址对数据库<br>     autofs：自动安装管理进程 automount，和 NFS 相关，依赖于 NIS<br>     crond：Linux 下的计划任务的守护进程<br>     named：DNS 服务器<br>     netfs：安装 NFS、Samba 和 NetWare 网络文件系统<br>     network：激活已设置网络接口的脚本程序<br>     nfs：打开 NFS 服务<br>     portmap：RPC portmap 管理器，他管理基于 RPC 服务的连接<br>     sendmail：邮件服务器 sendmail<br>     smb：Samba 文件共享/打印服务<br>     syslog：一个让系统引导时起动 syslog 和 klogd 系统日志守候进程的脚本<br>     xfs：X Window 字型服务器，为本地和远程 X 服务器提供字型集<br>     Xinetd：支持多种网络服务的核心守护进程，能管理 wuftp、sshd、telnet 等服务<br>这些守护进程也启动完成了，rc 程序也就执行完了，然后又将返回 init 继续下一步。<br>第五部分：建立终端<br>rc 执行完毕后，返回 init。这时基本系统环境已设置好了，各种守护进程也已启动了。init 接下来会打开 6 个终端，以便用户登录系统。通过按 Alt+Fn(n 对应 1-6)能在这 6 个终端中转换。在 inittab 中的以下6 行就是定义了 6 个终端：<br>1:2345:respawn:/sbin/mingetty tty1<br>     2:2345:respawn:/sbin/mingetty tty2<br>     3:2345:respawn:/sbin/mingetty tty3<br>     4:2345:respawn:/sbin/mingetty tty4<br>     5:2345:respawn:/sbin/mingetty tty5<br>     6:2345:respawn:/sbin/mingetty tty6 </p><p>从上面能看出在 2、3、4、5 的运行级别中都将以 respawn 方式运行 mingetty 程序，mingetty 程序能打开终端、设置模式。同时他会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给 login 程序来验证用户的身份。 第六部分：登录系统，启动完成<br>对于运行级别为 5 的图像方式用户来说，他们的登录是通过一个图像化的登录界面。登录成功后能直接进入 KDE、Gnome 等窗口管理器。而本文主要讲的还是文本方式登录的情况：<br>当我们看到 mingetty 的登录界面时，我们就能输入用户名和密码来登录系统了。<br>     Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。然后 login 会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非 root 用户登录。只有/etc/securetty 中登记了的终端才允许 root用户登录，如果不存在这个文件，则 root 能在所有终端上登录。/etc /usertty 文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。<br>在分析完用户名后，login 将搜索/etc/passwd 及/etc/shadow 来验证密码及设置账户的其他信息，比如：主目录是什么、使用何种 shell。如果没有指定主目录，将默认为根目录；如果没有指定 shell，将默认为/bin/bash。<br>login 程序成功后，会向对应的终端在输出最近一次登录的信息(在/var/log/lastlog 中有记录)，并检查用户是否有新邮件(在/usr/spool /mail/的对应用户名目录下)。然后开始设置各种环境变量：对于 bash 来说，系统首先寻找/etc/profile 脚本文件，并执行他；然后如果用户的主目录中存在.bash_profile 文件，就执行他，在这些文件中又可能调用了其他设置文件，所有的设置文件执行后后，各种环境变量也设好了，这时会出现大家熟悉的命令行提示符，到此整个启动过程就结束了。 </p><p>****4****、相关命令 </p><p> ****4.1****、查看当前系统运行等级 </p><table><thead><tr><th></th><th>[root@test ~]# runlevel</th><th></th><th></th></tr></thead><tbody><tr><td>N 5</td><td></td><td></td><td>//’N’代表先前的 Runlevel; ‘5’代表目前的 Runlevel</td></tr></tbody></table><p> ****4.2****、切换系统运行等级 </p><table><thead><tr><th></th><th>#init N</th><th></th><th>//切换到运行级别 N</th></tr></thead><tbody><tr><td># init 0</td><td>//关机</td><td></td><td></td></tr><tr><td># init 6</td><td>//重启动系统</td><td></td><td></td></tr></tbody></table><p><em><strong>*十、*</strong></em> <em><strong>*进程管理*</strong></em> </p><p>进程就是运行中的程序，一个运行着的程序，可能有多个进程。 比如 LinuxSir.Org 所用的 WWW服务器是 apache 服务器，当管理员启动服务后，可能会有好多人来访问，也就是说许多用户来同时请求 httpd 服务，apache 服务器将会创建有多个 httpd 进程来对其进行服务。 </p><p>****1****、 进程分类 </p><p>​    进程一般分为交互进程、批处理进程和守护进程三类。<br>​    值得一提的是守护进程总是活跃的，一般是后台运行，守护进程一般是由系统在开机时通过脚本自动激活启动或超级管理用户 root 来启动。比如在 Fedora 或 Redhat 中，我们可以定义 httpd 服务器的启动脚本的运行级别，此文件位于/etc/init.d 目录下，文件名是 httpd，/etc/init.d/httpd 就是 httpd 服务器的守护程序，当把它的运行级别设置为 3 和 5 时，当系统启动时，它会跟着启动。<br>​    [root@localhost ~]# chkconfig  –level 35  httpd on </p><p>​    由于守护进程是一直运行着的，所以它所处的状态是等待请求处理任务。比如，我们是不是访问 LinuxSir.Org ，LinuxSir.Org 的 httpd 服务器都在运行，等待着用户来访问，也就是等待着任务处理。 </p><p>****2****、进程的属性 </p><p>进程 ID（PID)：是唯一的数值，用来区分进程；<br>父进程和父进程的 ID（PPID)；<br>启动进程的用户 ID（UID）和所归属的组（GID）；<br>进程状态：状态分为运行 R、休眠 S、僵尸 Z；<br>进程执行的优先级；<br>进程所连接的终端名；<br>进程资源占用：比如占用资源大小（内存、CPU 占用量）； </p><p>****3****、父进程和子进程 </p><p>​    他们的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进程并不一定终止。比如 httpd 服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止而终止。<br>​    在进程管理中，当我们发现占用资源过多，或无法控制的进程时，应该杀死它，以保护系统的稳定安全运行 </p><p>****4****、进程管理命令 </p><p><em><strong>*4.1*<em><strong>、</strong></em>*ps*</strong></em> </p><p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。 </p><p>****4.1.1****、 <em><strong>*ps*</strong></em> 的参数说明：<br>ps 提供了很多的选项参数，常用的有以下几个；<br>l  长格式输出；<br>u  按用户名和启动时间的顺序来显示进程；<br>j  用任务格式来显示进程；<br>f  用树形格式来显示进程；<br>a  显示所有用户的所有进程（包括其它用户）；<br>x  显示无控制终端的进程；<br>r  显示运行中的进程；<br>ww 避免详细参数被截断；<br>我们常用的选项是组合是 aux 或 lax，还有参数 f 的应用；<br>ps aux 或 lax 输出的解释； </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps6.jpg" alt="img"> </p><p>USER 表示启动进程用户。PID 表示进程标志号。%CPU 表示运行该进程占用 CPU 的时间与该进程总的运行时间的比例。%MEM 表示该进程占用内存和总内存的比例。VSZ 表示占用的虚拟内存大小，以 KB 为单位。RSS 为进程占用的物理内存值，以 KB 为单位。TTY 表示该进程建立时所对应的终端，”?”表示该进程不占用终端。STAT 表示进程的运行状态，包括以下几种代码：D，不可中断的睡眠；R，就绪（在可运行队列中）；S，睡眠；T，被跟踪或停止；Z，终止（僵死）的进程，Z 不</p><p>存在，但暂时无法消除；W，没有足够的内存分页可分配；&lt;高优先序的进程；N，低优先序的进程；L，有内存分页分配并锁在内存体内（实时系统或 I/O）。START 为进程开始时间。TIME 为执行的时间。COMMAND 是对应的命令名。 </p><p><em><strong>*4.1.2 ps*</strong></em> 应用举例 </p><p>实例一：ps aux 最常用<br>[root@localhost ~]# ps -aux |more </p><p>可以用 | 管道和 more 连接起来分页查看；<br>[root@localhost ~]# ps  aux  &gt; ps001.txt<br>[root@localhost ~]# more ps001.txt </p><p>这里是把所有进程显示出来，并输出到 ps001.txt 文件，然后再通过 more 来分页查看； 实例二：和 grep 结合，提取指定程序的进程；<br>[root@localhost ~]# ps aux |grep httpd<br>root    4187  0.0  1.3  24236 10272 ?     Ss  11:55  0:00 /usr/sbin/httpd apache   4189  0.0  0.6  24368  4940 ?     S   11:55  0:00 /usr/sbin/httpd apache   4190  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4191  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4192  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4193  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4194  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4195  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd apache   4196  0.0  0.6  24368  4932 ?     S   11:55  0:00 /usr/sbin/httpd root    4480  0.0  0.0  5160  708 pts/3   R+  12:20  0:00 grep httpd<br>实例二：父进和子进程的关系友好判断的例子<br>[root@localhost ~]# ps auxf  |grep httpd<br>root    4484  0.0  0.0  5160  704 pts/3   S+  12:21  0:00        _ grep httpd<br>root    4187  0.0  1.3  24236 10272 ?     Ss  11:55  0:00 /usr/sbin/httpd apache   4189  0.0  0.6  24368  4940 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4190  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4191  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4192  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4193  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4194  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4195  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd apache   4196  0.0  0.6  24368  4932 ?     S   11:55  0:00  _ /usr/sbin/httpd </p><p>​    这里用到了 f 参数；父与子关系一目了然；<br>​    例三：找出消耗内存最多的前 10 名进程<br>​    # ps -auxf | sort -nr -k 4 | head -10<br>​    例四：找出使用 CPU 最多的前 10 名进程<br># ps -auxf | sort -nr -k 3 | head -10 </p><p><em><strong>*4.2*<em><strong>、</strong></em>*pstree*</strong></em> </p><p>功能：pstree 命令列出当前的进程，以及它们的树状结构。<br>格式：pstree [选项] [pid|user]<br>主要选项如下： </p><p>-a：显示执行程序的命令与完整参数。<br>-c：取消同名程序，合并显示。<br>-h：对输出结果进行处理，高亮显示正在执行的程序。<br>-l：长格式显示。<br>-n：以 PID 大小排序。<br>-p：显示 PID。<br>-u：显示 UID 信息。<br>-G：使用 VT100 终端编码显示。<br>-U：使用 UTF-8（Unicode）编码显示。<br>说明：使用 ps 命令得到的数据精确，但数据庞大，这一点对掌握系统整体概况来说是不容易的。pstree正好可以弥补这个缺憾。它能将当前的执行程序以树状结构显示。pstree 支持指定特定程序（PID）或使用者（USER）作为显示的起始。<br>应用实例如下。<br>进程启动的时候可能会产生自己的一个子进程。运行 pstree 命令就可以很容易地看到这些信息。以超级用户权限运行 pstree： </p><p> ＃init-+-apmd  |-atd |-bdflush |-gconfd-2 |-gdm-binary—gdm-binary-+-X |             <code>-startkde-+-kwrapper |                   </code>-ssh-agent |-gpm |-httpd—8*[httpd] ……下略 </p><p>命令对程序名称相同的会自动合并，所有”|-httpd—8*[httpd]”即表示系统中有 8 个 httpd 进程产生的子进程。 </p><p><em><strong>*4.3*<em><strong>、</strong></em>*top*</strong></em> </p><p> top 命令用来显示系统当前的进程状况。<br>格式：top [选项]<br>主要选项如下。<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则 top 命令将会以最高的优先序执行。 c：显示进程完整的路径与名称。<br>S：累积模式，会将已完成或消失的子进程的 CPU 时间累积起来。 </p><p>s：安全模式。<br>i：不显示任何闲置（Idle）或无用（Zombie）的进程。<br>n：显示更新的次数，完成后将会退出 top。<br>说明：top 命令和 ps 命令的基本作用是相同的，都显示系统当前的进程状况。但是 top 是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。这里结合下图来说明它给出的信息。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps7.jpg" alt="img"> </p><p>第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。<br>第二行显示的是 Tasks: 114 total 进程总数、2 running 正在运行的进程数、110 sleeping 睡眠的进程数、    0 stopped 停止的进程数、2 zombie 僵尸进程数<br>第三行显示的是目前 CPU 的使用情况，Cpu(s): 0.3% us 用户空间占用 CPU 百分比、1.0% sy 内核空间    占用 CPU 百分比、0.0% ni 用户进程空间内改变过优先级的进程占用 CPU 百分比、98.7% id 空    闲 CPU 百分比、0.0% wa 等待输入输出的 CPU 时间百分比、0.0% hi、0.0% si<br>第四行显示物理内存的使用情况，Mem: 191272k total 物理内存总量、173656k used 使用的物理内存    总量、17616k free 空闲内存总量、22052k buffers 用作内核缓存的内存量<br>第五行显示交换分区使用情况，Swap: 192772k total 交换区总量、0k used 使用的交换区总量、192772k     free 空闲交换区总量、123988k cached 缓冲的交换区总量、内存中的内容被换出到交换区，    而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的    交换区的大小。相应的内存再次被换出时可不必再对交换区写入。<br>第六行显示的项目最多，下面列出了详细解释。<br>PID（Process ID）：进程标志号，是非零正整数。USER：进程所有者的用户名。PR：进程的优先级别。NI：进程的优先级别数值。VIRT：进程占用的虚拟内存值。RES：进程占用的物理内存值。SHR：进程使用的共享内存值。STAT：进程的状态，其中 S 表示休眠，R 表示正在运行，Z 表示僵死状态，N 表示该进程优先值是负数。%CPU：该进程占用的 CPU 使用率。%MEM：该进程占用的物理内存和总内</p><p>存的百分比。TIME：该进程启动后占用的总的 CPU 时间。COMMAND：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。<br>top 命令使用过程中，还可以使用一些交互的命令来完成其他参数的功能。这些命令是通过快捷键启动的。<br>&lt;空格&gt;：立刻刷新。<br>A 分类显示系统不同资源的使用大户。有助于快速识别系统中资源消耗多的任务。<br>f 添加删除所要显示栏位.<br>o 调整所要显示栏位的顺序.<br>r 调整一个正在运行的进程 Nice 值.<br>k 结束一个正在运行的进程.<br>z 彩色/黑白显示开关<br>P：根据 CPU 使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出 top 命令。<br>m：切换显示内存信息。<br>t：切换显示进程和 CPU 状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入～/.toprc 文件中。这是写 top 配置文件的推荐方法。<br>可以看到，top 命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，它的缺点是会消耗很多系统资源。 </p><p><em><strong>*十一、*</strong></em> <em><strong>*资源监控*</strong></em> </p><p>****1*<em><strong>、</strong></em>*free****内存监控 </p><p>语  法： free [-bkmotV][-s &lt;间隔秒数&gt;]<br>补充说明：free 指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。<br>参  数：<br>-b  以 Byte 为单位显示内存使用情况。<br>-k  以 KB 为单位显示内存使用情况。<br>-m  以 MB 为单位显示内存使用情况。<br>-o  不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt;  持续观察内存使用状况。<br>-t  显示内存总和列。<br>-V  显示版本信息。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps8.jpg" alt="img"> </p><p>Mem：表示物理内存统计<br>-/+ buffers/cached：表示物理内存的缓存统计<br>Swap：表示硬盘上交换分区的使用情况<br>第 1 行 Mem： total：表示物理内存总量。 </p><p>used：表示总计分配给缓存（包含 buffers 与 cache ）使用的数量，但其中可能部分缓存并未实际使用。<br>free：未被分配的内存。<br>shared：共享内存，一般系统不会用到，这里也不讨论。<br>buffers：系统分配但未被使用的 buffers 数量。<br>cached：系统分配但未被使用的 cache 数量。buffer 与 cache 的区别见后面。 total = used + free 第 2 行 -/+ buffers/cached： used：也就是第一行中的 used – buffers-cached 也是实际使用的内存总量。<br>free：未被使用的 buffers 与 cache 和未被分配的内存之和，这就是系统当前实际可用内存。 free 2= buffers1 + cached1 + free1 //free2 为第二行、buffers1 等为第一行<br>A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use 第 3 行： 第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为 buffer/cached 是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached 会很快地被回收。<br>所以从应用程序的角度来说，可用内存=系统 free memory+buffers+cached.<br>接下来解释什么时候内存会被交换，以及按什么方交换。<br>当可用内存少于额定值的时候，就会开会进行交换，如何看额定值（RHEL4.0）：<br>#cat /proc/meminfo<br>交换将通过三个途径来减少系统中使用的物理页面的个数：<br>1.减少缓冲与页面 cache 的大小，<br>2.将系统 V 类型的内存页面交换出去，<br>3.换出或者丢弃页面。(Application 占用的内存页，也就是物理内存不足）。<br>事实上，少量地使用 swap 是不是影响到系统性能的。<br>下面是 buffers 与 cached 的区别：<br>buffers 是指用来给块设备做的缓冲大小，他只记录文件系统的 metadata 以及 tracking in-flight pages.<br>cached 是用来给文件做缓冲。<br>那就是说：buffers 是用来存储，目录里面有什么内容，权限等等。<br>而 cached 直接用来记忆我们打开的文件 ，如果你想知道他是不是真的生效，你可以试一下，先后执行两次命令#man X ,你就可以明显的感觉到第二次的开打的速度快很多。<br>实验：在一台没有什么应用的机器上做会看得比较明显。记得实验只能做一次，如果想多做请换一个文件名。<br>#free<br>#man X<br>#free<br>#man X<br>#free<br>你可以先后比较一下 free 后显示 buffers 的大小。<br>另一个实验：<br>#free<br>#ls /dev<br>#free<br>你比较一下两个的大小，当然这个 buffers 随时都在增加，但你有 ls 过的话，增加的速度会变得快，这个就是 buffers/chached 的区别。 </p><p>​    因为 Linux 将你暂时不使用的内存作为文件和数据缓存，以提高系统性能，当你需要这些内存时，系统会自动释放（不像 windows 那样，即使你有很多空闲内存,他也要访问一下磁盘中的 pagefiles） 使用 free 命令<br>将 used 的值减去  buffer 和 cache 的值就是你当前真实内存使用 ————– 对操作系统 来讲是Mem 的参数.buffers/cached 都是属于被使用,所以它认为 free 只有 16936 .<br>对应用程序 来讲是(-/+ buffers/cach).buffers/cached 是等同可用的，因为 buffer/cached 是为 了提高 程序执行的性能， 当程序使用内存时，buffer/cached 会很快地被使用。 所以,以应用来看看,以(-/+ buffers/cache)的 free 和 used 为主.所以我们看这个就好了.另外告诉大家 一些常识.Linux为了提高磁盘和内存存取效率, Linux 做了很多精心的设计, 除了对 dentry 进行缓存(用于 VFS,加速文件路径名到 inode 的转换), 还采取了两种主要 Cache 方式：Buffer Cache 和 Page Cache。 前者针对磁盘块的读写，后者针对文件 inode 的读写。这些 Cache 能有效缩短了 I/O 系统调用(比如read,write,getdents)的时间。 记住内存是拿来用的,不是拿来看的. 不象 windows,无论你的真实物理内存有多少,他都要拿硬盘交换 文件来读.这也就是 windows 为什么常常提示虚拟空间不足的原因.你们想想,多无聊,在内存还有大部分 的时候,拿出一部分硬盘空间来充当内存.硬盘怎么会快过内存.所以我们看 linux,只要不用 swap 的交换 空间,就不用担心自己的内存太少.如果常常 swap 用很多,可能你就要考虑加物理内存了.这也是 linux 看 内存是否够用的标准哦.<br>[root@scs-2 tmp]# free<br>​         total    used    free   shared   buffers   cached<br>Mem:    3266180   3250004    16176      0   110652   2668236<br>-/+ buffers/cache:   471116   2795064<br>Swap:    2048276    80160   1968116<br>下面是对这些数值的解释：<br>total:总计物理内存的大小。<br>used:已使用多大。<br>free:可用有多少。<br>Shared:多个进程共享的内存总额。<br>Buffers/cached:磁盘缓存的大小。<br>第三行(-/+ buffers/cached):<br>used:已使用多大。<br>free:可用有多少。<br>第四行就不多解释了。<br>区别：第二行(mem)的 used/free 与第三行(-/+ buffers/cache) used/free 的区别。 这两个的区别在于使用的角度来看，第一行是从 OS 的角度来看，因为对于 OS，buffers/cached 都是属于被使用，所以他的可用内存是 16176KB,已用内存是 3250004KB,其中包括，内核（OS）使用+Application(X, oracle,etc)使用的+buffers+cached.<br>第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached 是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached 会很快地被回收。<br>所以从应用程序的角度来说，可用内存=系统 free memory+buffers+cached。<br>如上例：<br>2795064=16176+110652+2668236 </p><p>接下来解释什么时候内存会被交换，以及按什么方交换。 当可用内存少于额定值的时候，就会开会进行交换。<br>如何看额定值： </p><p>cat /proc/meminfo<br>[root@scs-2 tmp]# cat /proc/meminfo<br>MemTotal:    3266180 kB<br>MemFree:     17456 kB<br>Buffers:     111328 kB<br>Cached:     2664024 kB<br>SwapCached:      0 kB<br>Active:     467236 kB<br>Inactive:    2644928 kB<br>HighTotal:      0 kB<br>HighFree:       0 kB<br>LowTotal:    3266180 kB<br>LowFree:     17456 kB<br>SwapTotal:   2048276 kB<br>SwapFree:    1968116 kB<br>Dirty:        8 kB<br>Writeback:      0 kB<br>Mapped:     345360 kB<br>Slab:      112344 kB<br>Committed_AS:  535292 kB<br>PageTables:    2340 kB<br>VmallocTotal: 536870911 kB<br>VmallocUsed:   272696 kB<br>VmallocChunk: 536598175 kB<br>HugePages_Total:   0<br>HugePages_Free:    0<br>Hugepagesize:   2048 kB<br>用 free -m 查看的结果：<br>[root@scs-2 tmp]# free -m<br>     total    used    free   shared   buffers   cached<br>Mem:      3189    3173     16      0     107    2605<br>-/+ buffers/cache:     460    2729<br>Swap:     2000     78    1921 </p><p>查看/proc/kcore 文件的大小（内存镜像）：<br>[root@scs-2 tmp]# ll -h /proc/kcore<br>-r——– 1 root root 4.1G Jun 12 12:04 /proc/kcore </p><p>备注：<br>占用内存的测量<br>测量一个进程占用了多少内存，linux 为我们提供了一个很方便的方法，/proc 目录为我们提供了所有的信息，实际上 top 等工具也通过这里来获取相应的信息。<br>/proc/meminfo 机器的内存使用信息<br>/proc/pid/maps pid 为进程号，显示当前进程所占用的虚拟地址。<br>/proc/pid/statm 进程所占用的内存 </p><p>[root@localhost ~]# cat /proc/self/statm<br>654 57 44 0 0 334 0 </p><p>输出解释<br>CPU 以及 CPU0。。。的每行的每个参数意思（以第一行为例）为：<br>参数 解释 /proc//status<br>Size (pages) 任务虚拟地址空间的大小 VmSize/4<br>Resident(pages) 应用程序正在使用的物理内存的大小 VmRSS/4<br>Shared(pages) 共享页数 0<br>Trs(pages) 程序所拥有的可执行虚拟内存的大小 VmExe/4<br>Lrs(pages) 被映像到任务的虚拟内存空间的库的大小 VmLib/4<br>Drs(pages) 程序数据段和用户态的栈的大小 （VmData+ VmStk ）4<br>dt(pages) 04 </p><p>查看机器可用内存<br>/proc/28248/&gt;free<br>total used free shared buffers cached<br>Mem: 1023788 926400 97388 0 134668 503688<br>-/+ buffers/cache: 288044 735744<br>Swap: 1959920 89608 1870312<br>我们通过 free 命令查看机器空闲内存时，会发现 free 的值很小。这主要是因为，在 linux 中有这么一种思想，内存不用白不用，因此它尽可能的 cache 和 buffer 一些数据，以方便下次使用。但实际上这些内存也是可以立刻拿来使用的。<br>所以 空闲内存=free+buffers+cached=total-used </p><p><em><strong>*2*<em><strong>、</strong></em>*vmstat*</strong></em> </p><p> 很显然从名字中我们就可以知道 vmstat 是一个查看虚拟内存（Virtual Memory）使用状况的工具，但是怎样通过 vmstat 来发现系统中的瓶颈呢？在回答这个问题前，还是让我们回顾一下 Linux 中关于虚拟内存相关内容。 </p><p>****2.1****、虚拟内存运行原理 </p><p>在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。 在 Linux 内存管理中，主要是通过“调页 Paging”和“交换 Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。<br>分页(Page)写入磁盘的过程被称作 Page-Out，分页(Page)从磁盘重新回到内存的过程被称作 Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被 Page-Out 了)，此时就发生了分页错误（Page Fault）。<br>当系统内核发现可运行内存变少时，就会通过 Page-Out 来释放一部分物理内存。经管 Page-Out 不是经常发生，但是如果 Page-out 频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作 thrashing(颠簸)。 </p><p><em><strong>*2.2*<em><strong>、使用</strong></em>*vmstat*</strong></em> </p><p>1.用法<br>    vmstat [-a] [-n] [-S unit] [delay [ count]] </p><p>vmstat [-s] [-n] [-S unit]<br>vmstat [-m] [-n] [delay [ count]]<br>vmstat [-d] [-n] [delay [ count]]<br>vmstat [-p disk partition] [-n] [delay [ count]]<br>vmstat [-f]<br>vmstat [-V] </p><p>-a：显示活跃和非活跃内存<br>-f：显示从系统启动至今的 fork 数量 。<br>-m：显示 slabinfo<br>-n：只在开始时显示一次各字段名称。<br>-s：显示内存相关统计信息及多种系统活动数量。<br>delay：刷新时间间隔。如果不指定，只显示一条结果。<br>count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。<br>-d：显示磁盘相关统计信息。<br>-p：显示指定磁盘分区统计信息<br>-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表 1000、1024、1000000、1048576 字节（byte）。默认单位为 K（1024 bytes）<br>-V：显示 vmstat 版本信息。 </p><p>****2.3****、实例 </p><p> 例子 ****1****：每 <em><strong>*2*</strong></em> 秒输出一条结果 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps9.jpg" alt="img"> </p><p>字段说明：<br>****Procs****（进程）： </p><p>r: 运行的和等待(CPU 时间片)运行的进程数，这个值也可以判断是否需要增加 CPU(长期大于 1) b: 等待 IO 的进程数量，处于不可中断状态的进程数，常见的情况是由 IO 引起的 </p><p>****Memory****（内存）： </p><p>swpd: 使用虚拟内存大小，切换到交换内存上的内存(默认以 KB 为单位)<br>如果 swpd 的值不为 0，或者还比较大，比如超过 100M 了，但是 si, so 的值长期为 0，这种情况我    们可以不用担心，不会影响系统性能。<br>free: 空闲的物理内存<br>buff: 用作缓冲的内存大小<br>cache: 用作缓存的内存大小，文件系统的 cache，如果 cache 的值大的时候，说明 cache 住的文件数    多，如果频繁访问到的文件都能被 cache 住，那么磁盘的读 IO bi 会非常小 </p><p>****Swap****： </p><p>si: 每秒从交换区写到内存的大小，交换内存使用，由磁盘调入内存<br>so: 每秒写入交换区的内存大小，交换内存使用，由内存调入磁盘<br>内存够用的时候，这 2 个值都是 0，如果这 2 个值长期大于 0 时，系统性能会受到影响。磁盘 IO 和CPU 资源都会被消耗。 </p><p>常有人看到空闲内存(free)很少或接近于 0 时，就认为内存不够用了，实际上不能光看这一点的，还要结合 si,so，如果 free 很少，但是 si,so 也很少(大多时候是 0)，那么不用担心，系统性能这时不会受到影响的。 </p><p>****IO****：（现在的 <em><strong>*Linux*</strong></em> 版本块的大小为 ****1024bytes****） </p><p>bi: 每秒读取的块数，从块设备读入的数据总量(读磁盘) (KB/s)<br>bo: 每秒写入的块数，写入到块设备的数据总理(写磁盘) (KB/s)<br>随机磁盘读写的时候，这 2 个 值越大（如超出 1M），能看到 CPU 在 IO 等待的值也会越大 </p><p>****system****： </p><p>in: 每秒中断数，包括时钟中断。<br>cs: 每秒上下文切换数。<br>上面这 2 个值越大，会看到由内核消耗的 CPU 时间会越多 </p><p>****CPU****（以百分比表示）： </p><p>us: 用户进程消耗的 CPU 时间百分比，us 的值比较高时，说明用户进程消耗的 CPU 时间多，但是如        果长期超过 50% 的使用，那么我们就该考虑优化程序算法或者进行加速了<br>sy: 内核进程消耗的 CPU 时间百分比，sy 的值高时，说明系统内核消耗的 CPU 资源多，这并不是良        性的表现，我们应该检查原因。<br>id: CPU 处在空闲状态时间百分比(包括 IO 等待时间)<br>wa: IO 等待消耗的 CPU 时间百分比，wa 的值高时，说明 IO 等待比较严重，这可能是由于磁盘大量作随机访问造成，也有可能是磁盘的带宽出现瓶颈(块操作)。 </p><p>例子 ****2****：显示活跃和非活跃内存 </p><table><thead><tr><th></th><th><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps10.jpg" alt="img"></th></tr></thead><tbody><tr><td>使用-a 选项显示活跃和非活跃内存时，所显示的内容除增加 inact 和 active 外，其他显示内容与例子 1相同。  字段说明：  ****Memory****（内存）：</td><td></td></tr></tbody></table><p>inact: 非活跃内存大小（当使用-a 选项时显示）<br>active: 活跃的内存大小（当使用-a 选项时显示） </p><p>注：如果 r 经常大于 4，且 id 经常少于 40，表示 cpu 的负荷很重，如果 bi，bo 长期不等于 0，表示内存不足，如果 disk 经常不等于 0，且在 b 中的队列大于 3，表示 io 性能不好。<br>CPU 问题现象：<br>1.)如果在processes中运行的序列(process r)是连续的大于在系统中的CPU的个数表示系统现在运行比较慢,有多数的进程等待 CPU.<br>2.)如果 r 的输出数大于系统中可用 CPU 个数的 4 倍的话,则系统面临着 CPU 短缺的问题,或者是 CPU 的速率过低,系统中有多数的进程在等待 CPU,造成系统中进程运行过慢.<br>3.)如果空闲时间(cpu id)持续为 0 并且系统时间(cpu sy)是用户时间的两倍(cpu us)系统则面临着 CPU 资源的短缺.<br>    解决办法: </p><p>​    当发生以上问题的时候请先调整应用程序对 CPU 的占用情况.使得应用程序能够更有效的使用 CPU.同    时可以考虑增加更多的 CPU.  关于 CPU 的使用情况还可以结合 mpstat,  ps aux top  prstat –a 等    等一些相应的命令来综合考虑关于具体的 CPU 的使用情况,和那些进程在占用大量的 CPU 时间.一般情    况下，应用程序的问题会比较大一些.比如一些 SQL 语句不合理等等都会造成这样的现象.<br>内存问题现象:<br>​        内存的瓶颈是由 scan rate (sr)来决定的.scan rate 是通过每秒的始终算法来进行页扫描的.如果 scan rate(sr)连续的大于每秒 200 页则表示可能存在内存缺陷.同样的如果 page 项中的 pi 和 po 这两栏表示每秒页面的调入的页数和每秒调出的页数.如果该值经常为非零值,也有可能存在内存的瓶颈,当然,如果个别的时候不为 0 的话,属于正常的页面调度这个是虚拟内存的主要原理.<br>​        解决办法:<br>​    1.调节 applications &amp; servers 使得对内存和 cache 的使用更加有效.<br>​    2.增加系统的内存.<br>​    3. Implement priority paging in s in pre solaris 8 versions by adding line “set priority paging=1” in     /etc/system. Remove this line if upgrading from Solaris 7 to 8 &amp; retaining old /etc/system file. </p><p>关于内存的使用情况还可以结 ps aux top  prstat –a 等等一些相应的命令来综合考虑关于具体的内存的使用情况,和那些进程在占用大量的内存.一般情况下，如果内存的占用率比较高,但是,CPU 的占用很低的时候,可以考虑是有很多的应用程序占用了内存没有释放,但是,并没有占用 CPU 时间,可以考虑应用程序,对于未占用 CPU 时间和一些后台的程序,释放内存的占用 </p><p>****4.4****、案例 </p><p> 案例学习：<br>1：在这个例子中,这个系统被充分利用<br># vmstat 1<br>procs            memory    swap      io   system     cpu<br>r  b  swpd  free  buff  cache  si  so   bi   bo  in   cs us sy wa id<br>3  0 206564  15092  80336 176080   0   0   0   0  718   26 81 19  0  0<br>2  0 206564  14772  80336 176120   0   0   0   0  758   23 96  4  0  0<br>1  0 206564  14208  80336 176136   0   0   0   0  820   20 96  4  0  0<br>1  0 206956  13884  79180 175964   0  412   0  2680 1008   80 93  7  0  0<br>2  0 207348  14448  78800 175576   0  412   0  412  763   70 84 16  0  0<br>2  0 207348  15756  78800 175424   0   0   0   0  874   25 89 11  0  0<br>1  0 207348  16368  78800 175596   0   0   0   0  940   24 86 14  0  0<br>1  0 207348  16600  78800 175604   0   0   0   0  929   27 95  3  0  2<br>3  0 207348  16976  78548 175876   0   0   0  2508  969   35 93  7  0  0<br>4  0 207348  16216  78548 175704   0   0   0   0  874   36 93  6  0  1<br>4  0 207348  16424  78548 175776   0   0   0   0  850   26 77 23  0  0<br>2  0 207348  17496  78556 175840   0   0   0   0  736   23 83 17  0  0<br>0  0 207348  17680  78556 175868   0   0   0   0  861   21 91  8  0  1<br>根据观察值,我们可以得到以下结论：<br>1.有大量的中断(in) 和较少的上下文切换(cs).这意味着一个单一的进程在产生对硬件设备的请求. 2.进一步显示某单个应用,user time(us)经常在 85%或者更多.考虑到较少的上下文切换,这个应用应该还在处理器中被处理.<br>3.运行队列还在可接受的性能范围内,其中有 2 个地方,是超出了允许限制.<br>2：在这个例子中,内核调度中的上下文切换处于饱和<br># vmstat 1 </p><p>procs            memory    swap      io   system     cpu<br>r  b  swpd  free  buff  cache  si  so   bi   bo  in   cs us sy wa id<br>2  1 207740  98476  81344 180972   0   0  2496   0  900  2883  4 12 57 27<br>0  1 207740  96448  83304 180984   0   0  1968  328  810  2559  8  9 83  0<br>0  1 207740  94404  85348 180984   0   0  2044   0  829  2879  9  6 78  7<br>0  1 207740  92576  87176 180984   0   0  1828   0  689  2088  3  9 78 10<br>2  0 207740  91300  88452 180984   0   0  1276   0  565  2182  7  6 83  4<br>3  1 207740  90124  89628 180984   0   0  1176   0  551  2219  2  7 91  0<br>4  2 207740  89240  90512 180984   0   0  880  520  443  907 22 10 67  0<br>5  3 207740  88056  91680 180984   0   0  1168   0  628  1248 12 11 77  0<br>4  2 207740  86852  92880 180984   0   0  1200   0  654  1505  6  7 87  0<br>6  1 207740  85736  93996 180984   0   0  1116   0  526  1512  5 10 85  0<br>0  1 207740  84844  94888 180984   0   0  892   0  438  1556  6  4 90  0 </p><p>根据观察值,我们可以得到以下结论：<br>1.上下文切换数目高于中断数目,说明 kernel 中相当数量的时间都开销在上下文切换线程.<br>2.大量的上下文切换将导致 CPU 利用率分类不均衡.很明显实际上等待 io 请求的百分比(wa)非常高,<br>以及 user time 百分比非常低(us).<br>3.因为 CPU 都阻塞在 IO 请求上,所以运行队列里也有相当数目的可运行状态线程在等待执行. </p><p><em><strong>*3*<em><strong>、</strong></em>*iostat*</strong></em> </p><p>​    用途：报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入／<br>​            输出统计信息。<br>​        语法：iostat [ -c | -d ] [ -k ] [ -t | -m ] [ -V ] [ -x [ device ] ] [ interval [ count ] ]<br>​        描述：iostat 命令用来监视系统输入／输出设备负载，这通过观察与它们的平均传送速率相关的物<br>理磁盘的活动时间来实现。iostat 命令生成的报告可以用来更改系统配置来更好地平衡物理磁盘和适配<br>器之间的输入／输出负载。<br> 参数：-c 为汇报 CPU 的使用情况；-d 为汇报磁盘的使用情况；-k 表示每秒按 kilobytes 字节显示数据；<br>-m 表示每秒按 M 字节显示数据；-t 为打印汇报的时间；-v 表示打印出版本信息和用法；-x device 指定<br>要统计的设备名称，默认为所有的设备；interval 指每次统计间隔的时间；count 指按照这个时间间隔统<br>计的次数。<br>iostat 结果解析 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps11.jpg" alt="img"> </p><p>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s<br>wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s<br>r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s<br>w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s<br>rsec/s: 每秒读扇区数。即 delta(rsect)/s </p><p>wsec/s: 每秒写扇区数。即 delta(wsect)/s<br>rkB/s: 每秒读 K 字节数。是 rsect/s 的一半，因为每扇区大小为 512 字节。<br>wkB/s: 每秒写 K 字节数。是 wsect/s 的一半。<br>avgrq-sz: 平均每次设备 I/O 操作的数据大小 (扇区)。即 delta(rsect+wsect)/delta(rio+wio)<br>avgqu-sz: 平均 I/O 队列长度。即 delta(aveq)/s/1000 (因为 aveq 的单位为毫秒)。<br>await: 平均每次设备 I/O 操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)<br>svctm: 平均每次设备 I/O 操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)<br>%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为 use 的单位为毫秒)<br>如果 %util 接近 100%，说明产生的 I/O 请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈。 比较重要的参数<br>%util:    一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的 svctm:  平均每次设备 I/O 操作的服务时间<br>await:   平均每次设备 I/O 操作的等待时间<br>avgqu-sz: 平均 I/O 队列长度<br>如果%util 接近 100%,表明 i/o 请求太多,i/o 系统已经满负荷,磁盘可能存在瓶颈,一般%util 大于 70%,i/o 压力就比较大,读取速度有较多的 wait.同时可以结合 vmstat 查看查看 b 参数(等待资源的进程数)和 wa 参数(IO 等待所占用的 CPU 时间的百分比,高过 30%时 IO 压力高)。<br>要理解这些性能指标我们先看下图 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps12.jpg" alt="img"> </p><p>IO 的执行过程的各个参数<br>    上图的左边是 iostat 显示的各个性能指标，每个性能指标都会显示在一条虚线之上，这表明这个性能指标是从虚线之上的那个读写阶段开始计量的，比如说图中的 w/s 从 Linux IO scheduler 开始穿过硬盘控制器(CCIS/3ware)，这就表明w/s 统计的是每秒钟从 Linux IO scheduler 通过硬盘控制器的写 IO的数量。 结合上图对读 IO 操作的过程做一个说明，在从 OS Buffer Cache 传入到 OS Kernel(Linux IO scheduler)的读 IO 操作的个数实际上是 rrqm/s+r/s，直到读 IO 请求到达 OS Kernel 层之后，有每秒钟有 rrqm/s 个读 IO 操作被合并，最终转送给磁盘控制器的每秒钟读 IO 的个数为 r/w；在进入到操作系统的设备层(/dev/sda)之后，计数器开始对 IO 操作进行计时，最终的计算结果表现是 await，这个值就是我们要的IO 响应时间了；svctm 是在 IO 操作进入到磁盘控制器之后直到磁盘控制器返回结果所花费的时间，这是一个实际 IO 操作所花的时间，当 await 与 svctm 相差很大的时候，我们就要注意磁盘的 IO 性能了；而 avgrq-sz 是从 OS Kernel 往下传递请求时单个 IO 的大小，avgqu-sz 则是在 OS Kernel 中 IO 请求队列的平均大小。<br>    现在我们可以将 iostat 输出结果和我们上面讨论的指标挂钩了<br>设备 IO 操作:总 IO(io)/s = r/s(读) +w/s(写) =1.46 + 25.28=26.74<br>平均每次设备I/O操作只需要0.36毫秒完成,现在却需要10.57毫秒完成，因为发出的请求太多(每秒26.74个)，假如请求时同时发出的，可以这样计算平均等待时间:<br>平均等待时间=单个 I/O 服务器时间*(1+2+…+请求总数-1)/请求总数<br>每秒发出的 I/0 请求很多,但是平均队列就 4,表示这些请求比较均匀,大部分处理还是比较及时<br>svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。<br>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。<br><em><strong>*I/O*</strong></em> 系统 <em><strong>*vs.*</strong></em> 超市排队<br>举一个例子，我们在超市排队 checkout 时，怎么决定该去哪个交款台呢? 首当是看排的队人数，5 个人总比 20 人要快吧? 除了数人头，我们也常常看看前面人购买的东西多少，如果前面有个采购了一星期食品的大妈，那么可以考虑换个队排了。还有就是收银员的速度了，如果碰上了连钱都点不清楚的新手，那就有的<br>等了。另外，时机也很重要，可能 5 分钟前还人满为患的收款台，现在已是人去楼空，这时候交款可是很爽啊，当然，前提是那过去的 5 分钟里所做的事情比排队要有意义 (不过我还没发现什么事情比排队还无聊的)。<br>I/O 系统也和超市排队有很多类似之处:<br>r/s+w/s 类似于交款人的总数<br>平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数<br>平均服务时间(svctm)类似于收银员的收款速度<br>平均等待时间(await)类似于平均每人的等待时间<br>平均 I/O 数据(avgrq-sz)类似于平均每人所买的东西多少<br>I/O 操作率 (％util)类似于收款台前有人排队的时间比例。<br>我们可以根据这些数据分析出 I/O 请求的模式，以及 I/O 的速度和响应时间。 </p><p>一个例子 </p><p># iostat -x 1 </p><p>avg-cpu: ％user ％nice ％sys ％idle<br>16.24 0.00 4.31 79.44 </p><p>Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s rkB/s wkB/s avgrq-sz avgqu-sz await svctm ％util<br>/dev/cciss/c0d0<br>0.00 44.90 1.02 27.55 8.16 579.59 4.08 289.80 20.57 22.35 78.21 5.00 14.29<br>/dev/cciss/c0d0p1<br>0.00 44.90 1.02 27.55 8.16 579.59 4.08 289.80 20.57 22.35 78.21 5.00 14.29<br>/dev/cciss/c0d0p2<br>0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 </p><p>上面的 iostat 输出表明秒有 28.57 次设备 I/O 操作: delta(io)/s = r/s +w/s = 1.02+27.55 = 28.57 (次/秒) 其中写操作占了主体 (w:r = 27:1)。<br>平均每次设备 I/O 操作只需要 5ms 就可以完成，但每个 I/O 请求却需要等上 78ms，为什么? 因为发出的 I/O 请求太多 (每秒钟约 29 个)，假设这些请求是同时发出的，那么平均等待时间可以这样计算: 平均等待时间 = 单个 I/O 服务时间 * ( 1 + 2 + … + 请求总数-1) / 请求总数<br>应用到上面的例子: 平均等待时间 = 5ms * (1+2+…+28)/29 = 70ms，和 iostat 给出的 78ms 的平均等待时间很接近。这反过来表明 I/O 是同时发起的。每秒发出的 I/O 请求很多 (约 29 个)，平均队列却不长 (只有 2 个 左右)，这表明这 29 个请求的到来并不均匀，大部分时间 I/O 是空闲的。一秒中有 14.29％ 的时间 I/O 队列中是有请求的，也就是说，85.71％ 的时间里 I/O 系统无事可做，所有 29 个 I/O 请求都在 142 毫秒之内处理掉了。<br>delta(ruse+wuse)/delta(io) = await = 78.21 =&gt; delta(ruse+wuse)/s =78.21 * delta(io)/s = 78.21*28.57 = 2232.8，表明每秒内的 I/O 请求总共需要等待 2232.8ms。所以平均队列长度应为 2232.8ms/1000ms = 2.23，而 iostat<br>给出的平均队列长度 (avgqu-sz) 却为 22.35，为什么?! 因为 iostat 中有 bug，avgqu-sz 值应为 2.23，而不是 22.35。 </p><p><em><strong>*4*<em><strong>、</strong></em>*uptime*</strong></em> </p><p>uptime 命令用于查看服务器运行了多长时间以及有多少个用户登录，快速获知服务器的负荷情况。 uptime 的输出包含一项内容是 load average，显示了最近 1，5，15 分钟的负荷情况。它的值代表等待CPU 处理的进程数，如果 CPU 没有时间处理这些进程，load average 值会升高；反之则会降低。load average的最佳值是 1，说明每个进程都可以马上处理并且没有 CPU cycles 被丢失。对于单 CPU 的机器，1 或者2 是可以接受的值；对于多路 CPU 的机器，load average 值可能在 8 到 10 之间。也可以使用 uptime 命令来判断网络性能。例如，某个网络应用性能很低，通过运行 uptime 查看服务器的负荷是否很高，如果不是，那么问题应该是网络方面造成的。<br>以下是 uptime 的运行实例：<br>9:24am up 19:06, 1 user, load average: 0.00, 0.00, 0.00<br>也可以查看/proc/loadavg 和/proc/uptime 两个文件，注意不能编辑/proc 中的文件，要用 cat 等命令来查看，如：<br>liyawei:~ # cat /proc/loadavg<br>0.0 0.00 0.00 1/55 5505<br>uptime 命令用法十分简单：直接输入<br># uptime </p><p>例：<br>18:02:41 up 41 days, 23:42,  1 user,  load average: 0.00, 0.00, 0.00 </p><p>1 可以被认为是最优的负载值。负载是会随着系统不同改变得。单 CPU 系统 1-3 和 SMP 系统 6-10 都是可能接受的。<br>另外还有一个参数 -V ，是用来查询版本的。 (注意是大写的字母 v)<br>[linux @ localhost]$ uptime -V<br>procps version 3.2.7<br>[linux @ localhost]$ uptime </p><p>显示结果为：<br>10:19:04 up 257 days, 18:56,  12 users,  load average: 2.10, 2.10,2.09 </p><p>显示内容说明：<br>10:19:04               //系统当前时间<br>up 257 days, 18:56       //主机已运行时间,时间越大，说明你的机器越稳定。<br>12 user                //用户连接数，是总连接数而不是用户数<br>load average            // 系统平均负载，统计最近 1，5，15 分钟的系统平均负载<br>    那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。如果每个 CPU 内核的当前活动进程数不大于 3 的话，那么系统的性能是良好的。如果每个 CPU 内核的任务数大于 5，那么这台机器的性能有严重问题。如果你的 linux 主机是 1 个双核 CPU 的话，当 Load Average 为 6 的时候说明机器已经被充分使用了。 </p><p><em><strong>*5*<em><strong>、</strong></em>*W*</strong></em> </p><p> w 命令主要是查看当前登录的用户，这个命令相对来说比较简单。我们来看一下截图。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps13.jpg" alt="img"> </p><p>在上面这个截图里面呢，第一列 user，代表登录的用户，第二列，tty 代表用户登录的终端号，因为在linux 中并不是只有一个终端的，pts/2 代表是图形界面的第二个终端（这仅是个人意见，网上的对 pts的看法可能有些争议）。第三列 FROM 代表登录的地方，如果是远程登录的，会显示 ip 地址，:0 表示的是 display 0:0，意思就是主控制台的第一个虚拟终端。第四列 login@代表登录的时间，第五列的 IDLE代表系统的闲置时间。最后一列 what 是代表正在运行的进程，因为我正在运行 w 命令，所以咋 root显示 w。 </p><p><em><strong>*5*<em><strong>、</strong></em>*mpstat*</strong></em> </p><p> mpstat （RHEL5 默认不安装）<br>    mpstat 是 MultiProcessor Statistics 的缩写，是实时系统监控工具。其报告与 CPU 的一些统计信息，这些信息存放在/proc/stat 文件中。在多 CPUs 系统里，其不但能查看所有 CPU 的平均状况信息，而且能够查看特定 CPU 的信息。下面只介绍 mpstat 与 CPU 相关的参数，mpstat 的语法如下：<br>    mpstat [-P {|ALL}] [internal [count]]<br>    参数的含义如下：<br>    -P {|ALL} 表示监控哪个 CPU， cpu 在[0,cpu 个数-1]中取值<br>    internal 相邻的两次采样的间隔时间<br>    count 采样的次数，count 只能和 delay 一起使用<br>    当没有参数时，mpstat 则显示系统启动以后所有信息的平均值。有 interval 时，第一行的信息自系统启动以来的平均信息。<br> 从第二行开始，输出为前一个 interval 时间段的平均信息。与 CPU 有关的输出的含义如下：<br>[oracle@Test ~]$ mpstat -P ALL </p><p>Linux 2.6.18-194.el5 (Test.linux.com)  2010 年 06 月 22 日<br>09 时 18 分 18 秒 CPU  %user  %nice   %sys %iowait   %irq  %soft  %steal  %idle   intr/s 09 时 18 分 18 秒 all   0.06   0.00   0.43   0.78   0.00   0.00   0.00  98.71  1069.35 09 时 18 分 18 秒  0   0.05   0.00   0.36   0.17   0.02   0.00   0.00  99.41  1032.01 09 时 18 分 18 秒  1   0.04   0.00   0.42   0.07   0.00   0.00   0.00  99.47    0.26 09 时 18 分 18 秒  2   0.11   0.00   0.28   0.08   0.00   0.00   0.00  99.52    0.00 09 时 18 分 18 秒  3   0.07   0.00   0.48   0.05   0.00   0.00   0.00  99.39    0.01 09 时 18 分 18 秒  4   0.08   0.00   0.19   5.63   0.00   0.02   0.00  94.08   24.51 09 时 18 分 18 秒  5   0.05   0.00   0.63   0.11   0.00   0.00   0.00  99.21    0.22 09 时 18 分 18 秒  6   0.07   0.00   0.45   0.10   0.00   0.01   0.00  99.36   12.33 09 时 18 分 18 秒  7   0.05   0.00   0.64   0.07   0.00   0.00   0.00  99.24    0.00 参数 解释 从/proc/stat 获得数据 CPU 处理器 ID<br>user 在 internal 时间段里，用户的 CPU 时间（%） ，不包含 nice 值为负 进程 (usr/total)*100 nice 在 internal 时间段里，nice 值为负进程的 CPU 时间（%）  (nice/total)*100<br>system 在 internal 时间段里，核心时间（%）  (system/total)*100<br>iowait 在 internal 时间段里，硬盘 IO 等待时间（%） (iowait/total)*100<br>irq 在 internal 时间段里，硬中断时间（%）   (irq/total)*100<br>soft 在 internal 时间段里，软中断时间（%）  (softirq/total)*100<br>idle 在 internal 时间段里，CPU 除去等待磁盘 IO 操作外的因为任何原因而空闲的时间闲置时间（%）(idle/total)*100<br>intr/s 在 internal 时间段里，每秒 CPU 接收的中断的次数 intr/total)*100<br>CPU 总的工作时间=total_cur=user+system+nice+idle+iowait+irq+softirq<br>total_pre=pre_user+ pre_system+ pre_nice+ pre_idle+ pre_iowait+ pre_irq+ pre_softirq<br>user=user_cur – user_pre<br>total=total_cur-total_pre<br>其中_cur 表示当前值，_pre 表示 interval 时间前的值。上表中的所有值可取到两位小数点。<br>范例 1：average mode (粗略信息)当 mpstat 不带参数时，输出为从系统启动以来的平均值。<br>[work@builder linux-2.6.14]$ mpstat<br>Linux 2.6.9-5.31AXsmp (builder.redflag-linux.com) 12/16/2005<br>09:38:46 AM CPU %user %nice %system %iowait %irq %soft %idle intr/s<br>09:38:48 AM all 23.28 0.00 1.75   0.50 0.00 0.00 74.47 1018.59<br>范例 2: 每 2 秒产生了 2 个处理器的统计数据报告<br>下面的命令可以每 2 秒产生了 2 个处理器的统计数据报告，一共产生三个 interval 的信息，然后再给出这三个 interval 的平均信息。默认时，输出是按照 CPU 号排序。第一个行给出了从系统引导以来的所有活跃数据。接下来每行对应一个处理器的活跃状态。<br>[root@server yum_dir]# mpstat -P ALL 2 3<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>09:34:20 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 09:34:22 PM all   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00  1001.49 09:34:22 PM   0   0.00   0.00   0.50   0.00   0.00   0.00   0.00  99.50  1001.00 09:34:22 PM   1   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00    0.00 09:34:22 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 09:34:24 PM all   0.00   0.00   0.25   0.00   0.00   0.00   0.00  99.75  1005.00 09:34:24 PM   0   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00  1005.50 </p><p>09:34:24 PM   1   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00    0.00 09:34:24 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 09:34:26 PM all   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00  1001.49 09:34:26 PM   0   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00  1001.00 09:34:26 PM   1   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00    0.00 Average:   CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s Average:   all   0.00   0.00   0.08   0.00   0.00   0.00   0.00  99.92  1002.66 Average:    0   0.00   0.00   0.17   0.00   0.00   0.00   0.00  99.83  1002.49 Average:    1   0.00   0.00   0.00   0.00   0.00   0.00   0.00 100.00    0.00 </p><p>范例 3：比较带参数和不带参数的 mpstat 的结果。<br>在后台开一个 2G 的文件<br># cat 1.img &amp; </p><p>然后在另一个终端运行 mpstat 命令<br>[root@server ~]# cat 1.img &amp;<br>[1] 6934<br>[root@server ~]# mpstat<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>10:17:31 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 10:17:31 PM all   0.07   0.02   0.25   0.21   0.01   0.04   0.00  99.40  1004.57 [root@server ~]# mpstat<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>10:17:35 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 10:17:35 PM all   0.07   0.02   0.25   0.21   0.01   0.04   0.00  99.39  1004.73 [root@server ~]# mpstat<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>10:17:39 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 10:17:39 PM all   0.07   0.02   0.25   0.21   0.01   0.04   0.00  99.38  1004.96 [root@server ~]# mpstat<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>10:17:44 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 10:17:44 PM all   0.07   0.02   0.26   0.21   0.01   0.05   0.00  99.37  1005.20 [root@server ~]# mpstat 3 10<br>Linux 2.6.18-164.el5 (server.sys.com)   01/04/2010<br>10:17:55 PM CPU  %user  %nice   %sys %iowait   %irq  %soft %steal  %idle   intr/s 10:17:58 PM all  13.12   0.00  20.93   0.00   1.83   9.80   0.00  54.32  2488.08 10:18:01 PM all  10.82   0.00  19.30   0.83   1.83   9.32   0.00  57.90  2449.83 10:18:04 PM all  10.95   0.00  20.40   0.17   1.99   8.62   0.00  57.88  2384.05 10:18:07 PM all  10.47   0.00  18.11   0.00   1.50   8.47   0.00  61.46  2416.00 10:18:10 PM all  11.81   0.00  22.63   0.00   1.83  11.98   0.00  51.75  2210.60 10:18:13 PM all   6.31   0.00  10.80   0.00   1.00   5.32   0.00  76.58  1795.33 10:18:19 PM all   1.75   0.00   3.16   0.75   0.25   1.25   0.00  92.85  1245.18 10:18:22 PM all  11.94   0.00  19.07   0.00   1.99   8.29   0.00  58.71  2630.46 10:18:25 PM all  11.65   0.00  19.30   0.50   2.00   9.15   0.00  57.40  2673.91 10:18:28 PM all  11.44   0.00  21.06   0.33   1.99  10.61   0.00  54.56  2369.87 </p><p>Average:   all   9.27   0.00  16.18   0.30   1.50   7.64   0.00  65.11  2173.54 [root@server ~]# </p><p>上两表显示出当要正确反映系统的情况，需要正确使用命令的参数。vmstat 和 iostat 也需要注意这一问题。 </p><p><em><strong>*6*<em><strong>、</strong></em>*pmap*</strong></em> </p><p> pmap 命令可以显示进程的内存映射，使用这个命令可以找出造成内存瓶颈的原因。<br># pmap -d PID </p><p>显示 PID 为 47394 进程的内存信息。<br># pmap -d 47394 </p><p>输出样例：<br>47394:  /usr/bin/php-cgi<br>Address      Kbytes Mode Offset      Device   Mapping<br>0000000000400000   2584 r-x– 0000000000000000 008:00002 php-cgi<br>0000000000886000   140 rw— 0000000000286000 008:00002 php-cgi<br>00000000008a9000    52 rw— 00000000008a9000 000:00000  [ anon ]<br>0000000000aa8000    76 rw— 00000000002a8000 008:00002 php-cgi<br>000000000f678000   1980 rw— 000000000f678000 000:00000  [ anon ]<br>000000314a600000   112 r-x– 0000000000000000 008:00002 ld-2.5.so<br>000000314a81b000    4 r—- 000000000001b000 008:00002 ld-2.5.so<br>000000314a81c000    4 rw— 000000000001c000 008:00002 ld-2.5.so<br>000000314aa00000   1328 r-x– 0000000000000000 008:00002 libc-2.5.so<br>000000314ab4c000   2048 —– 000000000014c000 008:00002 libc-2.5.so<br>…..<br>……<br>00002af8d48fd000    4 rw— 0000000000006000 008:00002 xsl.so<br>00002af8d490c000    40 r-x– 0000000000000000 008:00002 libnss_files-2.5.so<br>00002af8d4916000   2044 —– 000000000000a000 008:00002 libnss_files-2.5.so<br>00002af8d4b15000    4 r—- 0000000000009000 008:00002 libnss_files-2.5.so<br>00002af8d4b16000    4 rw— 000000000000a000 008:00002 libnss_files-2.5.so<br>00002af8d4b17000 768000 rw-s- 0000000000000000 000:00009 zero (deleted)<br>00007fffc95fe000    84 rw— 00007ffffffea000 000:00000  [ stack ]<br>ffffffffff600000   8192 —– 0000000000000000 000:00000  [ anon ]<br>mapped: 933712K   writeable/private: 4304K   shared: 768000K </p><p>最后一行非常重要：<br>* mapped: 933712K 内存映射所占空间大小<br>* writeable/private: 4304K 私有地址空间大小<br>* shared: 768000K 共享地址空间大小 </p><p><em><strong>*7*<em><strong>、</strong></em>*sar*</strong></em> </p><p> sar 是一个优秀的一般性能监视工具，它可以输出 Linux 所完成的几乎所有工作的数据。sar 命令在sysetat rpm 中提供。示例中使用 sysstat 版本 5.0.5，这是稳定的最新版本之一。关于版本和下载信息，请访问 sysstat 主页 <a href="http://perso.wanadoo.fr/sebastien.godard/%E3%80%82">http://perso.wanadoo.fr/sebastien.godard/。</a><br>sar 可以显示 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、CPU 中断、网络等性能数据。最重要的 sar 功能是创建数据文件。每一个 Linux 系统都应该通过 cron 工作收集 sar 数据。该 sar 数据文件为</p><p>系统管理员提供历史性能信息。这个功能非常重要，它将 sar 和其他性能工具区分开。如果一个夜晚批处理工作正常运行两次，直到下一个早上才会发现这种情况（除非被叫醒）。我们需要具备研究 12 小时以前的性能数据的能力。sar 数据收集器提供了这种能力。<br> sar 命令行的常用格式：<br>     sar [options] [-A] [-o file] t [n] </p><p>​     在命令行中，n 和 t 两个参数组合起来定义采样间隔和次数，t 为采样间隔，是必须有的参数，n为采样次数，是可选的，默认值是 1，-o file 表示将命令结果以二进制格式存放在文件中，file 在此处不是关键字，是文件名。options 为命令行选项，sar 命令的选项很多，下面只列出常用选项：<br>​     </p><p> -A：所有报告的总和。<br> -u：CPU 利用率<br> -v：进程、I 节点、文件和锁表状态。<br> -d：硬盘使用报告。<br> -r：没有使用的内存页面和硬盘块。<br> -g：串口 I/O 的情况。<br> -b：缓冲区使用情况。<br> -a：文件读写情况。<br> -c：系统调用情况。<br> -R：进程的活动情况。<br> -y：终端设备活动情况。<br> -w：系统交换活动。 </p><p>****7.1*<em><strong>、</strong></em>*CPU****统计数据 </p><p> sar -u 输出显示 CPU 信息。-u 选项是 sar 的默认选项。该输出以百分比显示 CPU 的使用情况。表 3-2解释该输出。<br>表 3-2                            sar -u 字段 </p><table><thead><tr><th>字  段</th><th>说  明</th></tr></thead><tbody><tr><td>CPU</td><td>CPU 编号</td></tr><tr><td>%user</td><td>CPU 花费在用户进程（如应用程序、Shell 脚本或与该用户进行的交互）上的时间的百分比。</td></tr><tr><td>%nice</td><td>运行正常进程所花的时间</td></tr><tr><td>%system</td><td>在内核模式（系统）中运行进程所花的时间, 也就是CPU 用来执行核心任务的时间的百分比。</td></tr><tr><td>%iowait</td><td>没有进程在该 CPU 上执行时，处理器等待 I/O 完成的时间</td></tr><tr><td>%idle</td><td>没有进程在该 CPU 上执行的时间</td></tr></tbody></table><p>这些看起来应该比较熟悉，它和 top 报告中的 CPU 信息内容相同。以下显示输出格式：<br>[oracle@Test ~]$ sar -u -o aixi 60 5<br>Linux 2.6.18-194.el5 (Test.linux.com)  06/22/10<br>13:41:25      CPU   %user   %nice  %system  %iowait   %steal   %idle<br>13:42:25      all    0.28    0.00    0.21    1.17    0.00   98.34<br>13:43:25      all    0.23    0.00    0.16    1.14    0.00   98.46 </p><p>13:44:25      all    0.27    0.00    0.21    1.40    0.00   98.12 13:45:25      all    0.26    0.00    0.19    0.99    0.00   98.56 13:46:25      all    0.32    0.00    0.23    1.39    0.00   98.05 Average:      all    0.27    0.00    0.20    1.22    0.00   98.31 </p><p>​        每 60 秒采样一次，连续采样 5 次，观察 CPU 的使用情况，并将采样结果以二进制形式存入当前目录下的文件 aixi 中<br>​     </p><p>​         在所有的显示中，我们应主要注意%wio 和%idle，%wio 的值过高，表示硬盘存在 I/O 瓶颈，%idle值高，表示 CPU 较空闲，如果%idle 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。%idle 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。另外任何 sar 报告的第一列都是时间戳。<br>​         </p><p> 如果要查看二进制文件 aixi 中的内容，则需键入如下 sar 命令： </p><p> # sar -u -f aixi </p><p> 可见，sar 命令即可以实时采样，又可以对以往的采样结果进行查询。 </p><pre><code>我们本来可以研究使用-f 选项通过 sadc 创建的文件。这个 sar 语法显示 sar -f/var/log/ sa/sa21 的输出： </code></pre><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps14.jpg" alt="img"> </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps15.jpg" alt="img"> </p><p>在多 CPU Linux 系统中，sar 命令也可以为每个 CPU 分解该信息，如以下 sar -u -P ALL 5 5 输出所示： </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps16.jpg" alt="img"> </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps17.jpg" alt="img"> </p><table><thead><tr><th>磁盘****I/O****统计数据</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>sar 是一个研究磁盘 I/O 的优秀工具。以下是 sar 磁盘 I/O 输出的一个示例。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps18.jpg" alt="img"> </p><p>第一行-d 显示磁盘 I/O 信息，5 2 选项是间隔和迭代，就像 sar 数据收集器那样。表 3-3 列出了字段和说明。<br>表 3-3                            sar -d 字段 </p><table><thead><tr><th>字  段</th><th>说  明</th></tr></thead><tbody><tr><td>DEV</td><td>磁盘设备</td></tr><tr><td>tps</td><td>每秒传输数（或者每秒 IO 数）</td></tr><tr><td>rd_sec/s</td><td>每秒 512 字节读取数</td></tr><tr><td>wr_sec/s</td><td>每秒 512 字节写入数</td></tr></tbody></table><p>512 只是一个测量单位，不表示所有磁盘 I/O 均使用 512 字节块。DEV 列是 dev#-#格式的磁盘设备，其中第一个#是设备主编号，第二个#是次编号或者连续编号。对于大于 2.5 的内核，sar 使用次编号。例如，在 sar -d 输出中看到的 dev3-0 和 dev3-1。它们对应于/dev/hda 和/dev/hdal。请看/dev 中的以下各项： </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps19.jpg" alt="img"> </p><p>/dev/hda 有主编号 3 和次编号 0。hda1 有主编号 3 和次编号 1。<br><em><strong>*3.2.4*</strong></em>  网络统计数据<br>sar 提供四种不同的语法选项来显示网络信息。-n 选项使用四个不同的开关：DEV、EDEV、SOCK 和 FULL。DEV 显示网络接口信息，EDEV 显示关于网络错误的统计数据，SOCK 显示套接字信息，FULL 显示所有三个开关。它们可以单独或者一起使用。表 3-4 显示通过-n DEV 选项报告的字段。<br>表 3-4                          sar -n DEV 字段 </p><table><thead><tr><th>字  段</th><th>说  明</th></tr></thead><tbody><tr><td>IFACE</td><td>LAN 接口</td></tr></tbody></table><table><thead><tr><th>rxpck/s</th><th>每秒钟接收的数据包</th></tr></thead><tbody><tr><td>txpck/s</td><td>每秒钟发送的数据包</td></tr><tr><td>rxbyt/s</td><td>每秒钟接收的字节数</td></tr><tr><td>txbyt/s</td><td>每秒钟发送的字节数</td></tr><tr><td>rxcmp/s</td><td>每秒钟接收的压缩数据包</td></tr><tr><td>txcmp/s</td><td>每秒钟发送的压缩数据包</td></tr><tr><td>rxmcst/s</td><td>每秒钟接收的多播数据包</td></tr></tbody></table><p>以下是使用-n DEV 选项的 sar 输出： </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps20.jpg" alt="img"> </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps21.jpg" alt="img"> </p><p>关于网络错误的信息可以用 sar -n EDEV 显示。表 3-5 列出了显示的字段。 </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps22.jpg" alt="img"> </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps23.jpg" alt="img"> </p><p>表 3-5                         sar -n EDEV 字段 </p><table><thead><tr><th>字   段</th><th>说   明</th></tr></thead><tbody><tr><td>IFACE</td><td>LAN 接口</td></tr><tr><td>rxerr/s</td><td>每秒钟接收的坏数据包</td></tr><tr><td>txerr/s</td><td>每秒钟发送的坏数据包</td></tr><tr><td>coll/s</td><td>每秒冲突数</td></tr><tr><td>rxdrop/s</td><td>因为缓冲充满，每秒钟丢弃的已接收数据包数</td></tr><tr><td>txdrop/s</td><td>因为缓冲充满，每秒钟丢弃的已发送数据包数</td></tr><tr><td>txcarr/s</td><td>发送数据包时，每秒载波错误数</td></tr><tr><td>rxfram/s</td><td>每秒接收数据包的帧对齐错误数</td></tr><tr><td>rxfifo/s</td><td>接收的数据包每秒 FIFO 过速的错误数</td></tr><tr><td>txfifo/s</td><td>发送的数据包每秒 FIFO 过速的错误数</td></tr></tbody></table><p>SOCK 参数显示 IPCS 套接字信息。表 3-6 列出显示的字段及其意义。<br>表 3-6                         sar -n SOCK 字段 </p><table><thead><tr><th>字   段</th><th>说   明</th></tr></thead><tbody><tr><td>totsck</td><td>使用的套接字总数量</td></tr><tr><td>tcpsck</td><td>使用的 TCP 套接字数量</td></tr><tr><td>udpsck</td><td>使用的 UDP 套接字数量</td></tr><tr><td>rawsck</td><td>使用的 raw 套接字数量</td></tr><tr><td>ip-frag</td><td>使用的 IP 段数量</td></tr></tbody></table><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps24.jpg" alt="img"> </p><p>sar 可以产生许多其他报告。我们有必要仔细阅读 sar（1）手册页，查看是否有自己需要的其他报告 </p><p>例二：使用命行 sar -v t n </p><pre><code> 例如，每 30 秒采样一次，连续采样 5 次，观察核心表的状态，需键入如下命令：           # sar -v 30 5           屏幕显示：               SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001               10:33:23 proc-sz ov inod-sz ov file-sz ov lock-sz  (-v)   10:33:53 305/ 321  0 1337/2764  0 1561/1706 0 40/ 128   10:34:23 308/ 321  0 1340/2764  0 1587/1706 0 37/ 128   10:34:53 305/ 321  0 1332/2764  0 1565/1706 0 36/ 128   10:35:23 308/ 321  0 1338/2764  0 1592/1706 0 37/ 128   10:35:53 308/ 321  0 1335/2764  0 1591/1706 0 37/ 128           显示内容包括：           proc-sz：目前核心中正在使用或分配的进程表的表项数，由核心参数 MAX-PROC 控制。           inod-sz：目前核心中正在使用或分配的 i 节点表的表项数，由核心参数 MAX-INODE 控制。           file-sz： 目前核心中正在使用或分配的文件表的表项数，由核心参数 MAX-FILE 控制。           ov：溢出出现的次数。           Lock-sz：目前核心中正在使用或分配的记录加锁的表项数，由核心参数 MAX-FLCKRE 控制。           显示格式为           实际使用表项/可以使用的表项数           显示内容表示，核心使用完全正常，三个表没有出现溢出现象，核心参数不需调整，如果出现溢出时，要调整相应的核心参数，将对应的表项数加大。 </code></pre><p>​<br>​         例三：使用命行 sar -d t n<br>​<br>​         例如，每 30 秒采样一次，连续采样 5 次，报告设备使用情况，需键入如下命令：<br>​<br>​         # sar -d 30 5<br>​<br>​         屏幕显示：<br>​<br>​                             SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001<br>​         11:06:43 device %busy  avque  r+w/s  blks/s  avwait avserv (-d)       11:07:13 wd-0  1.47  2.75  4.67  14.73  5.50 3.14<br>​         11:07:43 wd-0  0.43  18.77  3.07  8.66  25.11 1.41<br>​         11:08:13 wd-0  0.77  2.78  2.77  7.26  4.94 2.77<br>​         11:08:43 wd-0  1.10  11.18  4.10  11.26  27.32 2.68<br>​         11:09:13 wd-0  1.97  21.78  5.86  34.06  69.66 3.35<br>​         Average wd-0  1.15  12.11  4.09  15.19  31.12 2.80<br>​<br>​         显示内容包括：<br>​<br>​                     device： sar 命令正在监视的块设备的名字。<br>​                         %busy： 设备忙时，传送请求所占时间的百分比。<br>​                         avque： 队列站满时，未完成请求数量的平均值。<br>​                         r+w/s： 每秒传送到设备或从设备传出的数据量。<br>​                         blks/s： 每秒传送的块数，每块 512 字节。<br>​                         avwait： 队列占满时传送请求等待队列空闲的平均时间。<br>​                         avserv： 完成传送请求所需平均时间（毫秒）。<br>​<br>​         在显示的内容中，wd-0 是硬盘的名字，%busy 的值比较小，说明用于处理传送请求的有效时间太少，文件系统效率不高，一般来讲，%busy 值高些，avque 值低些，文件系统的效率比较高，如果%busy 和avque 值相对比较高，说明硬盘传输速度太慢，需调整。<br>​<br>​         例四：使用命行 sar -b t n<br>​<br>​         例如，每 30 秒采样一次，连续采样 5 次，报告缓冲区的使用情况，需键入如下命令：<br>​<br>​         # sar -b 30 5<br>​<br>​         屏幕显示：<br>​<br>​                         SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001<br>​         14:54:59 bread/s lread/s %rcache bwrit/s lwrit/s %wcache pread/s pwrit/s (-b)       14:55:29 0  147  100  5  21  78  0  0<br>​         14:55:59 0  186  100  5  25  79  0  0  </p><p>​                 14:56:29 4  232  98  8  58  86  0  0<br>​                 14:56:59 0  125  100  5  23  76  0  0<br>​                 14:57:29 0  89  100  4  12  66  0  0<br>​                 Average  1  156  99  5  28  80  0  0<br>​<br>​                 显示内容包括：<br>​<br>​                 bread/s： 每秒从硬盘读入系统缓冲区 buffer 的物理块数。<br>​                 lread/s： 平均每秒从系统 buffer 读出的逻辑块数。<br>​                 %rcache： 在 buffer cache 中进行逻辑读的百分比。<br>​                 bwrit/s： 平均每秒从系统 buffer 向磁盘所写的物理块数。<br>​                 lwrit/s： 平均每秒写到系统 buffer 逻辑块数。<br>​                 %wcache： 在 buffer cache 中进行逻辑读的百分比。<br>​                 pread/s： 平均每秒请求物理读的次数。<br>​                 pwrit/s： 平均每秒请求物理写的次数。<br>​<br>​                 在显示的内容中，最重要的是%cache 和%wcache 两列，它们的值体现着 buffer 的使用效率，%rcache的值小于 90 或者%wcache 的值低于 65，应适当增加系统 buffer 的数量，buffer 数量由核心参数 NBUF控制，使%rcache 达到 90 左右，%wcache 达到 80 左右。但 buffer 参数值的多少影响 I/O 效率，增加buffer，应在较大内存的情况下，否则系统效率反而得不到提高。<br>​<br>​                 例五：使用命行 sar -g t n<br>​<br>​                 例如，每 30 秒采样一次，连续采样 5 次，报告串口 I/O 的操作情况，需键入如下命令：<br>​<br>​                 # sar -g 30 5<br>​<br>​                 屏幕显示：<br>​<br>​                 SCO_SV scosysv 3.2v5.0.5 i80386  11/22/2001<br>​                 17:07:03  ovsiohw/s  ovsiodma/s  ovclist/s (-g)<br>​                 17:07:33  0.00  0.00  0.00<br>​                 17:08:03  0.00  0.00  0.00<br>​                 17:08:33  0.00  0.00  0.00<br>​                 17:09:03  0.00  0.00  0.00<br>​                 17:09:33  0.00  0.00  0.00<br>​                 Average   0.00  0.00  0.00<br>​<br>​                 显示内容包括：<br>​<br>​                 ovsiohw/s：每秒在串口 I/O 硬件出现的溢出。<br>​<br>​                 ovsiodma/s：每秒在串口 I/O 的直接输入输出通道高速缓存出现的溢出。<br>​                                 </p><p>​     ovclist/s ：每秒字符队列出现的溢出。<br>​<br>​     在显示的内容中，每一列的值都是零，表明在采样时间内，系统中没有发生串口 I/O 溢出现象。<br>​<br>​     sar 命令的用法很多，有时判断一个问题，需要几个 sar 命令结合起来使用，比如，怀疑 CPU 存在瓶颈，可用 sar -u 和 sar -q 来看，怀疑 I/O 存在瓶颈，可用 sar -b、sar -u 和 sar-d 来看。      ——————————————————————————–      Sar<br>​     -A 所有的报告总和<br>​     -a 文件读，写报告<br>​     -B 报告附加的 buffer cache 使用情况<br>​     -b buffer cache 使用情况<br>​     -c 系统调用使用报告<br>​     -d 硬盘使用报告<br>​     -g 有关串口 I/O 情况<br>​     -h 关于 buffer 使用统计数字<br>​     -m IPC 消息和信号灯活动<br>​     -n 命名 cache<br>​     -p 调页活动<br>​     -q 运行队列和交换队列的平均长度<br>​     -R 报告进程的活动<br>​     -r 没有使用的内存页面和硬盘块<br>​     -u CPU 利用率<br>​     -v 进程，i 节点，文件和锁表状态<br>​     -w 系统交换活动<br>​     -y TTY 设备活动<br>​<br>​<br>​     -a 报告文件读，写报告<br>​             sar –a 5 5<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002<br>​     11:45:40 iget/s namei/s dirbk/s (-a)<br>​     11:45:45 6 2 2<br>​     11:45:50 91 20 28<br>​     11:45:55 159 20 18<br>​     11:46:00 157 21 19<br>​     11:46:05 177 30 35<br>​     Average 118 18 20<br>​<br>​     iget/s 每秒由 i 节点项定位的文件数量<br>​     namei/s 每秒文件系统路径查询的数量<br>​     dirbk/s 每秒所读目录块的数量<br>​             </p><p>​     ＊这些值越大，表明核心花在存取用户文件上的时间越多，它反映着一些程序和应用文件系统产生的负荷。一般地，如果 iget/s 与 namei/s 的比值大于 5，并且 namei/s 的值大于 30，则说明文件系统是低效的。这时需要检查文件系统的自由空间，看看是否自由空间过少。<br>​<br>​<br>​     -b 报告缓冲区（buffer cache）的使用情况<br>​                 sar -b 2 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002<br>​     13:51:28 bread/s lread/s %rcache bwrit/s lwrit/s %wcache pread/s pwrit/s (-b)      13:51:30 382 1380 72 131 273 52 0 0<br>​     13:51:32 378 516 27 6 22 72 0 0<br>​     13:51:34 172 323 47 39 57 32 0 0<br>​     Average 310 739 58 58 117 50 0 0<br>​<br>​     bread/s 平均每秒从硬盘（或其它块设备）读入系统 buffer 的物理块数<br>​     lread/s 平均每秒从系统 buffer 读出的逻辑块数<br>​     %rcache 在 buffer cache 中进行逻辑读的百分比（即 100％ - bread/lreads）<br>​     bwrit/s 平均每秒从系统 buffer 向磁盘（或其它块设备）所写的物理块数<br>​     lwrit/s 平均每秒写到系统 buffer 的逻辑块数<br>​     %wcache 在 buffer cache 中进行逻辑写的百分比（即 100％ - bwrit/lwrit）.<br>​     pread/sgu 平均每秒请求进行物理读的次数<br>​     pwrit/s 平均每秒请求进行物理写的次数<br>​<br>​     ＊所显示的内容反映了目前与系统 buffer 有关的读，写活。在所报告的数字中，最重要的是%rcache和%wcache（统称为 cache 命中率）两列，它们具体体现着系统 buffer 的效率。衡量 cache 效率的标准是它的命中率值的大小。<br>​     ＊如果%rcache 的值小于 90 或者%wcache 的值低于 65，可能就需要增加系统 buffer 的数量。如果在系统的应用中，系统的 I/O 活动十分频繁，并且在内存容量配置比较大时，可以增加 buffer cache，使%rcache 达到 95 左右，%wcache 达到 80 左右。<br>​     ＊系统 buffer cache 中，buffer 的数量由核心参数 NBUF 控制。它是一个要调的参数。系统中 buffer数量的多少是影响系统 I/O 效率的瓶颈。要增加系统 buffer 数量，则要求应该有较大的内存配置。否则一味增加 buffer 数量，势必减少用户进程在内存中的运行空间，这同样会导致系统效率下降。<br>​<br>​<br>​     -c 报告系统调用使用情况<br>​                 sar -c 2 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002<br>​     17:02:42 scall/s sread/s swrit/s fork/s exec/s rchar/s wchar/s (-c)<br>​     17:02:44 2262 169 141 0.00 0.00 131250 22159<br>​     17:02:46 1416 61 38 0.00 0.00 437279 6464<br>​     17:02:48 1825 43 25 0.00 0.00 109397 42331<br>​     Average 1834 91 68 0.00 0.00 225975 23651<br>​<br>​     scall/s 每秒使用系统调用的总数。一般地，当 4~6 个用户在系统上工作时，每秒大约 30 个左右。 </p><p>​     sread/s 每秒进行读操作的系统调用数量。<br>​     swrit/s 每秒进行写操作的系统调用数量。<br>​     fork/s 每秒 fork 系统调用次数。当 4~6 个用户在系统上工作时，每秒大约 0.5 秒左右。      exec/s 每秒 exec 系统调用次数。<br>​     rchar/s 每秒由读操作的系统调用传送的字符（以字节为单位）。<br>​     wchar/s 每秒由写操作的系统调用传送的字符（以字节为单位）。<br>​     ＊如果 scall/s 持续地大于 300，则表明正在系统中运行的可能是效率很低的应用程序。在比较典型的情况下，进行读操作的系统调用加上进行写操作的系统调用之和，约是 scall 的一半左右。<br>​<br>​<br>​     -d 报告硬盘使用情况<br>​                 sar -d 2 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/07/2002<br>​     17:27:49 device %busy avque r+w/s blks/s avwait avserv (-d)<br>​     17:27:51 ida-0 6.93 1.00 13.86 259.41 0.00 5.00<br>​     ida-1 0.99 1.00 17.33 290.10 0.00 0.57<br>​     17:27:53 ida-0 75.50 1.00 54.00 157.00 0.00 13.98<br>​     ida-1 9.50 1.00 12.00 75.00 0.00 7.92<br>​     17:27:55 ida-0 7.46 1.00 46.77 213.93 0.00 1.60<br>​     ida-1 17.41 1.00 57.71 494.53 0.00 3.02<br>​     Average ida-0 29.85 1.00 38.14 210.28 0.00 7.83<br>​     ida-1 9.29 1.00 29.02 286.90 0.00 3.20<br>​<br>​<br>​     device 这是 sar 命令正在监视的块设备的名字。<br>​     %busy 设备忙时，运行传送请求所占用的时间。这个值以百分比表示。<br>​     avque 在指定的时间周期内，没有完成的请求数量的平均值。仅在队列被占满时取这个值。      r+w/s 每秒传送到设备或者从设备传送出的数据量。<br>​     blks/s 每秒传送的块数。每块 512 个字节。<br>​     avwait 传送请求等待队列空闲的平均时间（以毫秒为单位）。仅在队列被占满时取这个值。      avserv 完成传送请求所需平均时间（以毫秒为单位）<br>​     ＊ida-0 和 ida-1 是硬盘的设备名字。在显示的内容中，如果%busy 的值比较小，说明用于处理传送请求的有效时间太少，文件系统的效率不高。要使文件系统的效率得到优化，应使%busy 的数值相对高一些，而 avque 的值应该低一些。<br>​<br>​<br>​     -g 报告有关串口 I/O 情况<br>​                 sar -g 3 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002<br>​     11:10:09 ovsiohw/s ovsiodma/s ovclist/s (-g)<br>​     11:10:12 0.00 0.00 0.00<br>​     11:10:15 0.00 0.00 0.00<br>​     11:10:18 0.00 0.00 0.00<br>​     Average 0.00 0.00 0.00 </p><p>​<br>​     ovsiohw/s 每秒在串囗 I/O 硬件出现的溢出。<br>​     ovsiodma/s 每秒在串囗 I/O 的直接输入，输出信道高速缓存出现的溢出。<br>​     ovclist/s 每秒字符队列出现的溢出。<br>​<br>​<br>​     -m 报告进程间的通信活动（IPC 消息和信号灯活动）情况<br>​                 sar -m 4 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002<br>​     13:24:28 msg/s sema/s (-m)<br>​     13:24:32 2.24 9.95<br>​     13:24:36 2.24 21.70<br>​     13:24:40 2.00 36.66<br>​     Average 2.16 22.76<br>​<br>​     msg/s 每秒消息操作的次数（包括发送消息的接收信息）。<br>​     sema/s 每秒信号灯操作次数。<br>​     ＊信号灯和消息作为进程间通信的工具，如果在系统中运行的应用过程中没有使用它们，那么由sar 命令报告的 msg 和 sema 的值都将等于 0.00。如果使用了这些工具，并且其中或者 msg/s 大于 100，或者 sema/s 大于 100，则表明这样的应用程序效率比较低。原因是在这样的应用程序中，大量的时间花费在进程之间的沟通上，而对保证进程本身有效的运行时间必然产生不良的影响。<br>​<br>​<br>​     -n 报告命名缓冲区活动情况<br>​                 sar -n 4 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002<br>​     13:37:31 c_hits cmisses (hit %) (-n)<br>​     13:37:35 1246 71 (94%)<br>​     13:37:39 1853 81 (95%)<br>​     13:37:43 969 56 (94%)<br>​     Average 1356 69 (95%)<br>​<br>​     c_hits cache 命中的数量。<br>​     cmisses cache 未命中的数量。<br>​     (hit %) 命中数量/(命中数理+未命中数量)。<br>​     ＊不难理解，(hit %)值越大越好，如果它低于 90％，则应该调整相应的核心参数。<br>​<br>​<br>​     -p 报告分页活动<br>​                 sar -p 5 3<br>​     SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002<br>​     13:45:26 vflt/s pflt/s pgfil/s rclm/s (-p)<br>​     13:45:31 36.25 50.20 0.00 0.00<br>​     13:45:36 32.14 58.48 0.00 0.00 </p><p>​         13:45:41 79.80 58.40 0.00 0.00<br>​         Average 49.37 55.69 0.00 0.00<br>​<br>​         vflt/s 每秒进行页面故障地址转换的数量（由于有效的页面当前不在内存中）。<br>​         pflt/s 每秒来自由于保护错误出现的页面故障数量（由于对页面的非法存，取引起的页面故障）。          pgfil/s 每秒通过”页—入”满足 vflt/s 的数量。<br>​         rclm/s 每秒由系统恢复的有效页面的数量。有效页面被增加到自由页面队列上。<br>​         ＊如果 vflt/s 的值高于 100，可能预示着对于页面系统来说，应用程序的效率不高，也可能分页参数需要调整，或者内存配置不太合适。<br>​<br>​<br>​         -q 报告进程队列（运行队列和交换队列的平均长度）情况<br>​                     sar -q 2 3<br>​         SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/13/2002<br>​         14:25:50 runq-sz %runocc swpq-sz %swpocc (-q)<br>​         14:25:52 4.0 50<br>​         14:25:54 9.0 100<br>​         14:25:56 9.0 100<br>​         Average 7.3 100<br>​<br>​         runq-sz 准备运行的进程运行队列。<br>​         %runocc 运行队列被占用的时间（百分比）<br>​         swpq-sz 要被换出的进程交换队列。<br>​         %swpocc 交换队列被占用的时间（百分比）。<br>​         ＊如果%runocc 大于 90，并且 runq-sz 的值大于 2，则表明 CPU 的负载较重。其直接后果，可能使系统的响应速度降低。如果%swpocc 大于 20，表明交换活动频繁，将严重导致系统效率下降。解决的办法是加大内存或减少缓存区数量，从而减少交换及页—入,页—出活动。<br>​<br>​<br>​         -r 报告内存及交换区使用情况（没有使用的内存页面和硬盘块）<br>​                     sar -r 2 3<br>​         SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002<br>​         10:14:19 freemem freeswp availrmem availsmem (-r)<br>​         10:14:22 279729 6673824 93160 1106876<br>​         10:14:24 279663 6673824 93160 1106876<br>​         10:14:26 279661 6673824 93160 1106873<br>​         Average 279684 6673824 93160 1106875<br>​<br>​         freemem 用户进程可以使用的内存页面数，4KB 为一个页面。<br>​         freeswp 用于进程交换可以使用的硬盘盘块，512B 为一个盘块。<br>​<br>​<br>​         -u CPU 利用率<br>​                     sar -u 2 3 </p><p>​         SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002<br>​         10:27:23 %usr %sys %wio %idle (-u)<br>​         10:27:25 2 3 8 88<br>​         10:27:27 3 3 5 89<br>​         10:27:29 0 0 0 100<br>​         Average 2 2 4 92<br>​         .<br>​         %usr cpu 处在用户模式下时间（百分比）<br>​         %sys cpu 处在系统模式下时间（百分比）<br>​         %wio cpu 等待输入，输出完成（时间百分比）<br>​         %idle cpu 空闲时间（百分比）<br>​         ＊在显示的内容中，%usr 和 %sys 这两个值一般情况下对系统无特别影响，%wio 的值不能太高，如果%wio 的值过高，则 CPU 花在等待输入，输出上的时间太多，这意味着硬盘存在 I/O 瓶颈。如果%idle的值比较高，但系统响应并不快，那么这有可能是 CPU 花时间等待分配内存引起的。%idle 的值可以较深入帮助人们了解系统的性能，在这种情况上，%idle 的值处于 40~100 之间，一旦它持续低于 30，则表明进程竟争的主要资源不是内存而是 CPU。<br>​         ＊在有大量用户运行的系统中，为了减少 CPU 的压力，应该使用智能多串卡，而不是非智能多串卡。智能多串卡可以承担 CPU 的某些负担。<br>​         ＊此外，如果系统中有大型的作业运行，应该把它们合理调度，错开高峰，当系统相对空闲时再运行。<br>​<br>​<br>​         -v 报告系统表的内容（进程，i 节点，文件和锁表状态）<br>​                 sar -v 2 3<br>​         SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002<br>​         10:56:46 proc-sz ov inod-sz ov file-sz ov lock-sz (-v)<br>​         10:56:48 449/ 500 0 994/4147 0 1313/2048 0 5/ 128<br>​         10:56:50 450/ 500 0 994/4147 0 1314/2048 0 5/ 128<br>​         10:56:52 450/ 500 0 994/4147 0 1314/2048 0 5/ 128<br>​<br>​         proc-sz 目前在核心中正在使用或分配的进程表的表项数<br>​         inod-sz 目前在核心中正在使用或分配的 i 节点表的表项数<br>​         file-sz 目前在核心中正在使用或分配的文件表的表项数<br>​         ov 溢出出现的次数<br>​         lock-sz 目前在核心中正在使用或分配的记录加锁的表项数<br>​         ＊除 ov 外，均涉及到 unix 的核心参数，它们分别受核心参数 NPROC,NIMODE,NFILE 和 FLOCKREC的控制。<br>​         ＊显示格式为：<br>​         实际使用表项/整个表可以使用的表项数<br>​         比如，proc-sz 一列所显示的四个数字中，分母的 100 是系统中整个进程表的长度（可建立 100 个表项），分子上的 24，26 和 25 分别是采样的那一段时间所使用的进程表项。inod-sz，file-sz 和 lock-sz三列数字的意义也相同。<br>​         三列 ov 的值分别对应进程表，i 节点表和文件表，表明目前这三个表都没有出现溢出现象，当出现溢出时，需要调整相应的核心参数，将对应表加大。 </p><p>​<br>​<br>​         -w 系统交换活动<br>​                 sar -w 2 3<br>​         SCO_SV scosvr 3.2v5.0.5 PentII(D)ISA 06/14/2002<br>​         11:22:05 swpin/s bswin/s swpot/s bswots pswch/s (-w)<br>​         11:22:07 0.00 0.0 0.00 0.0 330<br>​         11:22:09 0.00 0.0 0.00 0.0 892<br>​         11:22:11 0.00 0.0 0.00 0.0 1053<br>​         Average 0.00 0.0 0.00 0.0 757<br>​<br>​         swpin/s 每秒从硬盘交换区传送进入内存的次数。<br>​         bswin/s 每秒为换入而传送的块数。<br>​         swpot/s 每秒从内存传送到硬盘交换区的次数。<br>​         bswots 每秒为换出而传送的块数。<br>​         pswch/s 每秒进程交换的数量。<br>​         ＊swpin/s，bswin/s，swpot/s 和 bswots 描述的是与硬盘交换区相关的交换活动。交换关系到系统的效率。交换区在硬盘上对硬盘的读，写操作比内存读，写慢得多，因此，为了提高系统效率就应该设法减少交换。通常的作法就是加大内存，使交换区中进行的交换活动为零，或接近为零。如果 swpot/s的值大于 1，预示可能需要增加内存或减少缓冲区（减少缓冲区能够释放一部分自由内存空间）。<br>​                 </p><p>****8*<em><strong>、</strong></em>*proc****文件系统 </p><p> “proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过 proc 得到系统的信息，并可以改变内核的某些参数。”<br>这里将介绍如何从/proc 文件系统中获取与防火墙相关的一些性能参数，以及如何通过/proc 文件系统修改内核的相关配置。<br>1、从/proc 文件系统获取相关的性能参数<br>cpu 使用率：/proc/stat<br>内存使用情况：  /proc/meminfo<br>网络负载信息：/proc/net/dev<br>相应的计算方法：(摘自：什么是 proc 文件系统)<br>（1）  处理器使用率<br>（2）  内存使用率<br>（3）  流入流出数据包<br>（4）  整体网络负载<br>这些数据分别要从/proc/stat、/proc/net/dev、/proc/meminfo 三个文件中提取。如里有问题或对要提取的数据不太清楚，可以使用 man  proc 来查看 proc 文件系统的联机手册。<br>（1）  处理器使用率<br>这里要从/proc/stat 中提取四个数据：用户模式（user）、低优先级的用户模式（nice）、内核模式（system）以及空闲的处理器时间（idle）。它们均位于/proc/stat 文件的第一行。CPU 的利用率使用如下公式来计算。<br>CPU 利用率  =  100  *（user  +  nice  +  system）/（user  +  nice  +  system  + idle） </p><p>（2）  内存使用率<br>这里需要从/proc/meminfo 文件中提取两个数据，当前内存的使用量(cmem)以及内存总量(amem)。 内存使用百分比  =  100  *  (cmem  /  umem)<br>（3）网络利用率<br>为了得到网络利用率的相关数据，需要从/proc/net/dev 文件中获得两个数据：从本机输出的数据包数，流入本机的数据包数。它们都位于这个文件的第四行。<br>性能收集程序开始记录下这两个数据的初始值，以后每次获得这个值后均减去这个初始值即为从集群启动开始从本节点通过的数据包。<br>利用上述数据计算出网络的平均负载，方法如下：<br>平均网络负载  =  (输出的数据包+流入的数据包)  /  2<br>\2. 通过/proc 文件系统调整相关的内核配置<br>允许 ip 转发  /proc/sys/net/ipv4/ip_forward<br>禁止 ping/proc/sys/net/ipv4/icmp_echo_ignore_all<br>可以在命令行下直接往上述两个“文件”里头写入”1”来实现相关配置，如果写入”0”将取消相关配置。不过在系统重启以后，这些配置将恢复默认设置，所以，如果想让这些修改生效，可以把下面的配置直接写入/etc/profile 文件，或者其他随系统启动而执行的程序文件中。<br>1.echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br>2.echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<br>如果需要获取其他的性能参数，或者需要对内核进行更多的配置，可以参考 proc 文件系统介绍，也可以直接通过 man proc 查看相关的信息。 </p><p><em><strong>*十二、*</strong></em> <em><strong>*系统服务*</strong></em> </p><p>****1****、系统服务分类，根据其使用的方法来分，可以被分为三类 </p><p>a、由 init 控制的服务：基本都是系统级别的服务，运行级别这一章讲的就是这一类的服务<br>b、由 System V 启动脚本启动的服务：和我们打交道最多的一种服务，服务器基本都是这个类型的服务 c、由 xinetd 管理的服务 </p><p>****2*<em><strong>、</strong></em>*System V****启动脚本启动的服务 </p><table><thead><tr><th></th><th>/etc/rc.d/init.d/目录下的内容如下：这些常用的服务器都是 System v 的服务，要控制 System</th></tr></thead><tbody><tr><td>V 的服务，我们可以使用以下命令  #/etc/rc.d/init.d/script  {start|stop|restart|reload|condrestart|status}  stop：停止这个服务。  restart：先停止，再启动，也就是重新启动的意思。  reload：重新加载设定档，这个参数只有在服务已经启动的状况下才能使用。  condrestart：有条件的重新启动，这个服务必须是已经启动的，才会被重新启  动；如果这个服务尚未启动，则无须启动之。  status：察看目前服务的启动状态。  也可以使用 service 命令来执行脚本，例如 #service network  {start|stop|restart|reload|condrestart|status}</td><td></td></tr></tbody></table><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps25.jpg" alt="img"> </p><table><thead><tr><th>System V 的服务在不同级别下的默认开关可以不相同。我们还可以用两种方法来控制默认情况下，开机是否开启某些服务,使用 chkconfig 和 ntsysv（图形方式，默认只能定义当前级别，不过可以增加参数来实现如# ntsysv –level 23）来控制。</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>#chkconfig –list</td><td>//查看系统 system v 服务所有级别下的开关情况。</td><td></td><td></td></tr><tr><td>#chkconfig sshd on|off</td><td>//更改 sshd 服务 2-5 级别的默认开关情况</td><td></td><td></td></tr><tr><td>#chkconfig sendmail off</td><td></td><td></td><td>//所有级别关闭 sendmail 服务</td></tr><tr><td>#chkconfig –level 23 sendmail off</td><td>//在 2、3 级别关闭 sendmail 服务</td><td></td><td></td></tr></tbody></table><p>****3*<em><strong>、</strong></em>*xinetd****服务管理 </p><p>xinetd 服务的管理文件都放在 /etc/xinetd.d 目录内，我们可以编辑这个目录内的服务文件来开启和关闭服务。每个服务文件都有 disable 这个行，如果把值改成 yes 就是禁用服务，如果是 no，那就是启动这个服务。修改成功后，要使修改生效，需要从新启动 xinetd 服务。<br>#service xinetd restart </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps26.jpg" alt="img"> </p><p># vim chargen-dgram </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps27.jpg" alt="img"> </p><p>****4****、常见服务列表 </p><p> 服务名     必需（是/否）用途描述     注解<br>acon        否    语言支持     特别支持左手书写语言:阿拉伯语,波斯语和希伯莱语<br>acpi        否    电源管理     手提电脑电池电扇监控器<br>acpid       否    监听精灵进程     此进程监听并分配内核中的 acpi 事件 </p><p>adsl        否    内部 ADSL 开关控制     只有你的计算机内部有互联网连接 adsl开关时才用到此服务<br>alsa        否    高级 Linux 声音构件     这个单独的声音系统实际包含在内核中 anacron      否    周期命令调度程序     一个任务调度工具<br>apmd       否    电源管理     手提电脑电源管理<br>apmiser      否    电源管理     另一手提电脑电池延长器<br>arpwatch      否    以太网 IP 地址配对监控器     用主机名监控并记录远程 IP 地址 atd        否    周期命令调度程序     一个任务调度工具<br>autofs       否    自动安装服务     几个命令服务文件系统自动安装之一.一些此类服务专门针对发行配套软件,如果你使用的发行配套软件拥有自己的自动安装系统,不要用这一个. bluetooth     否    蓝牙技术核心     用于所有蓝牙服务<br>bootparamd     否     导入服务     以前导入无盘客户端/瘦客户端的方法.最新型的方法为零配置系统(zeroconf system).<br>canna       否     日语转换引擎<br>capi4linux     否     基本 CAPI 子系统<br>cpqarrayd     否     硬件服务     康柏独立冗余磁盘阵列(Raid Array)监控器 cpufreq      否     硬件服务     控查并配置 CPU 频率精灵程序模块<br>cpufreqd      否     硬件服务     此服务自动衡量 CPU 频率来减少过热情况.在超频时有用.<br>crond       是     周期命令调度程序     一个任务调度工具<br>Cups-lpd      否     使旧式Lunux或商业Unix系统连接到打印主机上.     只有在允许旧式系统访问打印机时才有用<br>cups        是     公共 Unix 打印系统     进行打印的必要功能<br>cvs        否     并发版本系统     用于管理多用户文档<br>devfsd       否     系统维护     此服务只清除动态桌面目录,除非你的系统经常崩溃,否则不需要此服务.<br>dhcpd       否     DHCP 服务器     你的网络足够大,使用静态 IP 很麻烦吗?此项服务对你的网络进行 DHCP IP 配置,方便网络应用.<br>diald       否     拨号网络智能自动拨号器     此服务一经请求,即连接上网络.你一旦输入电子邮件,点击发送,它就自动连接,发送电邮并断开.<br>dkms        否     DKMS 自安装导入     发行配套软件专用工具,用于 OEM 类型安装.它允许管理员密码的最初导入设置以及常规应用的用户名密码,系统的最后配置.<br>dm         是     显示管理器     X 服务器的核心,使用图形用户界面(GUI)时必需.<br>dnbc        否     数字网络绑定 Chrooter     这是一个简单的 bash 脚本,它将一个 BIND 服务器放入一个 chroot 牢笼中.安装 BIND,发布脚本并重启.<br>Drakxtools-http  否     小型服务管理服务器     远程系统管理的发行配套软件专用工具.<br>dund        否     蓝牙拨号网络<br>fam        否     文件系统变更监控器     文件系统所有改变的记录器<br>finger       否     数据远程访问     此服务允许你远程访问用户登录日期,最后登录日期与时间.用于不在办公室时监控雇员的工作习惯,主要的安全违反,因为你正有效地在线发布公司机密数据.<br>freshclam     是     ClamAV 更新器     用于自动更新 ClamAV </p><p>gpm        是     鼠标     鼠标驱动器控制台模式<br>haldaemon     否     硬件监控系统     此服务监控硬件改变,为你改变新的或更改过的硬件.<br>harddrake     否     硬件服务     发行配套软件专用硬件探测与配置<br>heartbeat     否     高可用性服务     此服务旨在增加重要服务与服务器的优先级 hidd        否     蓝牙 H.I.D.服务器<br>hplip       否     惠普 Linux 打印与成像     旧版惠普整成产品供应驱动器 hpoj        否     Pital?init,惠普办公喷墨打印机驱动器     惠普办公喷墨打印机旧式驱动器.新式驱动器包含在打印机的打印驱动器内.<br>httpd       否     Apache 网络服务器     在系统上应用此服务有两个原因,一是要用它作为网络服务器,二是用它作为网址开发器.如果没有此二项,则不必安装 Apache.<br>hylafax?server   否     企业传真机?调制调解器服务     此服务仅用于 1 类与 2 类传真机.如果你想用 hylafax 通过调制调解器发送传真,必须运行此服务.它并不是唯一有效的传真工具. ibod        否     按需 ISDN MPPP 带宽     与拨号网络一同使用,按需连接到网络. identd       否     TCP 连接鉴定<br>imaps       否     安全 IMAP 服务器<br>imaps       否     IMAP 服务器<br>iplog       否     用主机名或远程主机记录 TCP,UDP,ICMP.     有用的网络监控工具<br>ipop2       否     POP2 邮件服务器<br>ipop3       否     POP3 邮件服务器<br>ipsec       否     加密与验证通信     KLIPS 为内核一半,PLUTO 为用户空间一半.在远程访问情况下十分有用.<br>iptables      是     基于 Packet 过滤防火墙内核     所有优秀的 Linux 防火墙都基于此项服务<br>ipvsadmin     否     Linux 核心 IP 虚拟服务器     最早的 Linux 网络系统之一,已不常用.<br>irda        否     红外线设备界面     以前的无线设备支持<br>keytable      是     键盘映射     此服务明确告诉系统你正在使用哪种键盘 kheader      否     导入服务     此服务自动重建内核头导入<br>lads        否     登录异常探测系统     跟踪登录企图并警告入侵企图的工具 laptop mode    否     电源管理     减少电力耗费,延长手提电脑电池寿命的工具 leafnode      否     X? INETD NNTP 服务<br>lisa        否     局域网信息服务器<br>lmsensors     否     硬件健康监控器     此服务要求系统主板支持并有合适的监控系统,如 CPU 温度与电压监控器.<br>mailman      否     GUN 邮件列表管理器     常用的邮件列表工具,带 Python 编写的管理网络界面.它允许列表成员发送邮件并回复邮件到同一个地址进行交流. 它还可用于向那些发送请求的用户传送新闻时讯/产品更新.<br>mandi       否     交互式防火墙     允许暂时无线访问系统的专用服务,将为当前任务开放 iptables 防火墙,仅用于无线设备访问.在用户许可情况下才可使用,不能自动使用. mdadm       否     软阵列监控服务     这也是一个用于上述软件阵列栏的管理工具<br>mdnsresponder   否     零配置 DNS 配置工具 </p><p>messagebus     是     事件监控服务     此服务在必要时向所有用户发送广播信息,如服务器将要重启.<br>mon        是     系统监控精灵进程     许多系统服务要求此服务来运行 mysqld       否     MySQL 服务器     如果你不需要这个数据库,不要打开它. named       否     绑定(BIND)服务器     这就是声名狼藉的名称服务器<br>netplugd      否     网卡精灵进程     此服务监控网络界面,根据信号关闭或启动它,主要用于不经常连接的手提电脑.<br>network      是     网络     此服务打开网卡,或为调制调解器供电.<br>nfs        否     网络文件共享     此服务使用户访问 NFS 共享文件,为 NFS 系统客户机所必需.<br>nfsfs       否     网络文件共享服务器     只有在网络服务器上才被激活 nfslock      否     NFS 文件锁定     只有在使用 NFS 网络/文件共享功能时,此服务才被激活.<br>nifd        否     Howl 客户端     此服务为零配置网络/系统提供 ipv4 链接本地服务<br>nscd        否     密码与群查找服务     此服务用于减慢 N.I.S/Y.P.nist,ldap和 hesiod 之类的服务.专门为这些服务提供更长的中断时间.<br>ntpd        否     NTP 服务器的第 4 版<br>numlock      否     数字锁定键灯光控制     此服务保持数字锁定键的激活状态,打开键盘上的数字键区.<br>Oki4daemon     否     OKI4 和兼容 win 打印机的兼容性精灵进程     只有在你有这些打印机时才可用<br>pand        否     蓝牙个人区域网络     用于基于网络的家庭区域蓝牙技术 partmon      是     分区监控     此服务跟踪安装分区上的剩余空间.大多数文件系统浏览器使用它来计算指定分区上的剩余空间.<br>pcmcia       否     个人电脑内存卡国际协会<br>pg_autovacum    否     PostgreSQL 维护     此服务自动运行 PostgreSQL 所需的空间(vacuum)来减少磁盘空间,从数据库中拖动临时表格,并删除 PostgreSQL 建立的临时文件. pop3s       否     安全 POP3 服务     POP3 SSL 服务器<br>portmap      否     RPC 支持     支持那些应用 rpc 的罕有的应用软件<br>postgresql     否     Postgresql 数据库引擎     只有在运行或开发 Postgresql 数据库驱动应用软件时才用到此服务<br>postfix      否     电子邮件服务器     与 sendmail 兼容的电子邮件服务器,比sendmail 更新,也变得比 sendmail 更通用.<br>pptp        否     PPP 断电服务     PPP 频道断电服务,UPS 打开时使用,以避免电源返回系统时出现文件锁定问题.<br>prelude      否     IDS     入侵探测系统<br>psacct       否     进程计算     活动进程追踪器,实际上是资源的浪费.<br>rawdevices     是     分配 raw 设备,阻止其使用     DVDS,oracle DBMS 等需要此服务 rsync       否     远程同步     使指定目录树上的文件远程同步的服务器,常用于维护镜象地址,也在备份时用于保持公司文件为最新状态.<br>saned       否     网络扫描仪     从网络上的任何工作站提供扫描仪访问 shorwall      是     防火墙     一个非常优秀的 IPTables 防火墙 </p><p>smartd       否     自我监控服务     用于智能设备的 OS 访问,此服务允许 Linux告诉你是否设备将要变坏,但这要依靠设备的精确智能特性.<br>smb        否     Samba 网络服务     此服务提供 samba 服务,实现 Windows 网络兼容性.<br>snmpd       否     简单的网络管理协议     用于小型(家庭办公室)网络 sound       否     声音系统     此为 Linux 声音系统的核心,适用于桌面系统,在服务器上则是资源的浪费.<br>squid       否     高速缓存工具     用于高速缓存网络页面及 DNS 登录 ssh?xinetd     否     X?inetd OpenSSH 服务器     OpenSSH 的按需运行版本 sshd        否     OpenSSH 服务器     如果你需要 SSH 访问你的系统时才开启此服务,将不会使用 x?inetd 版本.<br>subversion     否     并发版本系统     CVS 的新型替代品<br>swat        否     Samba 网络管理工具     基于 Samba 管理的网络<br>syslog       是     系统登录     一项必要的服务,控制整个系统上的所有登录. tmdns       否     多点传送 DNS 响应器     用于零配置环境<br>ultrabayed     否     ThinkPad 工具     此服务为你的 IBM ThindPad 探测 ultrabay,并在适当情况下启动/关闭 IDE 接口.<br>upsd        否     NUT 精灵进程及驱动器     一个不间断地电源监控及报告工具,此服务向中心地址报告,产生关于 UPS 统计的数据库.<br>upsmon       否     UPS 监控工具     此服务监控 UPS 的状况,在其运行低下时关系系统.<br>vncserver     否     虚拟网络计算服务器     在项目中应用 VNC 时非常有用 Webmin       否     远程管理工具     发行配套软件 Agnostic 远程管理工具.在机器不能总是直接访问,如网络服务器集群时有用.<br>winbind      否     Samba 名称服务器     Samba 网络运行所必需.此服务将用户与群数据从 windows 网络映射到 Linux 工作站中.<br>wine        否     Wine 并非竞争者     此服务使 MS Windows 可在 Linux 上执行,WINE 是商业产品 Crossover Office 的限制版本.<br>wlan        否     控制精灵进程     由于服务通常由 init 进程控制,此控制服务不常用.<br>xinetd       是     监控并控制其它服务器的服务器    这是一项必需的服务,它实际上减少了服务器上 CPU 的负载.如果你需要 SSH,ftp 等但并不总是需要,x?inetd 版本将在请求,甚至是远程需求时启 动它们.此服务让它们生效,但如果它们一天/周只使用几次的话,又释放了时钟周期.<br>xfs        是     X 字体服务器     你任何时间需要使用图形用户界面(GUI),就需要此服务.<br>ypbind       否     SUN 的 YP 服务器名称服务器     此服务用于基于 GLIBC 的NIS/YP 网络服务 </p><p>**<br>**</p><p><em><strong>*十三、*</strong></em> <em><strong>*环境管理*</strong></em> </p><p>****1****、环境变量 </p><p>​    在 linux 系统下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“command not found”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉及到环境变量 PATH 的设置问题，而 PATH 的设置也是在 linux 下定制环境变量的一个组成部分。     环境变量可以让子程序继续引用的原因，是因为：<br>​    1. 当启动一个 shell ，操作系统分配一记忆区块给 shell 使用，此区域之变量可以让子程序存取；<br>​    2. 利用 export 功能，可以让变量的内容写到上述的记忆区块当中(环境变量)；<br>​    当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 3. 可以将父 shell 的环境变量所在的记忆区块导入自己的环境变量区块当中。<br>​    所以环境变量是和 Shell 紧密相关的，用户登录系统后就启动了一个 Shell。对于 Linux 来说一般是 bash，但也可以重新设定或切换到其它的 Shell（使用 chsh 命令）。<br>​    根据发行版本的情况，bash 有两个基本的系统级配置文件：/etc/bashrc 和/etc/profile。这些配置文件包含两组不同的变量：shell 变量和环境变量。前者只是在特定的 shell 中固定（如 bash），后者在不同 shell 中固定。很明显，shell 变量是局部的，而环境变量是全局的。环境变量是通过 Shell命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于 bash 这个 Shell程序来说，可以通过变量名来访问相应的环境变量，通过 export 来设置环境变量。 </p><p>注：Linux 的环境变量名称一般使用大写字母 </p><p>****1.1****、 ****Linux****环境变量的种类 </p><p>按环境变量的生存周期来划分，Linux 的环境变量可分为两类： </p><p>○1 永久的：需要修改配置文件，变量永久生效。 </p><p>○2 临时的：使用export命令行声明即可，变量在关闭shell时失效。 </p><p>****1.2****、设置变量的三种方法 </p><table><thead><tr><th></th><th>○1 在/etc/profile文件中添加变量对所有用户生效（永久的）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>​    用 VI 在文件/etc/profile 文件中增加变量，该变量将会对 Linux 下所有用户有效，并且是“永久生效”。<br>​    例如：编辑/etc/profile 文件，添加 CLASSPATH 变量<br>​    # vi /etc/profile<br>​        export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib </p><p>注 1：profile 文件在系统启动时将被运行。大家可以在里面加入其他命令，但是一定要加正确，不然的话系统会启动不起来的。 </p><p>○2 在用户目录下的.bash_profile文件中增加变量对单一用户生效（永久的） </p><p>​    用 VI 在用户目录下的.bash_profile 文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。<br>​    例如：编辑 guok 用户目录（/home/guok）下的.bash_profile<br>​    # vi /home/guok/.bash.profile </p><p>添加如下内容：<br>export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib </p><p>注 2：如果修改了/etc/profile，那么编辑结束后执行 source profile 或 执行点命令 ./profile,PATH的值就会立即生效了。这个方法的原理就是再执行一次/etc/profile shell 脚本，注意如果用 sh /etc/profile 是不行的，因为 sh 是在子 shell 进程中执行的，即使 PATH 改变了也不会反应到当前环境中，但是 source 是在当前 shell 进程中执行的，所以我们能看到 PATH 的改变。<br>注 3：变量重复定义时，以后面的设置为先。<br>         例如：在 peofile 文件默认对 PATH 变量都有设置 PATH=￥￥￥￥￥￥￥，在以后可能在对 PATH 设置，一般都加在 profile 文件的最后 PATH=······（打个比方）。而系统之中认定的<br>PATH=·······￥￥￥￥￥￥￥￥￥，也就是说相同名字的环境变量，后写入的先起作用（通俗地讲）。 注 4、特殊字符介绍。<br>         例如在 profile 中有如下内容，通过以下内容说明特殊符号的用法。<br>         export A=/q/jing:aaa/cc/ld<br>         export B=.:/liheng/wang export A=/cd/cdr:$A<br>         : 表示并列含义，例如 A 变量值有多个，用：符号进行分离。<br>         . 表示你操作的当前目录。例如 pap 命令会查找 B 环境变量。<br>在/home 键入 B 命令，系统首先在/home 目录下（即当前路径）查找关于 B 的内容，如果没有在/liheng/wang 目录下查找关于 B 的内容。 $ 表示该变量本次定义之前的值，例如$A 代表<br>/q/jing:aaa/cc/ld。也就是说 A=/cd/cdr:/q/jing:aaa/cc/ld<br>注 5、常见的环境变量 </p><p>​            PATH：决定了 shell 将到哪些目录中寻找命令或程序<br>​                 HOME：当前用户主目录<br>​         MAIL：是指当前用户的邮件存放目录。<br>​         SHELL：是指当前用户用的是哪种 Shell。<br>​     HISTSIZE：是指保存历史命令记录的条数。<br>​     LOGNAME：是指当前用户的登录名。<br>HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。      LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。   PS1：是基本提示符，对于 root 用户是#，对于普通用户是$。<br>​     PS2：是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符修改成字符串“Hello,My NewPrompt :) ”。<br>​     # PS1=” Hello,My NewPrompt :) “ </p><p>○3 直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】 </p><p>在 shell 的命令行下直接使用[export 变量名=变量值]定义变量，该变量只在当前的 shell（BASH）或其子 shell（BASH）下是有效的，shell 关闭了，变量也就失效了，再打开新 shell 时就没有这个变量，需要使用的话还需要重新定义。 </p><p>****1.3****、环境变量设置命令 </p><table><thead><tr><th>○1 echo $ &lt;变量名&gt;</th><th>//显示某个环境变量</th></tr></thead><tbody><tr><td>○2 env</td><td>// environment (环境) 的简写，列出来所有的环境变量</td></tr></tbody></table><table><thead><tr><th>○3 set</th><th>//显示所有本地定义的Shell变量，这个命令除了会将环境变量列出来之外，其它我们</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>的自定义的变量，都会被列出来。因此，想要观察目前 shell 环境下的所有变量，就用 set 即可！ </p><p>○4 export 命令 </p><p>功能说明：设置或显示环境变量。<br>语  法：export [-fnp][变量名称]=[变量设置值]<br>补充说明：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅及于该此登陆操作。<br>参  数：<br> -f  代表[变量名称]中为函数名称。<br> -n  删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。  -p  列出所有的 shell 赋予程序的环境变量。<br>一个变量创建时，它不会自动 地为在它之后创建的 shell 进程所知。而命令 export 可以向后面的 shell 传递变量的值。当一个 shell 脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export 命令可以用于传递一个或多个变量的值到任何后继脚本。 </p><p> ○5 unset清除环境变量，如果未指定值，则该变量值将被设为NULL </p><p> ○6 readonly设置只读变量，只读变量设置后不能用unset清除，除非重启shell </p><p> ○7 declare 、typeset 这两个命令是完全一样的，他们允许指定变量的具体类型，在某些特定的语言</p><p>中,<br>这是一种指定类型的很弱的形式，declare 命令是在 Bash 版本 2 或之后的版本才被加入的，typeset 命令也可以工作在 ksh 脚本中。<br>[root@linux ~]# declare [-aixr] variable<br>参数：<br>-a ：将后面的 variable 定义成为数组 (array)<br>-i ：将后面接的 variable 定义成为整数数字 (integer)<br>-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；<br>-r ：将一个 variable 的变量设定成为 readonly ，该变量不可被更改内容，也不能 unset 范例一：让变量 sum 进行 100+300+50 的加总结果<br>[root@linux ~]# sum=100+300+50<br>[root@linux ~]# echo $sum<br>100+300+50 &lt;==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！<br>[root@linux ~]# declare -i sum=100+300+50<br>[root@linux ~]# echo $sum<br>450<br>范例二：将 sum 变成环境变量<br>[root@linux ~]# declare -x sum<br>范例三：让 sum 变成只读属性，不可更动！<br>[root@linux ~]# declare -r sum<br>[root@linux ~]# sum=tesgting </p><p>-bash: sum: readonly variable </p><p><em><strong>*十四、*</strong></em> <em><strong>*网络管理*</strong></em> </p><p> 网卡在 Linux 操作系统中用 ethX,是由 0 开始的正整数，比如 eth0、eth1…… ethX。而普通猫和ADSL 的接口是 pppX，比如 ppp0 等 </p><p><em><strong>*7.1*<em><strong>、</strong></em>*ifconfig*</strong></em> </p><p>1、 关于网络接口及配置工具说明； </p><p>在 Linux 操作系统中配置网络接口，一般是通过网络配置工具实现的，但最终目的还是通过网络配</p><p>置工具来达到修改与网络相关的配置文件而起作用的。由此说来，我们配置网络可以直接修改配置文件。 </p><p>比如网络网络接口（网卡）的 IP 地址、子掩码、网关，在 Slackware 中只需修改一个配置文件就</p><p>行了 /etc/rc.d/rc.inet1 ，而在 Redhat/Fedora 等或以 Redhat/Fedora 为基础的发行版中，一般要</p><p>涉及到好几个文件，比如包括 /etc/sysconfig/network-scripts/ifcfg-eth0 在内等。 </p><p>了解 Linux 网络配置文件是极为重要的，我们通过工具修改了什么，是怎么生效的，只有了解网络</p><p>配置文件才能搞清楚。做个不恰当的比喻：Linux 系统是一个透明的盒子，至于盒子里装的是什么都是</p><p>一目了然的。而闭源操作系统，我们没有机会知道这些，更不知道他是怎么实现的。 </p><p>对于复杂的网络模型，Linux 操作系统是有极大的优势，可能在我们看看 man 和 help，修改修改</p><p>配置文件，在几分钟就可以搞定。但闭源图形界面的操作系统就没有这么幸运了，反复的点鼠标. </p><p>点了几十次上百次也解决不了一个问题，这是极为常见的。 由于 Linux 操作系统存在很多的发行</p><p>和版本，大多发行版本都有自己的专用配置工具。主要是为了方便用户配置网络；但也有通用的配置工</p><p>具，比如 Linux ifconfig 、ifup、ifdown； </p><p>2 关于网络硬件设备的驱动； </p><p>我在以前的文档中有写过，网络硬件，比如网卡（包括有线、无线），猫包括普通猫和 ADSL 猫等，</p><p>都是需要内核支持的，所以我们首先得知道自己的网络设备是不是已经被硬内核支持了。如果不支持，</p><p>我们得找驱动（或通过内核编译）来支持它； 请参考： </p><p>3、Linux ifconfig 配置网络接口的工具介绍； </p><p>Linux ifconfig 是一个用来查看、配置、启用或禁用网络接口的工具，这个工具极为常用的。比</p><p>如我们可以用这个工具来临时性的配置网卡的 IP 地址、掩码、广播地址、网关等。也可以把它写入一</p><p>个文件中（比如/etc/rc.d/rc.local)，这样系统引导后，会读取这个文件，为网卡设置 IP 地址； </p><p>不过这样做目前看来没有太大的必要。主要是各个发行版本都有自己的配置工具，无论如何也能把</p><p>主机加入到网络中； 下面我们看看 Linux ifconfig 用法； </p><p>3.1 Linux ifconfig 查看网络接口状态； </p><p>Linux ifconfig 如果不接任何参数，就会输出当前网络接口的情况； </p><p>\1. [root@localhost ~]# Linux ifconfig </p><p>\2. eth0    Link encap:Ethernet  HWaddr 00:C0:9F:94:78:0E </p><p>\3. inet addr:192.168.1.88  Bcast:192.168.1.255  Mask:255.255.255.0 </p><p>\4. inet6 addr: fe80::2c0:9fff:fe94:780e/64 Scope:Link </p><p>\5. UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1 </p><p>\6. RX packets:850 errors:0 dropped:0 overruns:0 frame:0 </p><p>\7. TX packets:628 errors:0 dropped:0 overruns:0 carrier:0 </p><p>\8. collisions:0 txqueuelen:1000 </p><p>\9. RX bytes:369135 (360.4 KiB)  TX bytes:75945 (74.1 KiB) </p><p>\10. Interrupt:10 Base address:0x3000 </p><p>\11. </p><p>\12. lo     Link encap:Local Loopback </p><p>\13. inet addr:127.0.0.1  Mask:255.0.0.0 </p><p>\14. inet6 addr: ::1/128 Scope:Host </p><p>\15. UP LOOPBACK RUNNING  MTU:16436  Metric:1 </p><p>\16. RX packets:57 errors:0 dropped:0 overruns:0 frame:0 </p><p>\17. TX packets:57 errors:0 dropped:0 overruns:0 carrier:0 </p><p>\18. collisions:0 txqueuelen:0 </p><p>\19. RX bytes:8121 (7.9 KiB)  TX bytes:8121 (7.9 KiB) </p><p>解说：eth0 表示第一块网卡， 其中 HWaddr 表示网卡的物理地址，我们可以看到目前这个网卡的</p><p>物理地址(MAC 地址）是 00:C0:9F:94:78:0E ； inet addr 用来表示网卡的 IP 地址，此网卡的 IP 地</p><p>址是 192.168.1.88， 广播地址， Bcast:192.168.1.255，掩码地址 Mask:255.255.255.0 </p><p>lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户</p><p>能够查看，只能在此台主机上运行和查看所用的网络接口。比如我们把 HTTPD 服务器的指定到回坏地址，</p><p>在浏览器输入 127.0.0.1 就能看到你所架 WEB 网站了。但只是您能看得到，局域网的其它主机或用户</p><p>无从知道； </p><p>如果我们想知道主机所有网络接口的情况，请用下面的命令； [root@localhost ~]# Linux </p><p>ifconfig -a 如果我们想查看某个端口，比如我们想查看 eth0 的状态，就可以用下面的方法；</p><p>[root@localhost ~]# Linux ifconfig eth0 </p><p>3.2 Linux ifconfig 配置网络接口； </p><p>Linux ifconfig 可以用来配置网络接口的 IP 地址、掩码、网关、物理地址等；值得一说的是用</p><p>Linux ifconfig 为网卡指定 IP 地址，这只是用来调试网络用的，并不会更改系统关于网卡的配置文件。 </p><p>如果您想把网络接口的 IP 地址固定下来，目前有三个方法：一是通过各个发行和版本专用的工具</p><p>来修改 IP 地址；二是直接修改网络接口的配置文件；三是修改特定的文件，加入 Linux ifconfig 指</p><p>令来指定网卡的 IP 地址，比如在 redhat 或 Fedora 中，把 Linux ifconfig 的语名写入</p><p>/etc/rc.d/rc.local 文件中； </p><p>Linux ifconfig 配置网络端口的方法： Linux ifconfig 工具配置网络接口的方法是通过指令的</p><p>参数来达到目的的，我们只说最常用的参数； Linux ifconfig  网络端口  IP 地址   hw <HW>  MAC</HW></p><p>地址  netmask  掩码地址   broadcast  广播地址  [up/down] </p><p>实例一： </p><p>比如我们用 Linux ifconfig 来调试 eth0 网卡的地址 </p><p>\1. [root@localhost ~]# Linux ifconfig  eth0 down </p><p>\2. [root@localhost ~]# Linux ifconfig  eth0  192.168.1.99 broadcast 192.168.1.255  netma</p><p>sk 255.255.255.0 </p><p>\3. [root@localhost ~]# Linux ifconfig eth0 up </p><p>\4. [root@localhost ~]# Linux ifconfig eth0 </p><p>\5. eth0    Link encap:Ethernet  HWaddr 00:11:00:00:11:11 </p><p>\6. inet addr:192.168.1.99  Bcast:192.168.1.255  Mask:255.255.255.0 </p><p>\7. UP BROADCAST MULTICAST  MTU:1500  Metric:1 </p><p>\8. RX packets:0 errors:0 dropped:0 overruns:0 frame:0 </p><p>\9. TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 </p><p>\10. collisions:0 txqueuelen:1000 </p><p>\11. RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b) </p><p>\12. Interrupt:11 Base address:0x3400 </p><p>注解： 上面的例子我们解说一下； </p><p>第一行：Linux ifconfig eth0 down 表示如果 eth0 是激活的，就把它 DOWN 掉。此命令等同于 ifdown </p><p>eth0； </p><p>第二行：用 Linux ifconfig 来配置 eth0 的 IP 地址、广播地址和网络掩码； </p><p>第三行：用 Linux ifconfig eth0 up 来激活 eth0 ； 此命令等同于 ifup eth0 </p><p>第四行：用 Linux ifconfig eth0 来查看 eth0 的状态； </p><p>当然您也可以用直接在指令 IP 地址、网络掩码、广播地址的同时，激活网卡；要加 up 参数；比如</p><p>下面的例子； [root@localhost ~]# Linux ifconfig  eth0  192.168.1.99 broadcast </p><p>192.168.1.255  netmask 255.255.255.0 up </p><p>实例二：在这个例子中，我们要学会设置网络 IP 地址的同时，学会设置网卡的物理地址（MAC 地</p><p>址）； </p><p>比如我们设置网卡 eth1 的 IP 地址、网络掩码、广播地址，物理地址并且激活它； [root@localhost </p><p>~]# Linux ifconfig eth1 192.168.1.252 hw ether  00:11:00:00:11:11  netmask 255.255.255.0 </p><p>broadcast 192.168.1.255  up 或[root@localhost ~]# Linux ifconfig eth1   hw </p><p>ether  00:11:00:00:11:22[root@localhost ~]# Linux ifconfig eth1 192.168.1.252  netmask </p><p>255.255.255.0 broadcast 192.168.1.255  up </p><p>其中 hw 后面所接的是网络接口类型， ether 表示乙太网， 同时也支持 ax25 、ARCnet、netrom</p><p>等，详情请查看 man Linux ifconfig ； </p><p>3.3 如何用 Linux ifconfig 来配置虚拟网络接口； </p><p>有时我们为了满足不同的需要还需要配置虚拟网络接口，比如我们用不同的 IP 地址来架运行多个</p><p>HTTPD 服务器，就要用到虚拟地址；这样就省却了同一个 IP 地址，如果开设两个的 HTTPD 服务器时，</p><p>要指定端口号。 </p><p>虚拟网络接口指的是为一个网络接口指定多个 IP 地址，虚拟接口是这样的 eth0:0 、 eth0:1、</p><p>eth0:2 … .. eth1N。当然您为 eth1 指定多个 IP 地址，也就是 eth1:0、eth1:1、eth1:2 … …</p><p>以此类推； </p><p>其实用 Linux ifconfig 为一个网卡配置多个 IP 地址，就用前面我们所说的 Linux ifconfig 的用</p><p>法，这个比较简单；看下面的例子； [root@localhost ~]# Linux ifconfig eth1:0 192.168.1.251 hw </p><p>ether  00:11:00:00:11:33  netmask 255.255.255.0 broadcast 192.168.1.255  up 或</p><p>[root@localhost ~]# Linux ifconfig eth1   hw ether  00:11:00:00:11:33[root@localhost ~]# </p><p>Linux ifconfig eth1 192.168.1.251  netmask 255.255.255.0 broadcast 192.168.1.255  up </p><p>注意：指定时，要为每个虚拟网卡指定不同的物理地址； </p><p>在 Redhat/Fedora 或与 Redhat/Fedora 类似的系统，您可以把配置网络 IP 地址、广播地址、掩码</p><p>地址、物理地址以及激活网络接口同时放在一个句子中，写入/etc/rc.d/rc.local 中。比如下面的例</p><p>子； </p><p>Linux ifconfig eth1:0 192.168.1.250 hw ether  00:11:00:00:11:44  netmask 255.255.255.0 </p><p>broadcast 192.168.1.255  up </p><p>Linux ifconfig eth1:1 192.168.1.249 hw ether  00:11:00:00:11:55  netmask 255.255.255.0 </p><p>broadcast 192.168.1.255  up </p><p>解说：上面是为 eth1 的网络接口，设置了两个虚拟接口；每个接口都有自己的物理地址、IP 地</p><p>址… … </p><p>3.4 如何用 Linux ifconfig 来激活和终止网络接口的连接； </p><p>激活和终止网络接口的用 Linux ifconfig 命令，后面接网络接口，然后加上 down 或 up 参数，</p><p>就可以禁止或激活相应的网络接口了。当然也可以用专用工具 ifup 和 ifdown 工具； </p><p>\1. [root@localhost ~]# Linux ifconfig eth0 down </p><p>\2. [root@localhost ~]# Linux ifconfig eth0 up </p><p>\3. [root@localhost ~]# ifup eth0 </p><p>\4. [root@localhost ~]# ifdown eth0 </p><p>对于激活其它类型的网络接口也是如此，比如 ppp0，wlan0 等；不过只是对指定 IP 的网卡有效。 </p><p>注意：对 DHCP 自动分配的 IP，还得由各个发行版自带的网络工具来激活；当然得安装 dhcp 客户端；</p><p>这个您我们应该明白；比如 Redhat/Fedora [root@localhost ~]#  /etc/init.d/network start </p><p>Slackware 发行版； [root@localhost ~]# /etc/rc.d/rc.inet1 </p><p>4、Debian、Slackware、Redhat/Fedora、SuSE 等发行版专用网络接口配置工具； </p><p>由于 Linux ifconfig 用起来比较麻烦，而且是用来测试网络之用，但这个工具并不能修改网络接</p><p>口的相应配置文件。虽然也能通过把 Linux ifconfig配置网络接口的语句写入类似/etc/rc.d/rc.local </p><p>文件中，但相对来说还是写入关于网络接口的配置文件中更为安全和可靠；但对于虚拟网络接口写入类</p><p>似/etc/rc.d/rc.local 中还是可以的； </p><p>下面我们介绍一下各个发行版的网络接口配置工具； </p><p>4.1 Debian 网络接口配置文件和专用配置工具； </p><p>正在增加中； </p><p>4.2 Redhat/Fedora 网络接口的配置文件和网络接口专用配置工具； </p><p>在 Redhat/Fedora 中，与乙太网卡相关的配置文件位于 /etc/sysconfig/network-scripts 目录中，</p><p>比如 ifcfg-eth0、ifcfg-eth1 …. …. </p><p>4.21 Redhat/Fedora 或类似这样的系统，网卡的配置文件； </p><p>&lt;/FONT?&lt; p&gt; </p><p>比如在 Fedora 5.0 中，ifcfg-eth0 ； 如果您用 DHCP 服务器来自动获取 IP 的，一般情况下</p><p>ifcfg-eth0 的内容是类似下面这样的； </p><p>\1. DEVICE=eth0 </p><p>\2. ONBOOT=yes </p><p>\3. BOOTPROTO=dhcp </p><p>\4. TYPE=Ethernet </p><p>如果您是指定 IP 的，一般内容是类似下面的； </p><p>\1. DEVICE=eth0 注：网络接口 </p><p>\2. ONBOOT=yes 注：开机引导时激活 </p><p>\3. BOOTPROTO=static 注：采用静态 IP 地址； </p><p>\4. IPADDR=192.168.1.238 注：IP 地址 </p><p>\5. NETMASK=255.255.255.0 注：网络掩码； </p><p>\6. GATEWAY=192.168.1.1 注：网关； </p><p>下面的几个选项也可以利用； </p><p>\1. HOSTNAME=linxsir03 注：指定主机名； </p><p>\2. DOMAIN=localdomain 注：指定域名； </p><p>\3. HWADDR=00:00:11:22:00:aa 注： </p><p>指定网卡硬件地址 (MAC 地址）， 也可以省略，不过这在这里来更改 MAC 地址一般是不能生效的。</p><p>还是通过前面所说的 Linux ifconfig 的办法来更改吧； </p><p>4.22 Redhat/Fedora 或类似系统， 配置网络的工具介绍 ； </p><p>在 Redhat 早期的版本中， 有 linuxconf 、redhat-config-network 、netconfig 等工具； 在</p><p>Redhat/Fedora 最新的版本有 system-config-network-tui （文本模式的) 、system-config-network </p><p>（图形模式的），netconfig（文本模式的）。 </p><p>这些工具都会直接修改 Linux 系统中关于网络接口的配置文件；这是 Linux ifconfig 所不能比的； </p><p>其中 redhat-config-network 和 system-config-network 工具不仅仅是配置网卡的工具，还有配置</p><p>ISDN 和普通猫、ADSL 的工具、网络硬件的添加、主机名字的配置、DNS 各客户端的配置等。其实是一</p><p>个工具组的集成； </p><p>这些工具比较简单，以 root 权限运行命令就能调用，比如： </p><p>\1. [root@localhost ~]# /usr/sbin/system-config-network </p><p>\2. [root@localhost ~]# system-config-network </p><p>如果您设置了可执行命令的环境变量，不用加路径就可以运行，但前提是您得安装这个网络管理工</p><p>具； 不过值得一说的是 netconfig 工具是一个在文本模式比较好的工具，推荐大家使用；理由是这个</p><p>工具在文本模式下，也有一个简单的图形界面；还有命令模式；功能强着呢； </p><p>\1. [root@localhost ~]#  netconfig -d eth0  注：配置 eth0 </p><p>\2. [root@localhost ~]#  netconfig -d eth1  注：配置 eth1 </p><p>4.23 Redhat/Fedora 系统中的 netconfig 特别介绍； </p><p>netconfig 这个工具，在 Redhat/Fedora 或类似于它们的系统中都是存在的，这个工具比较强大。</p><p>所以特别介绍一下。但在 Slackware 中 netconfig 是 TEXT 模式下有一个图形模式，但不能象 Linux </p><p>ifconfig 一样用命令来操作网卡接口； </p><p>netconfig 的用法如下： </p><p>\1. [root@localhost ~]# netconfig –help  注：帮助； </p><p>\2.  –bootproto=(dhcp|bootp|none)   Boot protocol to use（ </p><p>\3.  –gateway=STRING    Network gateway（指定网关） </p><p>\4.  –ip=STRING  IP address（指定 IP 地址） </p><p>\5.  –nameserver=STRING   Nameserver（指定 DNS 客户端） </p><p>\6.  –netmask=STRING    Netmask（指定网络掩码） </p><p>\7.  –hostname=STRING    Hostname（ 指定主机名） </p><p>\8.  –domain=STRING     Domain name（指定域名） </p><p>\9.  -d, –device=STRING   Network device （指定网络设备） </p><p>\10.  –nodns    No DNS lookups （没有 DNS 查询） </p><p>\11.  –hwaddr=STRING     Ethernet hardware address （指定网卡的物理地址） </p><p>\12.  –description=STRING  Description of the device （描述性文字） </p><p>\13. Help options: (帮助选项） </p><p>\14.  -?, –help   Show this help message </p><p>\15.  –usage    Display brief usage message </p><p>实例一：设置网卡的 DHCP 模式自动获得 IP [root@localhost ~]# netconfig -d eth0 </p><p>–bootproto=dhcp </p><p>实例一：手动设置网卡的 IP 等 [root@localhost ~]# netconfig -d eth0 –ip=192.168.1.33 </p><p>–netmask=255.255.255.0  –gateway=192.168.1.1 </p><p>4.3 Slackware 网卡配置文件和配置工具； </p><p>Slackware 有关网卡的配置文件是/etc/rc.d/rc.inet1.conf ， 这个文件包括乙太网接口的网卡</p><p>和无线网卡的配置。Slackware 还是比较纯净的，网络配置也较简单；在 Slackware 中也有 netconfig </p><p>配置工具，也是 text 模式运行的，人机交互界面，这个设置比较简单； </p><p>Slackware 用 netconfig 配置网卡完成后，其实质是修改了/etc/rc.d/rc.inet1.conf 文件。</p><p>Slackware 是源法原味的 Linux 系统，他的配置文件比较标准 ，所以我推荐您在生产型的系统，不妨</p><p>尝试一下 Slackware ； </p><p>配置好网卡后，我们还得运行下面的命令，才能激活网卡； [root@localhost ~]# </p><p>/etc/rc.d/rc.inet1 下面是一个例子，比如此机器有两个网卡 eth0 和 eth1，eth0 用 DHCP 获得 IP 地</p><p>址，eth1 指定 IP 地址； </p><ol><li><h1 id="Config-information-for-eth0"><a href="#Config-information-for-eth0" class="headerlink" title="Config information for eth0:"></a>Config information for eth0:</h1></li></ol><p>\2. IPADDR[0]=”” </p><p>\3. NETMASK[0]=”” </p><p>\4. USE_DHCP[0]=”yes” 注：在这里写上 yes，表示用 DHCP 获得 IP； </p><p>\5. DHCP_HOSTNAME[0]=”linuxsir01” 注：DNS 服务器主机名，也可以用 IP 来指定 DNS 服务器； </p><p>\6. # Config information for eth1: 注：网卡 eth1 的配置； </p><p>\7. IPADDR[1]=”192.168.1.33” 注：指定 IP 地址； </p><p>\8. NETMASK[1]=”255.255.255.0” 注：指定掩码； </p><p>\9. USE_DHCP[1]=”no”  注：不用 DHCP 获得 IP； </p><p>\10. DHCP_HOSTNAME[1]=”” </p><p>\11. # Config information for eth2: </p><p>\12. IPADDR[2]=”” </p><p>\13. NETMASK[2]=”” </p><p>\14. USE_DHCP[2]=”” </p><p>\15. DHCP_HOSTNAME[2]=”” </p><p>\16. # Config information for eth3: </p><p>\17. IPADDR[3]=”” </p><p>\18. NETMASK[3]=”” </p><p>\19. USE_DHCP[3]=”” </p><p>\20. DHCP_HOSTNAME[3]=”” </p><p>\21. # Default gateway IP address: </p><p>\22. GATEWAY=”192.168.1.1” 注：指定网关； </p><p>4.4 SuSE 或 OpenSuSE 网卡配置文件和配置工具； </p><p>正在更新之中； </p><p>5、关于拔号工具的介绍； </p><p>有的弟兄可能需要 ADSL 猫和普通猫的拔号工具；现在我们分别介绍一下； </p><p>5.1 ADSL pppoe 拔号工具 rp-pppoe； </p><p>如果您的 ADSL 不是路由的，如果是路由的，在路由路就能设置好自动拔号。只要把机器接上就能</p><p>用了，这个咱们不说了，路由器大家都会用；但如果您的 ADSL 不支持路由，或您想用您当前所用的主</p><p>机来做路由器；这就需要一个拔号软件； </p><p>目前国内大多城市都用的是 pppoe 协议 ，所以我们有必要介绍 pppoe 拔号软件，在 Linux 中，这</p><p>个软件的名字是 rp-pppoe ； rp-pppoe 主页； </p><p><a href="http://www.roaringpenguin.com/penguin/open_source_rp-pppoe.php">http://www.roaringpenguin.com/penguin/open_source_rp-pppoe.php</a> </p><p>5.11 各大发行版自带的 rp-pppoe 的安装和使用； </p><p>rp-pppoe 目前在各大发行版本都是存在的，比如 Redhat/Fedora、红旗、Slackware、Debian、SuSE</p><p>等系统，都是采用这个拔号软件，所以您大可不必为下载源码编译安装。只需要在各大发行版的安装盘</p><p>中就可以找得到；请用各大发行版自带的软件包管理工具来安装此软件包； </p><p>如果您用的是各大发行版提供的 rp-pppoe 软件包 比如 RPM 包的系统是用 rpm -ivh </p><p>rp-pppoe*.rpmSlackware 系统是用 installpkg rp-pppoe*.tgz 在 Redhat/Fedora 中可以通过图形配</p><p>置工具来完成，redhat-config-network 命令，调用配置网络，要通过 XDSL 来添加拔号，比较简单； </p><p>所有发行版通用的方法是 adsl-setup 命令来配置 ADSL； </p><p>\1. [root@localhost ~]# adsl-setup  注：配置 pppoe 拔号，请文档下面，都差不多； </p><p>\2. [root@localhost ~]# adsl-start  注：启动拔号； </p><p>\3. [root@localhost ~]# adsl-stop  注：断开连接； </p><p>5.12 如果是源码包安装，我们要自己来编译安装； </p><p>[root@localhost ~]# tar zxvf  rp-pppoe-3.8.tar.gz </p><p>[root@localhost ~]# cd rp-pppoe-3.8 </p><p>[root@localhost rp-pppoe-3.8]# ./go </p><p>Welcome to the Roaring Penguin PPPoE client setup.  First, I will run </p><p>some checks on your system to make sure the PPPoE client is installed </p><p>properly… </p><p>Looks good!  Now, please enter some information: </p><p>USER NAME </p><p>&gt;&gt;&gt; Enter your PPPoE user name (default ): 在这里添写你的拔号用户</p><p>名；就是服务商提供的； </p><p>&gt;&gt;&gt; Enter the Ethernet interface connected to the DSL modem </p><p>For Solaris, this is likely to be something like /dev/hme0. </p><p>For Linux, it will be ethn, where ‘n’ is a number. </p><p>(default eth0): eth0 如果是乙太接口的 ADSL，就要在这里写上接猫的那个网络接口号。此处是</p><p>eth0； </p><p>Do you want the link to come up on demand, or stay up continuously? </p><p>If you want it to come up on demand, enter the idle time in seconds </p><p>after which the link should be dropped.  If you want the link to </p><p>stay up permanently, enter ‘no’ (two letters, lower-case.) </p><p>NOTE: Demand-activated links do not interact well with dynamic IP </p><p>addresses.  You may have some problems with demand-activated links. </p><p>&gt;&gt;&gt; Enter the demand value (default no): 注：默认回车 </p><p>&gt;&gt;&gt; Enter the DNS information here: 202.96.134.133  注：在这里写上 DNS 服务器地址；可以</p><p>和提供商要，也可以用我写的这个； </p><p>Please enter the IP address of your ISP’s secondary DNS server. </p><p>If you just press enter, I will assume there is only one DNS server. </p><p>&gt;&gt;&gt; Enter the secondary DNS server address here: 202.96.128.143 这是第二个 DNS 服务器地</p><p>址； </p><p>&gt;&gt;&gt; Please enter your PPPoE password:在这里输入用户的密码； </p><p>&gt;&gt;&gt; Please re-enter your PPPoE password: 确认密码； </p><p>The firewall choices are: </p><p>0 - NONE: This script will not set any firewall rules.  You are responsible </p><p>for ensuring the security of your machine.  You are STRONGLY </p><p>recommended to use some kind of firewall rules. </p><p>1 - STANDALONE: Appropriate for a basic stand-alone web-surfing workstation </p><p>2 - MASQUERADE: Appropriate for a machine acting as an Internet gateway </p><p>for a LAN </p><p>&gt;&gt;&gt; Choose a type of firewall (0-2): 2 注：在这里写上 2，可以共享上网的；当然还得加一</p><p>条防火墙规划 ； </p><p>Ethernet Interface: eth0 </p><p>User name:dxxx </p><p>Activate-on-demand: No </p><p>Primary DNS:     202.96.134.133 </p><p>Secondary DNS:    202.96.128.143 </p><p>Firewalling:     MASQUERADE </p><p>&gt;&gt;&gt; Accept these settings and adjust configuration files (y/n)? y 注：是不是保存配置； </p><p>关于共享上网，请参考：《ADSL 共享上网的解决办法》 </p><p>5.2 普通猫的拔号工具介绍； </p><p>普通猫分为串口和 PCI 的，请查看 《关于网络设备概述 》 普通猫的拔号工具主要有 kppp 和 wvdial；</p><p>在 Redhat/Fedora 中，用 system-config-network 或 redhat-config-network 也能设置 ppp 拔号； 在</p><p>KDE 桌面环境下，大家一般都用 kppp 拔号工具，点鼠标就可以完成； </p><p>wvdial 工具是文本的，几乎在各大发行版都有。wvdial 的配置文件是/etc/wvdial.conf 。如果您</p><p>的猫已经驱动好了，运行一下 wvdialconf 命令就生成了/etc/wvdial.conf 了 。当然您得查看一下它</p><p>的内容； </p><p>\1. [root@localhost ~]# wvdialconf </p><p>\2. [root@localhost ~]# more /etc/wvdial.conf </p><p>关于 wvdial 工具的使用，请查看《普通 56K 猫拔号上网工具 wvdial 介绍》 </p><p>6、无线网卡； </p><p>正在更新之中；由于我没有这样的网卡，是否有弟兄写一篇详尽一点的？在所有涉及无线网卡的文</p><p>档中，这块都是空白。缺的就是这个。 看来我是得弄一块无线网卡了。。。。。。 </p><p>7、DNS 客户端配置文件/etc/resolv.conf； </p><p>本来不应该把 DNS 客户端配置文件放在这里来说，但由于新手弟兄上网时，虽然能拔号，但不能以</p><p>域名访问。究其原因是由于没有修改 /etc/resolv.conf 文件； </p><p>/etc/resolv.conf 里面存放的是各大通信公司 DNS 服务器列表；下面的三个地址可以用一用；当</p><p>然您可以打电话问你的服务商； </p><p>\1. nameserver 202.96.134.133 </p><p>\2. nameserver 202.96.128.143 </p><p>\3. nameserver 202.96.68.38 </p><p>本文写了常用的乙太网接口的配置，介绍了 Linux ifconfig 、netconfig 等，我感觉最重要的还</p><p>是配置文件，新手弟兄还是仔细看看配置文件吧。当您用工具配置完成后，不妨查看一下相应配置文件</p><p>的变化。我认为这样的学习方式，能知其然，然后知所以然； </p><p>**<br>**</p><p><em><strong>*7.10*<em><strong>、</strong></em>*tcpdump*</strong></em> </p><p>tcpdump 是一个用于截取网络分组，并输出分组内容的工具。tcpdump 凭借强大的功能和灵活的截</p><p>取策略，使其成为类 UNIX 系统下用于网络分析和问题排查的首选工具。 </p><p>tcpdump 提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常</p><p>有用的工具。tcpdump 存在于基本的 Linux 系统中，由于它需要将网络界面设置为混杂模式，普通用户</p><p>不能正常执行，但具备 root 权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分</p><p>析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。 </p><p>7.1.1 概述 </p><p>顾名思义，tcpdump 可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、</p><p>协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句来帮助你去掉无用的信息。 </p><p>引用 </p><p># tcpdump -vv </p><p>tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes </p><p>11:53:21.444591 IP (tos 0x10, ttl  64, id 19324, offset 0, flags [DF], proto 6, length: 9</p><p>\2) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 3962132600:3962132652(52) ack 272652</p><p>5936 win 1266 </p><p>asptest.localdomain.1077 &gt; 192.168.228.153.domain: [bad udp cksum 166e!]  325+ PTR? 244.2</p><p>28.168.192.in-addr.arpa. (46) </p><p>11:53:21.446929 IP (tos 0x0, ttl  64, id 42911, offset 0, flags [DF], proto 17, length: 1</p><p>\51) 192.168.228.153.domain &gt; asptest.localdomain.1077:  325 NXDomain q: PTR? 244.228.168.</p><p>192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123) </p><p>11:53:21.447408 IP (tos 0x10, ttl  64, id 19328, offset 0, flags [DF], proto 6, length: 1</p><p>\72) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 168:300(132) ack 1 win 1266 </p><p>347 packets captured </p><p>1474 packets received by filter </p><p>745 packets dropped by kernel </p><p>不带参数的 tcpdump 会收集网络中所有的信息包头，数据量巨大，必须过滤。 </p><p>7.1.2、命令介绍 </p><p>命令格式为：tcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae] </p><p> [-qX] [-r 文件] [所欲捕获的数据内容] </p><p>参数： </p><p>-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。 </p><p>-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。 </p><p>-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。 </p><p>-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听， </p><p> 直到用户输入 [ctrl]-c 为止。 </p><p>-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。 </p><p>-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。 </p><p>-q，仅列出较为简短的数据包信息，每一行的内容比较精简。 </p><p>-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。 </p><p>-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，并且这个「文件」是由 </p><p>-w 所制作出来的。所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包</p><p>捕获。 </p><p> 那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。 </p><p> ‘host foo’, ‘host 127.0.0.1’ ：针对单台主机来进行数据包捕获。 </p><p> ‘net 192.168’ ：针对某个网段来进行数据包的捕获。 </p><p> ‘src host 127.0.0.1’ ‘dst net 192.168’：同时加上来源(src)或目标(dst)限制。 </p><p> ‘tcp port 21’：还可以针对通信协议检测，如 tcp、udp、arp、ether 等。 </p><p> 除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less, </p><p>greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是’and’,’&amp;&amp;’;或运算 是’o </p><p>r’ ,’||’； </p><p>范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒 </p><p>[root@linux ~]# tcpdump -i eth0 -nn </p><p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode </p><p>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes </p><p>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 116:232(116) ack 1 win </p><p>9648 </p><p>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 232:364(132) ack 1 win </p><p>9648 </p><p>&lt;==按下 [ctrl]-c 之后结束 </p><p>6680 packets captured        &lt;==捉取下来的数据包数量 </p><p>14250 packets received by filter  &lt;==由过滤所得的总数据包数量 </p><p>7512 packets dropped by kernel   &lt;==被核心所丢弃的数据包 </p><p>至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来</p><p>说明一下： </p><p>· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。 </p><p>· IP：通过的通信协议是 IP。 </p><p>· 192.168.1.100.22&gt;：传送端是 192.168.1.100 这个 IP，而传送的 Port Number 为 22，那个大于（&gt;）</p><p>的符号指的是数据包的传输方向。 </p><p>· 192.168.1.11.1190：接收端的 IP 是 192.168.1.11，且该主机开启 port 1190 来接收。 </p><p>· P 116:232(116)：这个数据包带有 PUSH 的数据传输标志，且传输的数据为整体数据的 116~232 Byt</p><p>e，所以这个数据包带有 116 Bytes 的数据量。 </p><p>· ack 1 win 9648：ACK 与 Window size 的相关资料。 </p><p>最简单的说法，就是该数据包是由 192.168.1.100 传到 192.168.1.11，通过的 port 是由 22 到 1190，</p><p>且带有 116 Bytes 的数据量，使用的是 PUSH 的标记，而不是 SYN 之类的主动联机标志。 </p><p>接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用 tcpdu</p><p>mp 配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过 tcpdump 的表达式功能，</p><p>就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对 eth0 做监听，所以整</p><p>个 eth0 接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出 port 21</p><p>的联机数据包，可以这样做： </p><p>[root@linux ~]# tcpdump -i eth0 -nn port 21 </p><p>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode </p><p>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes </p><p>01:54:37.96 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 1 win 65535 </p><p>01:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.11.1240:P 1:21(20) ack 1 win 5840 </p><p>01:54:38.12 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 21 win 65515 </p><p>01:54:42.79 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:P 1:17(16) ack 21 win 65515 </p><p>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: . ack 17 win 5840 </p><p>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 21:55(34) ack 17 win 5840 </p><p>看！这样就仅取出 port 21 的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client 端</p><p>发出请求而 Server 端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向</p><p>来了解到数据包运动的过程了。例如： </p><p>· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。 </p><p>· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？ </p><p>[root@linux ~]# tcpdump -i lo -nn </p><p> 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode </p><p> 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes </p><p> 3 11:02:54.253777 IP 127.0.0.1.32936 &gt; </p><p>127.0.0.1.22: S 933696132:933696132(0) </p><p> win 32767  </p><p> 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: </p><p>S 920046702:920046702(0) </p><p> ack 933696133 win 32767  </p><p> 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192 </p><p> 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: </p><p>P 1:23(22) ack 1 win 8192 </p><p> 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192 </p><p>代码显示的头两行是 tcpdump 的基本说明，然后： </p><p>· 第 3 行显示的是来自 Client 端带有 SYN 主动联机的数据包。 </p><p>· 第 4 行显示的是来自 Server 端，除了响应 Client 端之外（ACK），还带有 SYN 主动联机的标志。 </p><p>· 第 5 行则显示 Client 端响应 Server 确定联机建立（ACK）。 </p><p>· 第 6 行以后则开始进入数据传输的步骤。 </p><p>从第 3~5 行的流程来看，熟不熟悉啊？没错。那就是 3 次握手的基础流程，有趣吧。不过 tcpdump 之所</p><p>以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与</p><p>传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要</p><p>修订的地方。 </p><p>还有更神奇的用法。当我们使用 tcpdump 在 Router 上面监听明文的传输数据时，例如 FTP 传输协议，</p><p>你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以 FTP</p><p>登录本机，并输入账号与密码，结果你就可以发现如下的状况： </p><p>[root@linux ~]# tcpdump -i lo -nn -X ‘port 21’ </p><p> 0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@……. </p><p> 0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  ………U!I..% </p><p> 0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  …..&lt;………g </p><p> 0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  …a220.(vsFTPd. </p><p> 0x0040:  322e 302e 3129 0d0a            2.0.1).. </p><p> 0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY…. </p><p> 0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  ……….%.U!] </p><p> 0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  …..5………7 </p><p> 0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  …gUSER.dmtsai. </p><p> 0x0040:  0a                    . </p><p> 0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL…. </p><p> 0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  ……….2.U!. </p><p> 0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  …..&gt;……..2’ </p><p> 0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  …8PASS.mypassw </p><p> 0x0040:  6f72 6469 7379 6f75 0d0a         ordisyou..  </p><p>上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结</p><p>果的特殊字体中，我们可以发现该 FTP 软件使用的是 vsFTPd，并且用户输入 dmtsai 这个账号名称，且</p><p>密码是 mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？ </p><p>另外你得了解，为了让网络接口可以让 tcpdump 监听，所以执行 tcpdump 时网络接口会启动在“混杂模</p><p>式（promiscuous）”，所以你会在 /var/log/messages 里面看到很多的警告信息，通知你说你的网卡被</p><p>设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考 man tcpdump 了。 </p><p>例题：如何使用 tcpdump 监听来自 eth0 适配卡且通信协议为 port 22，目标来源为 192.168.1.100 的</p><p>数据包资料？ </p><p>答：tcpdump -i eth0 -nn port 22 and src host 192.168.1.100 </p><p>例题：如何使用 tcpdump 抓取访问 eth0 适配卡且访问端口为 tcp 9080？ </p><p>答:tcpdump -i eth0 dst 172.168.70.35 and tcp port 9080 </p><p>例题：如何使用 tcpdump 抓取与主机 192.168.43.23 或着与主机 192.168.43.24 通信报文，并且显示在</p><p>控制台上 </p><p>答：tcpdump -X -s 1024 -i eth0 host (192.168.43.23 or 192.168.43.24) and  host 172.16.7</p><p>0.35 </p><p>注：必须指定网卡 </p><p>7.1.3、tcpdump 的表达式介绍 </p><p>表达式是一个正则表达式，tcpdump 利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，</p><p>则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。 </p><p>在表达式中一般如下几种类型的关键字： </p><p>引用 </p><p>第一种是关于类型的关键字，主要包括 host，net，port，例如 host 210.27.48.2， 指明 210.27.48.</p><p>2 是一台主机，net 202.0.0.0 指明 202.0.0.0 是一个网络地址，port 23 指明端口号是 23。如果没有</p><p>指定类型，缺省的类型是 host。 </p><p>第二种是确定传输方向的关键字，主要包括 src，dst，dst or src，dst and src， 这些关键字指明</p><p>了传输的方向。举例说明，src 210.27.48.2 ，指明 ip 包中源地址是 210.27.48.2 ， dst net 202.</p><p>0.0.0 指明目的网络地址是 202.0.0.0。如果没有指明 方向关键字，则缺省是 src or dst 关键字。 </p><p>第三种是协议的关键字，主要包括 fddi，ip，arp，rarp，tcp，udp 等类型。Fddi 指明是在 FDDI (分</p><p>布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi 和 ether 具有类似</p><p>的源地址和目的地址，所以可以将 fddi 协议包当作 ether 的包进行处理和分析。 其他的几个关键字就</p><p>是指明了监听的包的协议内容。如果没有指定任何协议，则 tcpdump 将会 监听所有协议的信息包。 </p><p>除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， </p><p>还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘， 与运算是’and’，’&amp;&amp;’;或运算是’or’ ，’|</p><p>|’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。 </p><p>四、输出结果介绍 </p><p>下面我们介绍几种典型的 tcpdump 命令的输出信息 </p><p>(1) 数据链路层头信息 </p><p>使用命令： </p><p>#tcpdump –e host ICE </p><p>ICE 是一台装有 linux 的主机。它的 MAC 地址是 0：90：27：58：AF：1A H219 是一台装有 Solaris 的</p><p>SUN 工作站。它的 MAC 地址是 8：0：20：79：5B：46； 上一条命令的输出结果如下所示： </p><p>引用 </p><p>21:50:12.847509 eth0 &lt; 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 &gt; ICE.  telne t</p><p> 0:0(0) ack 22535 win 8760 (DF) </p><p>21：50：12 是显示的时间， 847509 是 ID 号，eth0 &lt;表示从网络接口 eth0 接收该分组， eth0 &gt;表示</p><p>从网络接口设备发送分组， 8:0:20:79:5b:46 是主机 H219 的 MAC 地址， 它表明是从源地址 H219 发来</p><p>的分组. 0:90:27:58:af:1a 是主机 ICE 的 MAC 地址， 表示该分组的目的地址是 ICE。 ip 是表明该分</p><p>组是 IP 分组，60 是分组的长度， h219.33357 &gt; ICE. telnet 表明该分组是从主机 H219 的 33357 端</p><p>口发往主机 ICE 的 TELNET(23)端口。 ack 22535 表明对序列号是 222535 的包进行响应。 win 8760</p><p>表明发 送窗口的大小是 8760。 </p><p>(2) ARP 包的 tcpdump 输出信息 </p><p>使用命令： </p><p>#tcpdump arp </p><p>得到的输出结果是： </p><p>引用 </p><p>22:32:42.802509 eth0 &gt; arp who-has route tell ICE (0:90:27:58:af:1a) </p><p>22:32:42.802902 eth0 &lt; arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a) </p><p>22:32:42 是时间戳， 802509 是 ID 号， eth0 &gt;表明从主机发出该分组，arp 表明是 ARP 请求包， who</p><p>-has route tell ICE 表明是主机 ICE 请求主机 route 的 MAC 地址。 0:90:27:58:af:1a 是主机 ICE 的</p><p>MAC 地址。 </p><p>(3) TCP 包的输出信息 </p><p>用 tcpdump 捕获的 TCP 包的一般输出信息是： </p><p>引用 </p><p>src &gt; dst: flags data-seqno ack window urgent options </p><p>src &gt; dst:表明从源地址到目的地址， flags 是 TCP 报文中的标志信息，S 是 SYN 标志， F (FIN)， </p><p>P (PUSH) ， R (RST) “.” (没有标记); data-seqno 是报文中的数据 的顺序号， ack 是下次期望的顺</p><p>序号， window 是接收缓存的窗口大小， urgent 表明 报文中是否有紧急指针。 Options 是选项。 </p><p>(4) UDP 包的输出信息 </p><p>用 tcpdump 捕获的 UDP 包的一般输出信息是： </p><p>引用 </p><p>route.port1 &gt; ICE.port2: udp lenth </p><p>UDP 十分简单，上面的输出行表明从主机 route 的 port1 端口发出的一个 UDP 报文 到主机 ICE 的 port</p><p>2 端口，类型是 UDP， 包的长度是 lenth。 </p><p>五、举例 </p><p>(1) 想要截获所有 210.27.48.1 的主机收到的和发出的所有的分组： </p><p>#tcpdump host 210.27.48.1 </p><p>(2) 想要截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信，使用命令（注意：括号</p><p>前的反斜杠是必须的）： </p><p>#tcpdump host 210.27.48.1 and (210.27.48.2 or 210.27.48.3 ) </p><p>(3) 如果想要获取主机 210.27.48.1 除了和主机 210.27.48.2 之外所有主机通信的 ip 包，使用命令： </p><p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2 </p><p>(4) 如果想要获取主机 192.168.228.246 接收或发出的 ssh 包，并且不转换主机名使用如下命令： </p><p>#tcpdump -nn -n src host 192.168.228.246 and port 22 and tcp </p><p>(5) 获取主机 192.168.228.246 接收或发出的 ssh 包，并把 mac 地址也一同显示： </p><p># tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn </p><p>(6) 过滤的是源主机为 192.168.0.1 与目的网络为 192.168.0.0 的报头： </p><p>tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24 </p><p>(7) 过滤源主机物理地址为 XXX 的报头： </p><p>tcpdump ether src 00:50:04:BA:9B and dst…… </p><p>（为什么 ether src 后面没有 host 或者 net？物理地址当然不可能有网络喽）。 </p><p>(8) 过滤源主机 192.168.0.1 和目的端口不是 telnet 的报头，并导入到 tes.t.txt 文件中： </p><p>Tcpdump src host 192.168.0.1 and dst port not telnet -l &gt; test.txt </p><p>ip icmp arp rarp 和 tcp、udp、icmp 这些选项等都要放到第一个参数的位置，用来过滤数据报的类</p><p>型。 </p><p><em><strong>*十五、*</strong></em> <em><strong>*配置文件*</strong></em> </p><p>****1****、 配置文件介绍： </p><p>每个 Linux 程序都是一个可执行文件，它含有操作码列表，CPU 将执行这些操作码来完成特定的操作。例如，ls 命令是由 /bin/ls 文件提供的，该文件含有机器指令的列表，在屏幕上显示当前目录中文件的列表时需要使用这些机器指令。几乎每个程序的行为都可以通过修改其配置文件来按照您的偏好或需要去定制。<br>Linux 中有没有一个标准的配置文件格式？<br>一句话，没有。不熟悉 Linux 的用户（一定）会感到沮丧，因为每个配置文件看起来都象是一个要迎接的新挑战。在 Linux 中，每个程序员都可以自由选择他或她喜欢的配置文件格式。可以选择的格式很多，从 /etc/shells 文件（它包含被一个换行符分开的 shell 的列表），到 Apache 的复杂的<br>/etc/httpd.conf 文件。<br>什么是系统配置文件？<br>内核本身也可以看成是一个“程序”。为什么内核需要配置文件？内核需要了解系统中用户和组的列表，进而管理文件权限（即根据权限判定特定用户（UNIX_USERS）是否可以打开某个文件）。注意，这些文件不是明确地由程序读取的，而是由系统库所提供的一个函数读取，并被内核使用。例如，程序需要某个用户的（加密过的）密码时不应该打开 /etc/passwd 文件。相反，程序应该调用系统库的 getpw() 函数。这种函数也被称为系统调用。打开 /etc/passwd 文件和之后查找那个被请求的用户的密码都是由内核（通过系统库）决定的。<br>除非另行指定，Red Hat Linux 系统中大多数配置文件都在 /etc 目录中。配置文件可以大致分为下面几类： </p><p>****2****、配置文件分类： </p><p>访问文件 </p><table><thead><tr><th>/etc/host.conf</th><th>告诉网络域名服务器如何查找主机名。（通常是 /etc/hosts，然后就是名称服务器；可通过 netconf 对其进行更改）</th></tr></thead><tbody><tr><td>/etc/hosts</td><td>包含（本地网络中）已知主机的一个列表。如果系统的 IP 不是动态生成，就可以使用它。对于简单的主机名解析（点分表示法），在请求 DNS 或 NIS 网络名称服务器之前， /etc/hosts.conf 通常会告诉解析程序先查看这里。</td></tr><tr><td>/etc/hosts.allow</td><td>请参阅 hosts_access 的联机帮助页。至少由 tcpd 读取。</td></tr><tr><td>/etc/hosts.deny</td><td>请参阅 hosts_access 的联机帮助页。至少由 tcpd 读取。</td></tr></tbody></table><p>引导和登录／注销 </p><table><thead><tr><th>/etc/issue &amp;  /etc/issue.net</th><th>这些文件由 mingetty（和类似的程序）读取，用来向从终端（issue）或通过 telnet 会话（issue.net）连接的用户显示一个“welcome”字符串。它们包括几行声明 Red Hat 版本号、名称和内核 ID 的信息。它们由</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>rc.local 使用。</th></tr></thead><tbody><tr><td>/etc/redhat-release</td><td>包括一行声明 Red Hat 版本号和名称的信息。由 rc.local 使用。</td></tr><tr><td>/etc/rc.d/rc</td><td>通常在所有运行级别运行，级别作为参数传送。例如，要以图形（Graphics）模式（X-Server）引导机器，请在命令行运行下面的命令： init 5 。运行级别 5 表示以图形模式引导系统。</td></tr><tr><td>/etc/rc.d/rc.local</td><td>非正式的。可以从 rc、rc.sysinit 或 /etc/inittab 调用。</td></tr><tr><td>/etc/rc.d/rc.sysinit</td><td>通常是所有运行级别的第一个脚本。</td></tr><tr><td>/etc/rc.d/rc/rcX.d</td><td>从 rc 运行的脚本（ X 表示 1 到 5 之间的任意数字）。这些目录是特定“运行级别”的目录。当系统启动时，它会识别要启动的运行级别，然后调用该运行级别的特定目录中存在的所有启动脚本。例如，系统启动时通常会在引导消息之后显示“entering run-level 3”的消息；这意味着 /etc/rc.d/rc3.d/ 目录中的所有初始化脚本都将被调用。</td></tr></tbody></table><p>文件系统<br>内核提供了一个接口，用来显示一些它的数据结构，这些数据结构对于决定诸如使用的中断、初始化的设备和内存统计信息之类的系统参数可能很有用。这个接口是作为一个独立但虚拟的文件系统提供的，称为 /proc 文件系统。很多系统实用程序都使用这个文件系统中存在的值来显示系统统计信息。例如，/proc/modules 文件列举系统中当前加载的模块。lsmod 命令读取此信息，然后将其以人们可以看懂的格式显示出来。下面表格中指定的 mtab 文件以同样的方式读取包含当前安装的文件系统的 /proc/mount 文件。 </p><table><thead><tr><th>/etc/mtab</th><th>这将随着 /proc/mount 文件的改变而不断改变。换句话说，文件系统被安装和卸载时，改变会立即反映到此文件中。  1.文件格式  /etc/mtab 的格式和/etc/fstab 是一样的.但这个文件不能算是用户配置文件,他是由系统维护的.和/etc/fstab 的区别在于, fstab 是系统启动时需挂载的文件系统列表,而 mtab 是系统当前已挂载的文件系统列表,它由系统维护,在用户执行了 mount 或者 umount 命令后自动更新.用户不应该对此文件作任何修改. 2.安全性  /etc/mtab 的默认权限仍然是 644  3.相关命令  mount  umount  smbmount</th></tr></thead><tbody><tr><td>/etc/fstab</td><td>1.文件格式  /etc/fstab 记载了系统启动时自动挂载的文件系统。一行为一条记录。每条记录有 6 个字段，字段间用空格或者 tab 键分开。这六个字段分别是：设备名称，挂载点（除交换分区为 swap 外，都必须是一个存在的目录名），文件系统类型，mount 选项，是否需要 dump（1 表示需要，0 表示不需要），在 reboot 期间 fsck检查的顺序（激活文件系统设定为 1，其余文件系统设定为 2，若设定为 0 表示该文件系统不需要被检查）。  在 linux 和 windows 共存时，也许想开机自动挂载 windows 分区，那么就可以在这个文件里加上相应的记录。</td></tr></tbody></table><table><thead><tr><th></th><th>某些时候对硬盘分区作了调整以后，这里也需要做一些相应的修改。否则会出现一些问题。  可用的 mount 选项：  async  对该文件系统的所有 I/O 操作都异步执行  ro  该文件系统是只读的  rw  该文件系统是可读可写的  atime  更新每次存取 inode 的存取时间  auto  可以使用 -a 选项 mount  defaults  使用预设的选项：rw,suid,dev,exec,auto,nouser,async  dev  解释在文件系统上的字符或区块设备  exec  允许执行二进制文件  noatime  不要在这个文件系统上更新存取时间  noauto  这个文件系统不能使用 -a 选项来 mount  nodev  不要解释在文件系统上的字符或区块设备  noexec  不允许在 mounted 文件系统上执行任何的二进制文件。这个选项对于具有包含非它自己的二进制结构的文件系统服务器而言非常有用  nosuid  不允许 setuid 和 setgid 位发生作用。（这似乎很安全，但是在安装 suidperl后，同样不安全）。  nouser  限制一般非 root 用户 mount 文件系统  remount  尝试重新 mount 已经 mounted 的文件系统。这通常是用来改变文件系统的 mount标志，特别是让只读的文件系统变成可擦写的  suid  允许 setuid 和 setgid 位发生作用  sync  文件系统的所有 I/O 同步执行  user  允许一般非 root 用户 mount 文件系统。这个选项会应用 noexec,nosuid,nodev这三个选项（除非在命令行上有指定覆盖这些设定的选项）。  3.安全性</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>/etc/fstab 的默认权限是 644,所有者和所有组均为 root  2.相关命令  mount  df  列举计算机当前“可以安装”的文件系统。这非常重要，因为计算机引导时将运行 mount -a 命令，该命令负责安装 fstab 的倒数第二列中带有“1”标记的每一个文件系统。</th></tr></thead><tbody><tr><td>/etc/mtools.conf</td><td>DOS 类型的文件系统上所有操作（创建目录、复制、格式化等等）的配置。</td></tr></tbody></table><p>系统管理 </p><table><thead><tr><th>/etc/group</th><th>1.文件格式  /etc/group 存储了系统中所有用户的基本信息.它的格式和/etc/passwd 的格式基本类似,这里就说简单一点,  /etc/group 也是由一条条的记录组成.每条记录分 4 个字段.分别是组名,组口令,组 ID 和该组包含用户列表.其中组口令不再使用（现在只是保留为 x）.最后一个域是一个用逗号分隔的用户名列表,这个组的成员就是在这里列出的所有用户.  2.安全性  /etc/group 的默认权限是 644,所有者和所有组均为 root.注意经常检察. 3.相关命令  groupadd  groupdel  groupmod  groups  包含有效的组名称和指定组中包括的用户。单一用户如果执行多个任务，可以存在于多个组中。例如，如果一个“用户”是“project 1”工程组的成员，同时也是管理员，那么在 group 文件中他的条目看起来就会是这样的： user: * : group-id : project1</th></tr></thead><tbody><tr><td>/etc/nologin</td><td>这是一个普通的文本文件.你可以在里面写上你喜欢的任何东西./etc/nologin的作用在于,如果它存在,那么系统将拒绝任何非 root 用户的登录请求,并对其它登录用户显示此文件的内容  此文件常由系统在停机前自动生成.有时系统管理员也会手工生成它,用以禁止其它用户登录,方便进行一些管理工作.</td></tr><tr><td>etc/passwd</td><td>1.文件格式  /etc/passwd 存储了系统中所有用户的基本信息.可以说这是系统中最重要的一个配置文件.对它作任何修改一定要小心谨慎.同时要经常检察这个文件,包括它的内容和权限设置.  使用 vi 编辑程序打开此文件,可以看到这个文件由许多行记录组成.每一行记录对应着一个用户.我们以第一行为例.第一行一般是 root 用户的记录,尽管这不是必需的.实际上用户记录出现的顺序并没有任何的意义.  在我的系统中,/etc/passwd 的第一行看起来是这样的:  root:x:0:0:root:/root:/bin/bash  每一条记录都由 7 个字段组成,每个字段之间用冒号隔开.第一个字段是用户名,示例中是 root.第二个字段是用户口令,示例中是一个字符 x,但这并不表示</td></tr></tbody></table><table><thead><tr><th></th><th>root 的口令是单个字符 x,而是说用户口令被加密了,并且加密口令也没有放在本文件中,而是放到了/etc/shadow(参考 /etc/shadow).假如删除这个 x,那么root 的口令就清空了.第三个字段是用户的用户 ID,即 uid.第四个字段是用户的组 ID,即 gid. 这里要注意,系统分辨两个用户是看他们的 uid 是否相同而不是看他们的用户名是否相同.用户名不同但 uid 相同的两个用户实际上是同一个用户.对组来说也有类似的规则.所以这两个字段大家一定要注意.第五个字段是用户全称,没有什么实际用途,相当于注释,这里是 root.第六个字段是用户的主目录 (home),即登录系统后默认所处目录,这里是/root.最后一个字段是用户的登录 shell,可以是系统拥有的任何一个 shell 的完整路径,这里是/bin/bash.注意,这个字段可以有一个特殊的值,即/sbin/nologin.如果把一个用户的登录 shell 设置为 /sbin/nologin 的话,系统将禁止此用户的本地登录. 请参阅“man passwd”。它包含一些用户帐号信息，包括密码（如果未被 shadow 程序加密过）。  2.安全性  /etc/passwd 的默认权限为 644,所有者和所有组均为 root.切记,在任何情况下都不要更改它.  3.相关命令  passwd  useradd  userdel  adduser  usermod  users</th></tr></thead><tbody><tr><td>/etc/rpmrc</td><td>rpm 命令配置。所有的 rpm 命令行选项都可以在这个文件中一起设置，这样，当任何 rpm 命令在该系统中运行时，所有的选项都会全局适用。</td></tr><tr><td>/etc/securetty</td><td>包含设备名称，由 tty 行组成（每行一个名称，不包括前面的 /dev/），root 用户在这里被允许登录。  1.文件格式  这是一个设备文件的列表.文件名取相对于/dev 的相对路径.如,/dev/tty1 记为 tty1  root 只有从这个列表中列出的设备上才可以登录系统.  例如:  代码: $cat /etc/securretty  tty1  tty2  tty3  这里 root 被限定只能从/dev/tty1, /dev/tty2, /dev/tty3 这三个设备上登录系统  如果/etc/securretty 不存在的话,那么 root 将可以从任何设备登录系统. 2.安全性  /etc/securetty 的默认权限是 600,所有者和所有组都是 root</td></tr><tr><td>/etc/shadow</td><td>包含加密后的用户帐号密码信息，还可以包括密码时效信息。包括的字段有：</td></tr></tbody></table><table><thead><tr><th></th><th>• • • • • • • • 登录名 加密后的密码  从 1970 年 1 月 1 日到密码最后一次被更改的天数  • 距密码可以更改之前的天数 距密码必须更改之前的天数 密码到期前用户被警告的天数 密码到期后帐户被禁用的天数 从 1970 年 1 月 1 日到帐号被禁用的天数  1.文件格式 /etc/shadow 文件保存的是用户名,密码,用户账号设置相关信息。 例： root:$1$6UviCNvh$WTR0zPMek41KmzD0Z1DdV1:12264:3:4:5:6:12267: 第一段: root—– 用户注册名 第二段: $1$6UviCNvh$WTR0zPMek41KmzD0Z1DdV1 —-加密口令 第三段: 12264—–上次更动密码的日期,以 1970 年 1 月 1 日为 1,1 天加 1 第四段: 3———密码将被允许修改之前的天数（0 表示“可在任何时间修改”） 第五段: 4———系统将强制用户修改为新密码之前的天数（1 表示“永远都不能修改”） 第六段: 5———密码过期之前，用户将被警告过期的天数（-1 表示“没有警告”） 第七段: 6———密码过期之后，系统自动禁用帐户的天数（-1 表示“永远不会禁用”） 第八段: 12267—–该帐户被禁用的天数（-1 表示“该帐户被启用”）.以 1970年 1 月 1 日为 1,1 月 2 日为 2 第九段 —— 保留供将来使用 注:第 2 段中为*表示帐号不可登录,如密码前为 !! 或只有 !! 表示帐号被锁 2.安全性</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>/etc/shadow 的默认所有者和所有组均为 root. 建议运行# chattr +i /etc/shadow 来保护文件使其不被意外地删除或重写 3.相关命令 passwd useradd userdel usermod</th></tr></thead><tbody><tr><td>/ect/gshadow</td><td>1.文件格式  /ect/gshadow 文件保存的是用户和组群设置的信息  例:  root:!!::root,wa1  第一段：组名  第四段：该组包含用户列表  2.安全性  /etc/gshadow 的默认所有者和所有组均为 root.  建议运行# chattr +i /etc/shadow 来保护文件使其不被意外地删除或重写 3.相关命令  groupadd  groupdel  groupmod  groups</td></tr><tr><td>/etc/sysctl.conf</td><td>1.文件格式  /etc/sysctl.conf 是 sysctl 程序的配置文件.sysctl 可以在系统运行时更改内核参数./etc/sysctl.conf 中的配置将在系统起动时执行.  以 # 和 ; 开始的行是注释,将和空白行一起被忽略.  配置项的格式为:  token = value  token 是一个键名,value 是对应的键值.token 和 value 前后的空格将被忽略 token 不能是随意的字符串.他和/proc/sys 下的文件有一一对应的关系: 假设foo是/proc/sys下的一个文件.删除foo的绝对路径前的 “/proc/sys” 这一部分,然后把剩下部分中的 “/“ 替换成 “.”,得到的字符串就是 foo 所对应的键名.例如:  /proc/sys/net/ipv4/ip_forward 对应的键名为 net.ipv4.ip_forward 应用举例:  Redhat Linux 9 默认是禁止 ip 转发的,而我们在做 ip 伪装时需要起用 ip 转发.通常的做法是在 iptables 的规则之前加上一句:  echo 1&gt;/proc/sys/net/ipv4/ip_forward  实际上我们也可以在/etc/sysctl.conf 中写上:</td></tr></tbody></table><table><thead><tr><th></th><th>net.ipv4.ip_forward = 1  这样系统就默认起用 ip 转发了.当然他不会立即生效.因为/etc/sysctl.conf是在系统起动时读入的.想要立即生效的话,请使用 sysctl 命令.  2.安全性  /etc/sysctl.conf 的默认权限是 644,所有者和所有组均为 root  3.See also  sysctl(8)  sysctl.conf(5)  proc(5)  procinfo(8)</th></tr></thead><tbody><tr><td>/etc/shells</td><td>包含系统可用的可能的“shell”的列表。</td></tr><tr><td>/etc/motd</td><td>每日消息；在管理员希望向 Linux 服务器的所有用户传达某个消息时使用。</td></tr></tbody></table><p>联网 </p><table><thead><tr><th>/etc/gated.conf</th><th>gated 的配置。只能被 gated 守护进程所使用。</th></tr></thead><tbody><tr><td>/etc/gated.version</td><td>包含 gated 守护进程的版本号。</td></tr><tr><td>/etc/gateway</td><td>由 routed 守护进程可选地使用。</td></tr><tr><td>/etc/networks</td><td>列举从机器所连接的网络可以访问的网络名和网络地址。通过路由命令使用。允许使用网络名称。</td></tr><tr><td>/etc/protocols</td><td>列举当前可用的协议。请参阅 NAG（网络管理员指南，Network Administrators Guide）和联机帮助页。 C 接口是 getprotoent。绝不能更改。</td></tr><tr><td>/etc/resolv.conf</td><td>在程序请求“解析”一个 IP 地址时告诉内核应该查询哪个名称服务器。  1.文件格式  /etc/resolv.conf 是系统的 DNS 解析器配置文件，最常见的用途是用来指定系统所使用的 DNS 服务器地址，您可以最多指定 MAXNS 个 DNS 服务器，MAXNS 是一个常量，在/usr/include/resolv.h 中定义，一般为 3。每个 DNS 服务器地址应该以点分十进制格式写在单独的行上，前面加上关键字 nameserver。例如：  nameserver 173.26.100.99  nameserver 202.118.224.101  这里我们指定了两个 DNS 服务器，ip 地址分别为 173.26.100.99 和 202.118.224.101。当系统需要进行 DNS解析时，优先使用列在前面的 DNS Server，如果解析失败则转而使用下一个 DNS Server。  2.安全性  /etc/resolv.conf 的默认权限为 0644</td></tr><tr><td>/etc/host.conf</td><td>1.文件格式</td></tr></tbody></table><table><thead><tr><th></th><th>/etc/host.conf 也是一个 DNS 解析器配置文件，但它最常见的用途是用来指定解析器使用的方法。一般来说，DNS解析可以使用两种方法，一是查询 DNS 服务器，二是使用本地 hosts 主机表。/etc/host.conf 可以用来指定优先使用哪一种方法。可以使用 order 关键字来指定他们的优先级.order 后可跟一种或多种 DNS 查询方法，之间用逗号隔开，其优先级依次降低。可用的 DNS 查询方法有： hosts,bind,nis，分别表示使用本地 hosts 主机表，DNS服务器，NIS 服务器来进行 DNS 查询。最常见的配置是： order bind,hosts  2.安全性  /etc/host.conf 的默认权限为 0644</th></tr></thead><tbody><tr><td>/etc/rpc</td><td>包含 RPC 指令／规则，这些指令／规则可以在 NFS 调用、远程文件系统安装等中使用。</td></tr><tr><td>/etc/exports</td><td>要导出的文件系统（NFS）和对它的权限。</td></tr><tr><td>/etc/services</td><td>将网络服务名转换为端口号／协议。由 inetd、telnet、tcpdump 和一些其它程序读取。有一些 C 访问例程。</td></tr><tr><td>/etc/inetd.conf</td><td>inetd 的配置文件。请参阅 inetd 联机帮助页。包含每个网络服务的条目，inetd 必须为这些网络服务控制守护进程或其它服务。注意，服务将会运行，但在 /etc/services 中将它们注释掉了，这样即使这些服务在运行也将不可用。格式为：<service_name> <sock_type> <proto> <flags> <user> <server_path> <args></args></server_path></user></flags></proto></sock_type></service_name></td></tr><tr><td>/etc/sendmail.cf</td><td>邮件程序 sendmail 的配置文件。比较隐晦，很难理解。</td></tr><tr><td>/etc/sysconfig/network</td><td>指出 NETWORKING=yes 或 no。至少由 rc.sysinit 读取。</td></tr><tr><td>/etc/sysconfig/network-scripts/if*</td><td>Red Hat 网络配置脚本。</td></tr></tbody></table><p>系统命令<br>系统命令要独占地控制系统，并让一切正常工作。所有如 login（完成控制台用户身份验证阶段）或 bash（提供用户和计算机之间交互）之类的程序都是系统命令。因此，和它们有关的文件也特别重要。这一类别中有下列令用户和管理员感兴趣的文件。 </p><table><thead><tr><th>/etc/lilo.conf 包含系统的缺省引导命令行参数，还有启动时使用的不同映象。您在 LILO 引导提示的时候按 Tab 键就可以看到这个列表。</th><th></th></tr></thead><tbody><tr><td>/etc/logrotate.conf 维护 /var/log 目录中的日志文件。</td><td></td></tr><tr><td>/etc/identd.conf identd 是一个服务器，它按照 RFC 1413 文档中指定的方式实现 TCP/IP 提议的标准 IDENT 用户身份识别协议。identd 的操作原理是查找特定 TCP/IP 连接并返回拥有此连接的进程的用户名。作为选择，它也可以返回其它信息，而不是用户名。请参阅 identd 联机帮助页。</td><td></td></tr><tr><td>/etc/ld.so.conf “动态链接程序”（Dynamic Linker）的配置。</td><td></td></tr><tr><td>/etc/inittab</td><td>按年代来讲，这是 UNIX 中第一个配置文件。在一台 UNIX 机器打开之后启动的第一个程序是 init，它知道该启动什么，这是由于 inittab 的存在。</td></tr></tbody></table><table><thead><tr><th></th><th>在运行级别改变时，init 读取 inittab，然后控制主进程的启动。 1.文件格式  init 进程将查看此文件来启动子进程,完成系统引导./etc/inittab 描述了一个进程是在系统引导时起动还是在系统引导完成后的某个情形下起动.他也是由一行行的记录组成的.而以 # 开头的行是注释,将被忽略.  记录的格式是:  id:runlevels:action:process  id 域是一个由 1 到 4 个字符组成的字符串,这个字符串必需是唯一的,即不能有两条记录拥有相同的 id 域.id 域是一个标志域,由它区分各条记录.注意,对于 gettys 或者其他的 login 进程来说,id 域必须是对应 tty 的 tty 后缀,例如,对于 tty1 来说,id 域应该是 1.查看你的 /etc/inittab,会发现类似下面这样的记录:  ………  1:2345:respawn:/sbin/mingetty tty1  2:2345:respawn:/sbin/mingetty tty2  3:2345:respawn:/sbin/mingetty tty3  ………….  runlevels 域是一个运行级的列表,可用的运行级有:  0 —- 停机  1 —- 单用户模式  2 —- 不带 NFS 的多用户模式  3 —- 完整的多用户模式  4 —- 没有使用  5 —- X11  6 —- 重起系统  S —- 单用户  s —- 同 S  action 域是一个预定义的动作,可用的 action 有:  respawn  进程终止后立刻重新开始(如 getty 进程)  wait  进程在进入指定的运行级后起动一次,然后 init 将等待它的终止  once  进程在进入指定的运行级后起动一次  boot  进程在系统引导时起动,runlevels 域将被忽略  bootwait  进程在系统引导时起动,然后 init 将等待它的终止,runlevels 域将被忽略 off  这个 action 不做任何事  ondemand  有一个特殊的运行级叫做 ondemand runlevel,包括 a,b 和 c.如果一个进程被标记了 ondemand runlevel,那么当要求切换到这个 ondemand runlevel时将会起动这个进程.但实际上的 runlevel 不会改变</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>initdefault  标记了 initdefault 这个 action 的记录项的 runlevel 域指定了系统引导完成后进入的运行级  sysinit  在系统引导时起动这个进程.而且在所有的 boot 和 bootwait 项之前起动.process 域将被忽略  powerwait  在电力中断时起动这个进程.通常会由一个与连接到计算机的 UPS 系统对话的进程通知 init 电力切断.init 在继续之前将等待这个进程结束  powerfail  同 powerwait 类似,但是 init 不会等待这个进程结束  powerokwait  一旦 init 被通知电力已经恢复,将起动这个进程  powerfailnow  当 init 被告知 UPS 的电力亦将耗尽时起动这个进程  ctrlaltdel  当 init 接到 SIGINT 信号时起动这个进程.一般是按下了 ctrl+alt+del 这个组合键  kbrequest  当一个特殊的键盘组合键被按下时起动这个进程  process 域指定了将运行的进程,可以有参数.如果这个域以 + 开头,表明init 将为这个进程更新 utmp/wtmp 记录.  范例:  id:3:initdefault:  系统引导完成后进入运行级 3  si::sysinit:/etc/rc.d/rc.sysinit  系统引导时运行/etc/rc.d/rc.sysinit  l0:0:wait:/etc/rc.d/rc 0  系统进入运行级 0 时执行/etc/rc.d/rc 0,这里 0 是参数  ca::ctrlaltdel:/sbin/shutdown -t3 -r now  捕获到 ctrl+alt+del 时运行/sbin/shutdown -t3 -r now.如果想禁用ctrl+alt+del 这个组合键,直接删除或注释掉这行  pf::powerfail:/sbin/shutdown -f -h +2 “Power Failure; System Shutting Down”  电力中断时执行/sbin/shutdown -f -h +2 “Power Failure; System Shutting Down”  1:2345:respawn:/sbin/mingetty tty1  进入运行级 2,3,4 或 5 时执行 respawn:/sbin/mingetty tty1.注意指定的action 是 respawn,这也就是为什么我们在终端下 logout 后会立刻又出现一个 login 提示符  x:5:respawn:/etc/X11/prefdm -nodaemon  进入运行级 5 时执行/etc/X11/prefdm -nodaemon,指定的 action 是 respawm 2.安全性  /etc/inittab 的权限是 644,所有者和所有组均为 root</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>3.相关命令  init  telinit  更多内容请  man init  man inittab</th></tr></thead><tbody><tr><td>/etc/termcap</td><td>一个数据库，包含所有可能的终端类型以及这些终端的性能。</td></tr></tbody></table><p>守护进程<br>守护进程是一种运行在非交互模式下的程序。一般来说，守护进程任务是和联网区域有关的：它们等待连接，以便通过连接提供服务。Linux 可以使用从 Web 服务器到 ftp 服务器的很多守护进程。 </p><table><thead><tr><th>/etc/syslog.conf</th><th>syslogd 是一种守护进程，它负责记录（写到磁盘）从其它程序发送到系统的消息。这个服务尤其常被某些守护进程所使用，这些守护进程不会有另外的方法来发出可能有问题存在的信号或向用户发送消息。  1.文件格式  /etc/syslog.conf 是 syslog 守护程序的配置文件.syslog 守护程序为记录来自运行于系统之上的程序的消息提供了一种成熟的客户机 -服务器机制。syslog 接收来自守护程序或程序的消息，根据优先级和类型将该消息分类，然后根据由管理员可配置的规则将它写入日志。结果是一个健壮而统一的管理日志的方法。  这个文件由一条条的规则组成.每条规则应该写在一行内.但是如果某行以反斜线 \ 结尾的话,他的下个物理行将被认为与此行同属于一行.空白行和以 # 开始的行将被忽略.  每条规则都是下面这种形式:  facility.priority[;facility.priority …..] action  facility 和 priority 之间用一个英文句点分隔.他们的整体称为 selector. 每条规则可以有多个 selector,selector 之间用分号隔开. 而 selector 和action 之间则用空格或者 tab 隔开.  facility 指定 syslog 功能，主要包括以下这些：  auth 由 pam_pwdb 报告的认证活动。  authpriv 包括特权信息如用户名在内的认证活动  cron 与 cron 和 at 有关的信息。  daemon 与 inetd 守护进程有关的信息。  kern 内核信息，首先通过 klogd 传递。  lpr 与打印服务有关的信息。  mail 与电子邮件有关的信息  mark syslog 内部功能用于生成时间戳  news 来自新闻服务器的信息  syslog 由 syslog 生成的信息  user 由用户程序生成的信息  uucp 由 uucp 生成的信息  local0—-local7 与自定义程序使用，例如使用 local5 做为 ssh 功能</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>* 通配符代表除了 mark 以外的所有功能  priority 指定消息的优先级. 与每个功能对应的优先级是按一定顺序排列的，emerg 是最高级，其次是 alert，依次类推。缺省时，在  /etc/syslog.conf 记录中指定的级别为该级别和更高级别。如果希望使用确定的级别可以使用两个运算符号！(不等)和=。  user.=info  表示告知 syslog 接受所有在 info 级别上的 user 功能信息。  可用的 syslog 优先级如下:  emerg 或 panic 该系统不可用  alert 需要立即被修改的条件  crit 阻止某些工具或子系统功能实现的错误条件  err 阻止工具或某些子系统部分功能实现的错误条件  warning 预警信息  notice 具有重要性的普通条件  info 提供信息的消息  debug 不包含函数条件或问题的其他信息  none 没有重要级，通常用于排错  * 所有级别，除了 none  action 字段所表示的活动具有许多灵活性，特别是，可以使用名称管道的作用是可以使 syslogd 生成后处理信息。  syslog 主要支持以下 action  file  指定文件的绝对路径,如: /var/log/messages . log 信息将写到此文件中 terminal 或 printer  完全的串行或并行设备标志符,如/dev/console . log 信息将送到此设备 @host  远程的日志服务器. log 信息将送到此日志服务器  username  发送信息给指定用户  named pipe  指定使用 mkfifo 命令来创建的 FIFO 文件的绝对路径。  如果对此文件作了改动, 想要使改动生效，您需要向 syslog 守护程序通知所做的更改。向它发送 SIGHUP 是个正确的办法，您可以用 killall 命令轻松地做到这一点：  # killall -HUP syslogd  2.安全性  您应该清楚如果 syslogd 写的日志文件还不存在的话，程序将创建它们。无论您当前的 umask 如何设置，该文件将被创建为可被所有用户读取。如果您关心安全性，那么您应该用 chmod 命令将该文件设置为仅 root 用户可读写。此外，可以用适当的许可权配置 logrotate 程序（在下面描述）以创建新的日志文件。syslog 守护程序始终会保留现有日志文件的当前属性，因此一旦创建了文件，您就不需要担心它。  3.相关命令  logrotate</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>用户或系统程序在每次启动时都会读取其配置文件。尽管如此，请记住，有些系统程序在计算机打开时情况不一样，它们的行为依赖于在 /etc/ 中的配置文件中读到的内容。所以，用户程序第一次启动时将从 /etc/ 目录中存在的文件读取缺省配置。然后，用户可以通过使用 rc 和 .（点）文件来定制程序，正如下面一节所示。<br>用户配置文件：.（点）文件和 rc 文件<br>我们已经看到怎样容易地配置程序。但是如果有的人不喜欢在 /etc/ 中配置程序的方式该怎么办呢？“普通”用户不能简单地进入 /etc 然后更改配置文件；从文件系统的角度来看，配置文件的所有者是 root 用户！这就是大多数用户程序都定义两个配置文件的原因：第一个是“系统”级别的，位于 /etc/；另一个属于用户“专用”，可以在他或她的主目录中找到。<br>例如，我在我的系统中安装了非常有用的 wget 实用程序。/etc/ 中有一个 /etc/wgetrc 文件。在我的主目录中，有一个名为 .wgetrc 的文件，它描述了我定制的配置（只有在我，也就是用户运行 wget 命令时，才会加载这个配置文件）。其它用户在他们自己的主目录（/home/other）中也可以有 .wgetrc 文件；当然，只有这些用户运行 wget 命令时，才会读取这个文件。换句话说，/etc/wgetrc 文件为 wget 提供了“缺省”值，而 /home/xxx/.wgetrc 文件列举了某个用户的“定制项”。重要的是这只是“一般规则”，并非所有情况都如此。例如，一个象 pine 一样的程序，在 /etc/ 中并没有任何文件，它只在用户主目录中有一个定制配置文件，名为 .pinerc。其它程序可能只有 /etc/ 中的缺省配置文件，而且可能不允许用户“定制”这些配置文件（/etc 目录中只有少数 config. 文件是这种情况）。<br>通常使用的 rc 和 .（点）文件 </p><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>~/.bash_login</td><td>请参考“man bash”。如果  ~/.bash_profile 不存在，bash 则将 ~/.bash_login 作为  ~/.bash_profile 处理。</td></tr><tr><td>~/.bash_logout</td><td>请参考“man bash”。在退出时由 bash 登录 shell 引用。</td></tr><tr><td>~/.bash_profile</td><td>由 bash 登录 shell 引用  /etc/profile 之后引用。</td></tr><tr><td>~/.bash_history</td><td>先前执行的命令的列表。</td></tr><tr><td>~/.bashrc</td><td>请参考“man bash”。由 bash 非登录交互式 shell 引用（没有其它文件）。除非设置了 BASH_ENV 或 ENV，非交互式 shell 不引用任何文件。</td></tr><tr><td>~/.emacs</td><td>启动时由 emac 读取。</td></tr><tr><td>~/.forward</td><td>如果这里包含一个电子邮件地址，那么所有发往 ~ 的所有者的邮件都会被转发到这个电子邮件地址。</td></tr><tr><td>~/.fvwmrc ~/.fvwm2rc</td><td>fvwm 和 fvwm2（基本的 X Window 管理器）的配置文件。</td></tr><tr><td>~/.hushlogin</td><td>请参考“man login”。引起“无提示”登录（没有邮件通知、上次登录信息或者 MOD 信息）。</td></tr></tbody></table><table><thead><tr><th>~/.mail.rc</th><th>邮件程序的用户初始化文件。</th></tr></thead><tbody><tr><td>~/.ncftp/</td><td>ncftp 程序的目录；包含书签、日志、宏、首选项和跟踪信息。请参阅 man ncftp。ncftp 的目的是为因特网标准文件传输协议（Internet standard File Transfer Protocol）提供一个强大而灵活的接口。它旨在替换系统所使用的标准的 ftp 程序。</td></tr><tr><td>~/.profile</td><td>请参考“man bash”。如果  ~/.bash_profile 和 ~/.bash_login 文件不存在，bash 则将 ~/.profile 作为 ~/.bash_profile 处理，并被其它继承 Bourn 的 shell 使用。</td></tr><tr><td>~/.pinerc</td><td>Pine 配置</td></tr><tr><td>~/.muttrc</td><td>Mutt 配置</td></tr><tr><td>~/.exrc</td><td>这个文件可以控制 vi 的配置。  示例：set ai sm ruler  在此文件中写入上面一行会让 vi 设置自动缩进、匹配括号、显示行号和行-列这几个选项。</td></tr><tr><td>~/.vimrc</td><td>缺省的“Vim”配置文件。和 .exrc 一样。</td></tr><tr><td>~/.gtkrc</td><td>GNOME 工具包（GNOME Toolkit）。</td></tr><tr><td>~/.kderc</td><td>KDE 配置。</td></tr><tr><td>~/.netrc</td><td>ftp 缺省登录名和密码。</td></tr><tr><td>~/.rhosts</td><td>由 r- 工具（如 rsh、rlogin 等等）使用。因为冒充主机很容易，所以安全性非常低。 1. 必须由用户（~/ 的所有者）或超        级用户拥有。  2. 列出一些主机，用户可以从这些主        机访问该帐号。  3. 如果是符号链接则被忽略。</td></tr><tr><td>~/.rpmrc</td><td>请参阅“man rpm”。如果 /etc/rpmrc 不存在则由 rpm 读取。</td></tr><tr><td>~/.signature</td><td>消息文本，将自动附加在从此帐号发出的邮件末尾。</td></tr><tr><td>~/.twmrc</td><td>twm（ The Window Manager）的配置文件。</td></tr></tbody></table><table><thead><tr><th>~/.xinitrc</th><th>启动时由 X 读取（而不是由 xinit 脚本读取）。通常会启动一些程序。 示例：exec /usr/sbin/startkde 如果该文件中存在上面这行内容，那么在从这个帐号发出 startx 命令时，这一行就会启动“KDE 视窗管理器”（KDE Window Manager）。</th></tr></thead><tbody><tr><td>~/.xmodmaprc</td><td>此文件被传送到 xmodmap 程序，而且可以被命名为任何文件（例如  ~/.Xmodmap 和 ~/.keymap.km）。</td></tr><tr><td>~/.xserverrc</td><td>如果 xinit 可以找到要执行的 X，xinit 就会将该文件作为 X 服务器运行。</td></tr><tr><td>~/News/Sent-Message-IDs</td><td>gnus 的缺省邮件历史文件。</td></tr><tr><td>~/.Xauthority</td><td>由 xdm 程序读和写，以处理权限。请参阅 X、xdm 和 xauth 联机帮助页。</td></tr><tr><td>~/.Xdefaults,  ~/.Xdefaults-hostname</td><td>在主机 hostname 的启动过程中由 X 应用程序读取。如果找不到  -hostname 文件，则查找 .Xdefaults 文件。</td></tr><tr><td>~/.Xmodmap</td><td>指向 .xmodmaprc；Red Hat 有使用这个名称的 .xinitrc 文件。</td></tr><tr><td>~/.Xresources</td><td>通常是传送到 xrdb 以加载 X 资源数据库的文件的名称，旨在避免应用程序需要读取一个很长 的 .Xdefaults 文件这样的情况。（有些情况曾经使用了 ~/.Xres。）</td></tr><tr><td>~/mbox</td><td>用户的旧邮件。</td></tr></tbody></table><p>****3****、重要的配置文件列表： </p><p>启动引导程序配置文件<br>LILO /etc/lilo.conf<br>GRUB /boot/grub/menu.lst<br>系统启动文件核脚本<br>主启动控制文件 /etc/inittab<br>SysV 启动脚本的位置 /etc/init.d、/etc/rc.d/init.d 或/etc/rc.d<br>SysV 启动脚本链接的位置 /etc/init.d/rc?.d、/etc/rc.d/rc?.d 或/etc/rc?.d<br>本地启动脚本 /etc/rc.d/rc.local、/etc/init.d/boot.local 或/etc/rc.boot 里的文件 网络配置文件<br>建立网络接口的脚本 /sbin/ifup<br>保存网络配置数据文件的目录 /etc/network、/etc/sysconfig/network 和<br>/etc/sysconfig/network-scripts </p><p>保存解析 DNS 服务的文件 /etc/resolv.conf<br>DHCP 客户端的配置文件 /etc/dhclient.conf<br>超级服务程序配置文件和目录<br>inetd 配置文件 /etc/inetd.conf<br>TCP Wrappers 配置文件 /etc/hosts.allow 和/etc/hosts.deny<br>xinetd 配置文件 /etc/xinetd.conf 和/etc/xinetd.d 目录里的文件<br>硬件配置<br>内核模块配置文件 /etc/modules.conf<br>硬件访问文件<br>Linux 设备文件 /dev 目录里<br>保存硬件和驱动程序数据的文件 /proc 目录里<br>扫描仪配置文件<br>SANE 主配置 /etc/sane.d/dll.conf<br>特定扫描仪的配置文件 /etc/sane.d 目录里以扫描仪型号命名的文件<br>打印机配置文件<br>BSD LPD 核 LPRng 的本地打印机主配置文件 /etc/printcap<br>CUPS 本地打印机主配置和远程访问受权文件 /etc/cups/cupsd.conf<br>BSD LPD 远程访问受权文件 /etc/hosts.lpd<br>LPRng 远程访问受权文件 /etc/lpd.perms<br>文件系统<br>文件系统表 /etc/fstab<br>软驱装配点 /floppy、/mnt/floppy 或/media/floppy<br>光驱装配点 /cdrom、/mnt/cdrom 或/media/cdrom<br>shell 配置文件<br>bash 系统非登录配置文件 /etc/bashrc、/etc/bash.bashrc 或/etc/bash.bashrc.local bash 系统登录文件 /etc/profile 和/etc/profile.d 里的文件<br>bash 用户非登录配置文件 ~/.bashrc<br>bash 用户登录配置文件 ~/.profile<br>XFree86 配置文件核目录<br>XFree86 主配置文件 /etc/XF86config、/etc/X11/XF86Config 或/etc/X11/XF86Config-4 字体服务程序配置文件 /etc/X11/fs/config<br>Xft 1.x 配置文件 /etcX11/XftConfig<br>Xft 2.0 配置文件 /etc/fonts/fonts.conf<br>字体目录 /usr/X11R6/lib/X11/fonts 和/usr/share/fonts<br>Web 服务程序配置文件<br>Apache 主配置文件 /etc/apache、/etc/httpd 或/httpd/conf 里的 httpd.conf 或 httpd2.conf 文件<br>MIME 类型文件 与 Apache 主配置文件在同一目录里的 mime.types 或 apache-mime.types 文件服务程序配置文件<br>ProFTPd 配置文件 /etc/proftpd.conf<br>vsftpd 配置文件 /etc/vsftpd.conf<br>NFS 服务程序的输出定义文件 /etc/exports<br>NFS 客户端装配的 NFS 输出 /etc/fstab<br>Samba 配置文件 /etc/samba/smb.conf </p><p>Samba 用户配置文件 /etc/samba/smbpasswd<br>邮件服务程序配置文件<br>sendmail 主配置文件 /etc/mail/sendmail.cf<br>sendmail 源配置文件 /etc/mail/sendmail.mc 或/usr/share/sendmail/cf/cf/linux.smtp.mc 或其他文件<br>Postfix 主配置文件 /etc/postfix/main.cf<br>Exim 主配置文件 /etc/exim/exim.cf<br>Procmail 配置文件 /etc/procmailrc 或<del>/.procmailrc<br>Fetchmail 配置文件 ~/.fetchmailrc<br>远程登录配置文件<br>SSH 服务程序配置文件 /etc/ssh/sshd_config<br>SSH 客户端配置文件 /etc/ssh/ssh_config<br>XDM 配置文件 /etc/X11/xdm 目录下<br>GDM 配置文件 /etc/X11/gdm 目录下<br>VNC 服务程序配置文件 /usr/X11R6/bin/vncserver 启动脚本和</del>/.vnc 目录里的文件<br>其他服务程序配置文件<br>DHCP 服务程序配置文件 /etc/dhcpd.conf<br>BIND 服务程序配置文件 /etc/named.conf 和/var/named/<br>NTP 服务程序配置文件 /etc/ntp.conf </p><p><em><strong>*十六、*</strong></em> <em><strong>*计划任务*</strong></em> </p><p>​    在很多时候为了自动化管理系统，我们都会用到计划任务，比如关机，管理，备份之类的操作，我们都可以使用计划任务来完成，这样可以是管理员的工作量大大降低，而且可靠度更好。<br>linux 系统支持一些能够自动执行任务的服务，我们称为计划任务。<br> LINUX 有如下三种计划任务：<br>​        at：指定一个时间执行一个任务 （适用一个或多个任务，执行一次后就不用）<br>​        cron：根据一个时间表自动执行任务 （使用一个或多个任务，周期性执行）<br>​        系统级别的计划任务及其扩展 anacron：在一个指定时间间隔错过后自动执行任务 </p><p>****1*<em><strong>、 <em><strong>*at:*</strong></em> 安排一个任务在未来执行，需要一个</strong></em>*atd****的系统后台进程 </p><table><thead><tr><th>检查 <em><strong>*atd*</strong></em> 进程是否启动  [root@centos61 桌面]# service atd status  atd (pid  2274) 正在运行…  [root@centos61 桌面]# chkconfig |grep atd</th><th>6:关闭</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>atd</td><td>0:关闭</td><td>1:关闭</td><td>2:关闭</td><td>3:启用</td><td>4:启用</td><td>5:启用</td></tr><tr><td>如果未启动，可以使用如下命令：  [root@centos61 桌面]# service atd start  正在启动 atd：                       [确定] [root@centos61 桌面]# chkconfig atd on  常用指令:  at:安排延时任务  具体使用方法:  例 1:  #at now+2 minutes  回车  &gt;输入要执行的命令</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>&gt;ctrl+d 结束输入<br>[root@test ~]# at now+2 minutes<br>at&gt; wall Aixi<br>at&gt; <EOT><br>job 2 at 2010-06-18 16:36<br><EOT>是 ctrl+d 中断输入，这个命令意思是发送一个广播内容是 Hello Aixi.具体时间可以改,单位可以改,可以用 hours,months,years,weeks 等.<br>例 2 我们还可以跟具体时间<br>[root@test ~]# at 16:39 dec 10<br>at&gt; Hello Aixi<br>at&gt; <EOT> ctrl+d 结束输入<br>job 3 at 2010-12-10 16:39<br>意思是在今年的 12 月 10 日 16:39 运行这个命令.如果不加月和日,默认就是今天.<br>Atq:查询当前的等待任务<br>用 atq 来查询，已经运行的任务，就消失了。这就是 at 计划任务的重点，只运行一次 </EOT></EOT></EOT></p><p>atrm：删除等待任务<br>启动计划任务后，如果不想启动设定好的计划任务可以使用 atrm 命令删除。<br>格式：atrm 任务号<br>命令后面跟计划任务编号，如果不跟，就会删除这个用户所有的计划任务。<br>例 3<br>atrm 10 //删除计划任务 10<br>atq //查看计划任务是否删除 </p><p>at 将要运行的命令以文本形式写入/var/spool/at/目录内，等待 atd 服务的取用和执行。<br>还可以进入到/var/spool/at 目录里把计划任务删除，计划任务的文件都保存在该目录里，可以用 rm -f 文件名来删除(以文件的形式删除计划任务，因为计划任务是以文件形式保存在该目录中)<br>例 4:<br>#cd /var/spool/at //进入到/var/spool/at 目录中<br>ls //显示目录中所有文件<br>rm -f a0000b0138b19c //删除计划任务 </p><p>在通常情况下，超级用户都可以使用这个命令。对于其他用户来说，能否可以使用就取决于两个文件:/etc/at.allow 和/etc/at.deny。<br>at 命令是可以基于用户来控制的，我们可以明确指定哪些用户可以使用 at 计划任务，哪些用户不可以使用 at 计划任务。<br>at 的控制文件<br>/etc/at.allow<br>/etc/at.deny<br>系统默认是有 at.deny 文件，如果某个用户名在这个文件里，他就不能使用 at 计划任务。如果有at.allow 文件，allow 文件先行，检查了 allow 明确允许，就不会检查 deny。 </p><p>如果你要让哪个用户不能使用计划任务，就直接把他的用户名写进去就可以了，一排只能写一个。 </p><p>**<br>**</p><p><em><strong>*2*<em><strong>、</strong></em>*cron*<em><strong>服务</strong></em>*(*<em><strong>参考网址：</strong></em>*<a href="http://www.linuxsir.org/main/?q=node/209)%5C">http://www.linuxsir.org/main/?q=node/209)\</a>*</strong></em> </p><p> 相对与 at，cron 的优点就是能够周期性的执行某个命令,at 却只能执行一次，cron 的后台进程名字是 crond ,cron 也是 system V 的服务，所以我们可以 service crond start|stop 来启动和关闭此服务,也可以使用 chkconfig 或者 ntsysv 来选择 cron 服务的默认开启，这些命令在以前我们都讲过的  命令：<br> #crontab -e        编辑当前用户的 cron 表<br>            #crontab -l        查看当前用户的 cron 表<br>            #crontab -r        删除当前用户的 cron 进程<br>            #crontab -u 用户名 以某用户的身份来控制 cron 表<br>            还有个重要的知识点，就是当用户的计划任务建立后是存放在 var/spool/cron 这个目录<br>            当使用 crontab -e 编辑当前用户的 cron 表后，会出现一个 vi 文件，cron 的格式是这样的。分成两            列，左边是时间，右边是运行的命令。时间是由 5 个部分组成。<br>            例：<br>            * * * * *      wall hello everyone<br>            5 个星号分别代表：minute hour day-of-month month-of-year day-of-week  ，而 wall hello             everyone 这是命令内容。上面的意识是每分每小时每天每月每周广播 hello everyone。具体时间大            家可以自己定义。如果要每两分钟发送就用*/2 代替第一个<em>。也可以是用具体时间来表示。             我们使用 crontab -e 编辑当前用户的 cron 表<br>            这里的 5 个星号就代表的时间和日期：<br>            第一个</em>星号代表个小时的第几分钟：minute 范围是从 0-59<br>            第二个<em>星号代表每天的第几个小时：hour 范围是从 0-23<br>            第三个</em>星号代表每月的第几个日：day-of-month 范围从 1-31<br>            第四个<em>星号代表没年的第几个月：month-of-year 范围从 1-12<br>            第五个</em>星号代表每周的星期几：day-of-week 范围从 0-6，其中 0 表示星期日<br>            用户名：也就是执行程序要通过哪个用户来执行，这个一般可以省略；<br>            命令：执行的命令和参数。<br>            时程表的格式如下 :<br>            f1 f2 f3 f4 f5 program<br>            其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期            中的第几天。program 表 示要执行的程序。<br>            当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其余以此类推             当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b             小时都要执行，其余以此类推<br>            当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一            次，其余以此类推<br>            当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…            个小时要执行，其余以此类推<br>            使用者也可以将所有的设定先存放在档案 file 中，用 crontab file 的方式来设定时程表。  例 1：如果我要表示 9 月 10 日 25 分执行 ls var/spool/cron 任务怎么表示？<br>                    25 * 10 9 *     ls var/spool/cron<br>                    由于我没表示小时，所以就只能里面为每小时<br> 例 2：我要在每周日，每分钟执行 wall Hello redking.blog.51cto.com 这个命令，时间怎么表示？                     */1 * * * 0 wall Hello redking.blog.51cto.com<br>                    */  表示每多少分钟执行一次 </p><p> 例 3：每晚的 21:30 重启 apache。 </p><table><thead><tr><th>30 21 * * * /usr/local/etc/rc.d/lighttpd restart   例 4：每月 1、10、22 日的 4 : 45 重启 apache</th><th></th></tr></thead><tbody><tr><td></td><td>45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart</td></tr><tr><td>例 5：每周六、周日的 1 : 10 重启 apache           10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart  例 6：在每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 apache           0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart  例 7：每一小时重启 apache           * */1 * * * /usr/local/etc/rc.d/lighttpd restart  例 8：晚上 11 点到早上 7 点之间，每隔一小时重启 apache           * 23-7/1 * * * /usr/local/etc/rc.d/lighttpd restart  例 9：每月的 4 号与每周一到周三的 11 点重启 apache           0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart  例 10：一月一号的 4 点重启 apache           0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart  例 11：在 12 月内, 每天的早上 6 点到 12 点中，每隔 3 个小时执行一次 /usr/bin/backup          0 6-12/3 * 12 * /usr/bin/backup  例 12：每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”          20 0-23/2 * * * echo “haha”</td><td></td></tr></tbody></table><p><em><strong>*3*<em><strong>、系统级别的计划任务及其扩展</strong></em>*anacrontab*</strong></em> </p><p> 这个是系统设置好了，清理系统垃圾或者是自动执行某些脚本的系统任务，一般我们做了解就行了，不要更改配置文件是/etc/conrtab </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps28.jpg" alt="img"> </p><p>SHELL：就是运行计划任务的解释器，默认是 bash<br>PATH：执行命令的环境变量<br>MAILTO：计划任务的出发者用户<br>HOME：家目录为/<br>run-parts 是一个脚本，在/usr/bin/run-parts，作用是执行一个目录下的所有脚本/程序。 run-parts /etc/cron.hourly 执行目录/etc/cron.hourly/之下的所有脚本/程序.<br>run-parts 下面就是运行的命令 </p><p>vim /etc/crontab 与 crontab -e 写入的定时运行的区别?<br>vim /etc/crontab：是系统级别定义的 crontab，/etc/crontab 的所有者和组都是 root<br>crontab -e ：是用户自定义的 crontab，是所有的用户都可以写入的 </p><p>两种方法记录的位置不一样，一个在/etc/ 另一个在/var/ 里面。都被 cron 服务调用<br>如果系统在以上说的时间没有开机怎么办？那么这个脚本不就是不能执行了？设计者早就想到了这个问题，所以就有了 cron 服务的扩展,目的就是为了防止非 24 小时开机的计算机遗漏的守护任务,anacrontab 就是系统计划任务的扩展文件：在一个指定时间间隔错过后自动执行任务<br>格式是这样的：<br>period  delay  job-identifier  command<br>period — 命令执行的频率（天数）<br>delay — 延迟时间（分钟）<br>job-identifier — 任务的描述，用在 anacron 的消息中，并作为作业时间戳文件的名称，只能包括非空白的字符（除斜线外）。<br>command — 要执行的命令  </p><p><img src="file:///C:\Users\YUFANG~1\AppData\Local\Temp\ksohtml376\wps29.jpg" alt="img"> </p><p>第一行的意思是：每天开机 65 分钟后就检查 cron.daily 文件是否被执行了，如果今天没有被执行就执行他<br>第二行的意思是：每隔 7 天开机后 70 分钟检查 cron.weekly 文件是否被执行了,如果一周内没有被执行就执行他<br>第三行的意思也差不多<br>下面说说关于 cron 服务的控制，和 at 差不多，就是/etc/cron.deny 这个配置文件来控制，里面写入要禁止使用 cron 用户的名字，一行一个就 OK 了 </p><p><em><strong>*十七、*</strong></em> <em><strong>*VI/VIM*</strong></em><em><strong>*编辑器*</strong></em> </p><table><thead><tr><th>常用快捷键：</th><th></th><th></th></tr></thead><tbody><tr><td>Ctrl+f</td><td>向下翻页</td><td></td></tr><tr><td>Ctrl+b</td><td>向上翻页</td><td></td></tr><tr><td>G</td><td></td><td>移动到文件最后一行</td></tr><tr><td>gg</td><td></td><td>移动到文件第一行</td></tr><tr><td>N+回车 N 为数字，向下移到到 N 行  /关键字 向下寻找关键字  ?关键字 向上寻找关键字</td><td></td><td></td></tr><tr><td>#</td><td>从光标向后查找光标所在关键词</td><td></td></tr><tr><td>*</td><td>从光标向前查找光标所在关键词</td><td></td></tr><tr><td>n</td><td></td><td>向下重复上一次查找操作</td></tr><tr><td>N</td><td></td><td>与 n 相反，反向重复上一次查找操作</td></tr></tbody></table><table><thead><tr><th>:n1,n2s/关键字 1/关键字 2/g</th><th>从第 n1 与 n2 行之间寻找关键字 1，并将关键字 1 替换为关键字 2</th></tr></thead><tbody><tr><td>:1,$s/关键字 1/关键字 2/g</td><td>从第 1 行到最后一行寻找关键字 1，并将关键字 1 替换为关键字 2</td></tr><tr><td>:1,$s/关键字 1/关键字 2/gc</td><td>从第 1 行到最后一行寻找关键字 1，将关键字 1 替换为关键字 2 前会提示用</td></tr><tr><td>户确认是否替换  dd    删除整行  ndd   n 为数字，删除光标所在向下 n 行。</td><td></td></tr><tr><td>yy</td><td>复制光标所在行</td></tr><tr><td>nyy</td><td>n 为数字，复制光标所在向下 n 行</td></tr><tr><td>p,P</td><td>小 p 将复制的数据在光标下一行粘贴，大 P 将复制的数据在光标上一行粘贴</td></tr><tr><td>u</td><td>撤消前一个操作</td></tr><tr><td>Ctrl+r</td><td>重做上一个操作</td></tr><tr><td>.</td><td>将会重复上一个命令</td></tr><tr><td>i：在当前字符的左边插入  I：在当前行首插入  a：在当前字符的右边插入  A：在当前行尾插入  o：在当前行下面插入一个新行  O：在当前行上面插入一个新行</td><td></td></tr><tr><td>:w</td><td>保存数据</td></tr><tr><td>:wq</td><td>保存退出</td></tr><tr><td>:q!</td><td>不保存退出</td></tr><tr><td>:w 文件名 相当于另存为</td><td></td></tr></tbody></table><p><em><strong>*十八、*</strong></em> <em><strong>*压缩打包*</strong></em> </p><p>​        linux 下的压缩命令有 tar、gzip、gunzip、bzip2、bunzip2、 compress、uncompress、zip、unzip、rar、unrar 等等，压缩后的扩展名有.tar、.gz、.tar.gz、. tgz、.bz2、.tar.bz2、.Z、.tar.Z、.zip、.rar 10 种。     对应关系如下：<br>​        1、*.tar 用 tar –xvf 解压<br>​        2、*.gz 用 gzip -d 或者 gunzip 解压<br>​        3、*.tar.gz 和*.tgz 用 tar –xzf 解压<br>​        4、*.bz2 用 bzip2 -d 或者用 bunzip2 解压<br>​        5、*.tar.bz2 用 tar –xjf 解压<br>​        6、*.Z 用 uncompress 解压<br>​        7、*.tar.Z 用 tar –xZf 解压<br>​        8、*.rar 用 unrar e 解压<br>​        9、*.zip 用 unzip 解压<br>​        在介绍压缩文件之前呢，首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压 缩算法变成一个小文件。为什么要区分这两个概念呢?其实这源于 Linux 中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。 </p><p>**<br>**</p><p><em><strong>*Gzip/zcat*</strong></em> </p><p><em><strong>*Bzip2/bzcat*</strong></em> </p><p><em><strong>*Tar*</strong></em> </p><table><thead><tr><th></th><th>Linux 下最常用的打包程序就是 tar 了，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通</th><th></th></tr></thead><tbody><tr><td>常都是以.tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法：  tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</td><td></td><td></td></tr><tr><td><em><strong>*# tar -cf all.tar *.jpg*</strong></em></td><td>这条命令是将所有.jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指</td><td></td></tr><tr><td>定包的文件名。</td><td></td><td></td></tr><tr><td><em><strong>*# tar -rf all.tar *.gif*</strong></em></td><td>这条命令是将所有.gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。</td><td></td></tr><tr><td><em><strong>*# tar -uf all.tar logo.gif*</strong></em> 这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</td><td></td><td></td></tr><tr><td><em><strong>*# tar -tf all.tar*</strong></em></td><td></td><td>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思</td></tr><tr><td><em><strong>*# tar -xf all.tar*</strong></em></td><td></td><td>这条命令是解出 all.tar 包中所有文件，-t 是解开的意思</td></tr><tr><td>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。 <em><strong>*1) tar*</strong></em> 调用 <em><strong>*gzip*</strong></em>     gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是gunzip。tar 中使用-z 这个参数来调用 gzip。下面来举例说明一下：</td><td></td><td></td></tr><tr><td><em><strong>*# tar -czf all.tar.gz *.jpg*</strong></em></td><td>这条命令是将所有.jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个</td><td></td></tr><tr><td>gzip 压缩过的包，包名为 all.tar.gz</td><td></td><td></td></tr><tr><td><em><strong>*# tar -xzf all.tar.gz*</strong></em></td><td></td><td>这条命令是将上面产生的包解开。</td></tr></tbody></table><p><em><strong>*2) tar*</strong></em> 调用 <em><strong>*bzip2*</strong></em> </p><table><thead><tr><th>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip2。tar 中使用-j 这个参数来调用 gzip。下面来举例说明一下：</th><th></th><th></th></tr></thead><tbody><tr><td><em><strong>*# tar -cjf all.tar.bz2 *.jpg*</strong></em></td><td>这条命令是将所有.jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个</td><td></td></tr><tr><td>bzip2 压缩过的包，包名为 all.tar.bz2</td><td></td><td></td></tr><tr><td><em><strong>*# tar -xjf all.tar.bz2*</strong></em></td><td></td><td>这条命令是将上面产生的包解开。</td></tr><tr><td>下面对于 tar 系列的压缩文件作一个小结：</td><td></td><td></td></tr><tr><td></td><td>1)对于.tar 结尾的文件</td><td></td></tr><tr><td>tar -xf all.tar  2)对于.gz 结尾的文件      gzip -d all.gz      gunzip all.gz  3)对于.tgz 或.tar.gz 结尾的文件      tar -xzf all.tar.gz      tar -xzf all.tgz  4)对于.bz2 结尾的文件      bzip2 -d all.bz2      bunzip2 all.bz2</td><td></td><td></td></tr></tbody></table><p>5)对于 tar.bz2 结尾的文件<br>    tar -xjf all.tar.bz2<br>6)对于.Z 结尾的文件 </p><table><thead><tr><th></th><th></th><th>uncompress all.Z</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>​    7)对于.tar.Z 结尾的文件<br>​        tar -xZf all.tar.z </p><p><em><strong>*Cpio*</strong></em> </p><p>Unzip：解压 zip<br>Gnuzip：解压 bz2 </p><p><em><strong>*十九、*</strong></em> <em><strong>*性能优化*</strong></em> </p><p>1、 设置文件夹打开方式<br>2、 设置屏幕保护时间<br>3、 解除上网限制<br>4、 </p><p><em><strong>*二十、*</strong></em> <em><strong>*常见问题*</strong></em> </p><p>部分网站无法访问问题的解决 </p><table><thead><tr><th>CentOS 5 内核对 TCP 的读缓冲区大小有缺省设置，缺省为：net.ipv4.tcp_rmem = 4096 87380 4194304     解决办法就是将最后一个数字改小一点，具体操作就是在文件/etc/sysctl.conf 中添加一行：      net.ipv4.tcp_rmem = 4096 87380 174760      然后保存      重新启动网络 service network restart,就 OK 了，如果还是部分网站上不去，可以检查/etc/sysctl.conf 文件是否和下面相同      net.ipv4.ip_local_port_range = 1024 65536      net.core.rmem_max=174760</th><th></th><th></th></tr></thead><tbody><tr><td>net.core.wmem_max=16777216</td><td></td><td></td></tr><tr><td>net.ipv4.tcp_rmem=4096 87380 174760      net.ipv4.tcp_wmem=4096 65536 16777216      net.ipv4.tcp_fin_timeout = 15      net.ipv4.tcp_keepalive_time = 600      net.ipv4.tcp_tw_recycle = 1      net.core.netdev_max_backlog = 30000      net.ipv4.tcp_no_metrics_save=1      net.core.somaxconn = 262144      net.ipv4.tcp_syncookies = 1      net.ipv4.tcp_max_orphans = 8000      net.ipv4.tcp_max_syn_backlog = 8000      net.ipv4.tcp_synack_retries = 2      net.ipv4.tcp_syn_retries = 2       net.ipv4.tcp_wmem=4096 65536 16777216 ：为自动调优定义每个 socket 使用的内存。第一个值 4096是为 socket 的发送缓冲区分配的最少字节数。第二个值 65536 是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。第三个值 16777216 是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）</td><td></td><td></td></tr></tbody></table><p>​     net.ipv4.tcp_rmem=4096 87380 174760：与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。<br>​     net.core.rmem_max = 25165824     #定义最大的 TCP/IP 栈的接收窗口大小<br>​            net.core.rmem_default = 25165824  #定义默认的 TCP/IP 栈的接收窗口大小<br>​            net.core.wmem_max = 25165824     #定义最大的 TCP/IP 栈的发送窗口大小<br>​            net.core.wmem_default = 65536     #定义默认的 TCP/IP 栈的发送窗口大小<br>​            net.ipv4.tcp_sack =1         #启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。<br>​            net.ipv4.tcp_window_scaling = 1     #启用 RFC1323 定义，支持超过 64K 窗口<br>​            net.ipv4.tcp_fack =1         #启用转发应答（Forward Acknowledgment），这可以进行有选择应答（SACK）从而减少拥塞情况的发生；这个选项也应该启用。<br>​            net.ipv4.tcp_mem 24576 32768 49152 确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。第一个值是内存使用的下限。第二个值是内存压力模式开始对缓冲区使用应用压力的上限。第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。 </p><p><em><strong>*Centos5*</strong></em> 无法连接无线网络 </p><table><thead><tr><th></th><th>系统－&gt;管理-&gt;服务器设置-&gt;服务，将 NetworkManager 选项勾选，点击重启服务。然后就可以看到右上</th></tr></thead><tbody><tr><td>角已经有了网络连接。</td><td></td></tr></tbody></table><p>****Linux*<em><strong>远程管理</strong></em>*Windows*<em><strong>程序</strong></em>*Rdesktop****详解 </p><table><thead><tr><th></th><th>#rpm –q rdesktop</th><th></th><th>//查找是否已经安装</th></tr></thead><tbody><tr><td>#yum install rdesktop</td><td></td><td>//使用 yum 安装</td><td></td></tr><tr><td>rdesktop 使用简单，windows 也不和装什么服务端，是要把远程桌面共享打开就行了 具体使用方法要先打开终端，然后输入以下命令：  <em><strong>*rdesktop -u yournape -p password -g 1024*720 192.168.0.2*</strong></em></td><td></td><td></td><td></td></tr></tbody></table><p>rdesktop 为使用远程桌面连接的命令；<br>-u 用户名，yourname 处为目标客户端的用户名；<br>-p 客户端用户的密码；<br>-g 指定使用屏幕大小-g 800*600+0+0 这个‘＋0’就是，就是你这个窗口的在你 linux 上出现的位置； 192.168.0.1 目标客户端的 IP 地址 </p><p>实例： </p><p>​    <em><strong>*[root@Centos5 ~]# rdesktop -u aixi -p d337448 -r clipboard:PRIMARYCLIPBOARD -r disk:centos=/root -r sound:local -z -a 16 10.26.11.72*</strong></em> </p><table><thead><tr><th></th><th>$rdesktop 192.168.1.1 //打开了一个 8 位色彩的，      $rdesktop -a 16 192.168.1.1 //这个是 16 位色彩的了，看起来好多了      $rdesktop -u administrator -p ****** -a 16 192.168.1.1 //都直接登陆了      $rdesktop -u administrator -p ****** -a 16 -r sound:local 192.168.1.1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>​    加上-r sound:local 可以把声音也搞过来，-r 的作用挺多的可以重定向许多东西，看一下帮助就会收获不少了。<br>​    -r comport:COM1=/dev/ttyS0 // 将串口 /dev/ttyS0 重定向为 COM1<br>​    -r comport:COM1=/dev/ttyS0,COM2=/dev/ttyS1 // 多个串口重定向<br>​    -r disk:floppy=/mnt/floppy // 将 /mnt/floppy 重定向为远程共享磁盘 ‘floppy’<br>​    -r disk:floppy=/mnt/floppy,cdrom=/mnt/cdrom,root=/,c=/mnt/c // 多个磁盘重定向 </p><p>​        -r clientname= // 为重定向的磁盘设置显示的客户端名称<br>​        -r lptport:LPT1=/dev/lp0 // 将并口 /dev/lp0 重定向为 LPT1<br>​        -r lptport:LPT1=/dev/lp0,LPT2=/dev/lp1 // 多个并口重定向<br>​        -r printer:mydeskjet // 打印机重定向<br>​        -r printer:mydeskjet=”HP LaserJet IIIP” // 打印机重定向<br>​        -r sound:[local|off|remote] // 声音重定向<br>​        -r clipboard:PRIMARYCLIPBOARD : 这个一定要加上，要不然不能在主机 Solaris 和服务器 Windows 直接复制粘贴文字了。贴中文也没有问题。<br>​        -r disk:sunway=/home/jianjian : 指定主机 Solaris 上的一个目录(/home/jianjian)映射到远程 Windows 上的硬盘(盘符为 sunway)，传送文件就不用再靠 Samba 或者 FTP 了。<br>​        -f ：全屏，退出全屏：ctrl＋alt＋enter 再次 Ctrl+Alt+Enter 即可再次进入全屏<br>​        -D：不显示标题栏，配合 -g 能更好地使用屏幕空间了；<br>​        -K： 这个选项说明保持窗口管理器的按键组合绑定；<br>​        -z：启动网络数据的压缩，减少带宽，局域网没什么作用；<br>​        提示：如果你的本地中文文件名在远程机器上显示为乱码的话，可能是你没有安装编码转化库，或者你安装的编码转化库不能正确运行。 </p><p>****Linux*<em><strong>远程访问</strong></em>*Windows****共享目录 </p><p>​        #mount –o username=用户名 –password=密码 //192.168.0.1/C$ /tmp/samba/<br>​        [root@Centos5 ~]# mount -o username=aixi,password=d337448 //10.26.11.72/d$ /root/aixi/<br>​        说明：IP 地址 192.168.0.1 为中文名文件所在的主机，文件位于 C 盘，该主机的用户名及密码为 linux，/tmp/samba/为本地主机挂载目录。在浏览完成后，使用以下命令卸载。<br>​        #umount /tmp/samba/ </p><p>升级或安装程序后无法进入图形界面 </p><table><thead><tr><th></th><th>报错如下：  Failed to start the X server (your graphical interface). lt is likely that it is not set up correctly.  Would you like to view the X server output to diagnose the problem ?  解决办法：</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>#cat /var/log/Xorg.0.log | grep EE</td><td>查看报错日志</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>#sh NVDIA</td><td></td><td></td><td></td><td></td><td></td><td>重新安装显卡驱动</td></tr><tr><td>参考如下网址：  <a href="http://www.linuxquestions.org/questions/linux-hardware-18/failed-to-start-the-x-server-your-graphical-user-interface-605516/">http://www.linuxquestions.org/questions/linux-hardware-18/failed-to-start-the-x-server-your-graphical-user-interface-605516/</a></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>****Linux****自动登陆的设置方法 </p><p>方法一： </p><p>1、设置 GDM<br>GDM 是 GNOME 显示管理器，通过设置其配置文件/etc/gdm/custom.conf 可以设置帐号自动登陆。 设置方法如下：<br>在/etc/gdm/custom.conf 文件中添加以下内容<br>[daemon]<br>AutomaticLogin=username<br>AutomaticLoginEnable=True </p><p>其中，username 是要自动登陆的用户名。<br>说明：username 不能是 root，也就说无法实现 root 的自动登陆。<br>2、设置 prefdm<br>其中，/etc/inittab 文件的最后一行，该行命令的作用是启动 X Windows，而/etc/X11/prefdm 就是具体实现启动 X Windows 的脚本。<br>在/etc/X11/prefdm 中添加启动 X Windows 的命令，并退出。<br>/usr/bin/startx<br>exit 1 </p><p>说明：<br>(1)这两行代码一定要在<br>[ -n “$preferred” ] &amp;&amp; exec $preferred “$@” &gt;/dev/null 2&gt;&amp;1 &lt;/dev/null </p><p>代码之前。<br>(2)该方法自动以 root 登陆，是因为运行到/etc/X11/prefdm 时，是 root 身份。<br>3、在 rc.local 中启动 X Windows<br>在/etc/rc.local 中添加启动 X Windows 的命令<br>/usr/bin/startx<br>说明：该方法自动以 root 登陆，是因为运行到/etc/rc.local 时，是 root 身份。<br>以上做完以上的操作就可以实现 Xwindow 的自动登录 </p><p>方法二： </p><table><thead><tr><th>首先配置自动登录命令行界面  修改/etc/inittab 将 1:2345:respawn:/sbin/mingetty tty1 更改为 1:2345:respawn:/sbin/mingetty tty2 –autologin aixi  再将/etc/inittab 修改为启动到字符界面：id:3:initdefault</th><th></th><th></th></tr></thead><tbody><tr><td>#init q</td><td></td><td>使配置生效</td></tr><tr><td>这样就可以开机自动启动到命令行界面，如果想自动启动到图形界面，其实在此基础上修改如下： 在/etc/rc.local 中添加启动 X Windows 的命令  /usr/bin/startx</td><td></td><td></td></tr></tbody></table><p>这样就可以自动启动到命令行，命令行又自动运行 startx 启动图形界面。这是最简单的一种方式。以上在 Centos5.7 版本中测试通过。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-学习笔记&quot;&gt;&lt;a href=&quot;#Linux-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;*Linux* 学习笔记&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;*Linux*&lt;/strong&gt;&lt;/em&gt; 学习笔记&lt;/h1&gt;&lt;h2 id=&quot;一、-</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="https://qwertyu212.github.io/2023/01/18/%E7%AE%80%E5%8E%86/"/>
    <id>https://qwertyu212.github.io/2023/01/18/%E7%AE%80%E5%8E%86/</id>
    <published>2023-01-18T12:29:16.000Z</published>
    <updated>2023-01-24T10:16:19.175Z</updated>
    
    <content type="html"><![CDATA[<p>1、Windows、Linux操作系统、数据库的使用及常用软件的安装、配置和维护，保证系统稳定运行；</p><p>2、每日登录“易维”平台进行巡检，对有预警的服务器进行预警处理，保证预警的服务器全部恢复正常。并在企业微信群中进行报告，带班领导进行核实。</p><p>3每周进行日常平台巡检，验证平台登陆，功能模块，接口状态等是否正常运行，并在企业微信群进行报告。</p><p>4、每月进行平台服务器深度巡检，必须对所有巡检项目认真负责的操作处理，对于有问题的服务进行及时的处理，并按本部维护部要求上传至服务支撑系统的平台巡检类。</p><p>5、负责公司故障热线，处理公司相关平台的故障问题，帮助用户解决平台使用问题。</p><p>6、处理领导安排的其他日常任务。</p><p>7、根据设备情况，出外勤进行修复，更换。或对新设备进行安装调试。</p><p>8、协助同事完成对房管局项目的维护。</p><p>9、用户端出现的问题，保障视频专网上的快速安检平台正常运行，协助警务站人员进行人脸识别测试，确保人脸识别警情能够正常弹出，每月汇总数据库相关数据并提交。</p><h4 id="新疆分维护运营日常规范"><a href="#新疆分维护运营日常规范" class="headerlink" title="新疆分维护运营日常规范"></a>新疆分维护运营日常规范</h4><p>三张网指挥调度平台       </p><p>一键报警3.0平台   快速安检平台     社区指挥调度平台     数字化警务联动平台</p><h6 id="能力要求："><a href="#能力要求：" class="headerlink" title="能力要求："></a>能力要求：</h6><p>熟悉计算机软硬件、计算机网络设备、操作系统、优化和维护、熟悉监控及理论基础，</p><p>有良好协调能力及团队合作精神及客户服务意识；</p><p>熟悉和善于利用word、excel、ppt、cad等办公工具。</p><p>日报、周报、月报等工作总结及计划的整理及上报；</p><p>负责对各类维护服务数据等相关信息进行汇总，并每月提交业务分析报告；</p><p>配合完成维护项目各业务信息系统硬件设备侧各项工作，包括;系统升级服务、预防性维护、系统调试、软件变更、工程支持服务、资源管理、业务接入调试、业务割接（或调整）实施以及保证接入所必须的其他业务。</p><p>高度的工作责任心，工作认真、细心、 虚心好学、沟通能力强；</p><h4 id="财大"><a href="#财大" class="headerlink" title="财大"></a>财大</h4><p>主修课程：大数据分析与挖掘、操作系统原理、人工智能概论、软件工程学、管理学、python语言、动态网页制作技术、Linux/Unix操作系统、机器学习、移动开发技术、电子商务、新制度经济学等<br>在校经历：在校期间通过学习具备了良好的科学素养，系统地、较好地掌握计算机科学与技术包括计算机硬件、软件与应用的基本理论、基本知识和基本技能与方法，使自己能在教育单位、企业、事业、技术和行政管理部门等单位从事计算机类的工作。<br>毕业设计：校园论坛小程序的设计与实现</p><h4 id="农校"><a href="#农校" class="headerlink" title="农校"></a>农校</h4><p>主修课程：Java程序设计、Android应用程序开发、HTML5语言、Jsp程序设计、Python程序设计、    计算机网络基础、CAD、Linux操作系统、数据库应用技术、数据结构、软件工程学等<br>在校经历：在校期间，完成自己的学业，顺利完成了本科阶段的各门课程，并取得了较好的成绩。使我具备了扎实的基础知识。在信息技术分院的中国移动外呼中心参与勤工俭学当一名 10086 的外呼人员，在这 里我每天都在和不同的客户打交道，虽然刚开始时还有一些不熟悉，但慢慢的努力 下，成为了一位优秀的外呼人员。 同时我也有着丰富的兼职工作经验，当过临时演员，快递包装员，发过传单，在这 些工作中我都收获到了丰富的知识与经验，使我感到非常的快乐。<br>毕业设计：个人博客系统的设计与实现</p><h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4><p>熟悉常见的算法，数据结构。<br> 熟悉Linux 操作系统以及常用shell命令。<br> 熟练使用各种 Office 办公软件。<br> 熟练掌握计算机网络相关基础知识。<br> 熟悉 Java/PHP/CSS/HTML等语言，并具备有良好的编程习惯。<br> 熟悉 CAD 设计的常用命令和其使用技巧，能够熟练的绘制各种图像。<br> 熟悉 Android 代码的编写，能够有效的编写出部分功能。<br> 熟悉 MySQL 基础操作和代码指令，能够使用 SQL 语言明确执行各种操作。</p><p>2.JAVA基础扎实，精通IO、多线程、集合等基础框架，精通分布式、缓存、消息、搜索等机制； 3.精通struts、Spring、Hibernate、MyBatis应用框架； 4.精通HTML、面向对象JavaScript技术，以及框架jQuery/EXT技术； 5.精通apache,nginx,Tomcat等应用服务器的使用，熟悉linux常用命令，可部署系统与分析性能； 6.精通面向对象设计方法和设计模式，逻辑能力佳，熟悉UML设计工具； 7.熟练掌握至少一种数据库Oracle、MySQL,有数据库优化经历者优先；</p><h4 id="校园经历"><a href="#校园经历" class="headerlink" title="校园经历"></a>校园经历</h4><p>在信息技术分院的中国移动外呼中心参与勤工俭学当一名 10086 的外呼人员，在这 里我每天都在和不同的客户打交道，虽然刚开始时还有一些不熟悉，但慢慢的努力 下，成为了一位优秀的外呼人员。 同时我也有着丰富的兼职工作经验，当过临时演员，快递包装员，发过传单，在这 些工作中我都收获到了丰富的知识与经验，使我感到非常的快乐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、Windows、Linux操作系统、数据库的使用及常用软件的安装、配置和维护，保证系统稳定运行；&lt;/p&gt;
&lt;p&gt;2、每日登录“易维”平台进行巡检，对有预警的服务器进行预警处理，保证预警的服务器全部恢复正常。并在企业微信群中进行报告，带班领导进行核实。&lt;/p&gt;
&lt;p&gt;3每</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记录</title>
    <link href="https://qwertyu212.github.io/2023/01/05/%E8%AE%B0%E5%BD%95/"/>
    <id>https://qwertyu212.github.io/2023/01/05/%E8%AE%B0%E5%BD%95/</id>
    <published>2023-01-05T12:31:42.000Z</published>
    <updated>2023-01-12T13:39:20.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a><strong>传统方法学</strong></h1><p>传统方法学又称生命周期方法学或结构化范型。一个软件从开始计划起，到废弃不用 止，称为软件的生命周期。在传统的软件工程方法中，软件的生存周期分为需求分析、总 体设计、详细设计、编程和测试几个阶段。</p><p>把软件生命周期的全过程依次划分为若干个阶 段，然后顺序地完成每个阶段的任务。</p><p>问题定义：要解决什么问题 软件定义 </p><p>可行性研究： 上一阶段所确定的问题是否有行的通的解决办法 </p><p>需求分析：目标系统必须做什么 总体设计：怎样实现目标系统？ </p><p>详细设计： 应该怎样具体地实现这个系统 </p><p>编码和单元测试： 写出正确的容易理解、容易维护的程序模块 </p><p>综合测试 ：通过各种类型的测试、调试使软件达到预定要 求运行维护通过各种必要的维护活动使系统持久 地满足用户的需求。</p><p>1.<strong>问题定义</strong> 问题定义阶段必须回答的关键问题是：“要解决的问题是什么”。通过调研，系统分析员应该提出关于 问题性质、工程目标、和工程规模的书面报告，并且需 要得到容户对这份报告的确认。 </p><p>2.<strong>可行性研究</strong> 这个阶段要回答的关键问题是：“上一个阶段所 确定的问题是否有行得通的解决办法”。系统分析员必 须确定能否以最小的代价最短的时间解决问题为宗旨， 综合技术、经济、社会因素等分析可行性，从而确定工 程可行性。</p><p>3.<strong>需求分析</strong> 这个阶段的任务仍然不是具体地解决客户 的问题，而是准确地回答“目标系统必须 做什么”这个问题。 这个阶段的另外一项重要任务，是用正 式文档准确地记录对目标条统的需求，这 份文档通常称为规格说明(specification)。</p><p>4.<strong>概要设计</strong> 这个阶段的基本任务是，概括地回答“怎样实现目标条 统？”这个问题。概要设计又称为初步设计、逻辑设计、高 层设计或总体设计。 首先，应设计出实现目标系统的几种可能的方亲。 概要设计的另一项主要任务就是设计程序的体象结构， 也就是确定程序由哪些模块组成以及模块间的关象。 </p><p>5.<strong>详细设计</strong> 概要设计阶段以比较抽象概括的方式提出了解决问题的 办法。详细设计阶段的任务就是把解法具体化，也就是回 答“应该怎样具体地实现这个系统”这个关键问题。这个 阶段的任务还不是编写程序，而是设计出程序的详细规格说明。</p><p>6.<strong>编码和单元测试</strong> 这个阶段的关键任务是写出正确的容易 理解、容易维护的程序模块。 </p><p>7.<strong>综合测试</strong> 这个阶段的关键任务是通过各种类型的测 试（及相应的调试）使软件达到预定的要求。</p><p>8.<strong>软件维护</strong> 维护阶段的关键任务是通过各种必要的维护话动 使系统持久地满足用户的要求。通常有以下四类 维护话动。 </p><ul><li>改正性维护：诊断和改正正在使用过程中发 现的软件错误 </li><li>适应性维护：修改软件以适应环境的变化 </li><li>完善性维护：根据用户的要求改进或扩充 软件使它更完善 4)预防性维护：修改软件为将来的维护话动 预先做准备</li></ul><h2 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h2><p>小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。</p><p>网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。</p><p>网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表1-1所示。</p><p>表1-1 小程序的运行环境</p><table><thead><tr><th align="left"><strong>运行环境</strong></th><th align="left"><strong>逻辑层</strong></th><th align="left"><strong>渲染层</strong></th></tr></thead><tbody><tr><td align="left">iOS</td><td align="left">JavaScriptCore</td><td align="left">WKWebView</td></tr><tr><td align="left">安卓</td><td align="left">V8</td><td align="left">chromium定制内核</td></tr><tr><td align="left">小程序开发者工具</td><td align="left">NWJS</td><td align="left">Chrome WebView</td></tr></tbody></table><p>网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。</p><h1 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h1><ol><li><code>.json</code> 后缀的 <code>JSON</code> 配置文件</li><li><code>.wxml</code> 后缀的 <code>WXML</code> 模板文件</li><li><code>.wxss</code> 后缀的 <code>WXSS</code> 样式文件</li><li><code>.js</code> 后缀的 <code>JS</code> 脚本逻辑文件</li></ol><h2 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h2><p>JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。</p><p>我们可以看到在项目的根目录有一个 <code>app.json</code> 和 <code>project.config.json</code>，此外在 <code>pages/logs</code> 目录下还有一个 <code>logs.json</code>，我们依次来说明一下它们的用途。</p><h3 id="小程序配置-app-json"><a href="#小程序配置-app-json" class="headerlink" title="小程序配置 app.json"></a>小程序配置 app.json</h3><p><code>app.json</code> 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 <code>app.json</code> 配置内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;window&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;backgroundTextStyle&quot;</span>:<span class="string">&quot;light&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;navigationBarBackgroundColor&quot;</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;Weixin&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;navigationBarTextStyle&quot;</span>:<span class="string">&quot;black&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单说一下这个配置各个项的含义:</p><ol><li><code>pages</code>字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。</li><li><code>window</code>字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。</li></ol><p>其他配置项细节可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html">小程序的配置 app.json</a> 。</p><h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p>这里说一下小程序里 JSON 配置的一些注意事项。</p><p>JSON文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON的 Key 必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。</p><p>JSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。</p><ol><li>数字，包含浮点数和整数</li><li>字符串，需要包裹在双引号中</li><li>Bool值，true 或者 false</li><li>数组，需要包裹在方括号中 []</li><li>对象，需要包裹在大括号中 {}</li><li>Null</li></ol><p>还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。</p><h2 id="WXML-模板"><a href="#WXML-模板" class="headerlink" title="WXML 模板"></a>WXML 模板</h2><p>从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 <code>HTML</code> 是用来描述当前这个页面的结构，<code>CSS</code> 用来描述页面的样子，<code>JS</code> 通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中 <code>WXML</code> 充当的就是类似 <code>HTML</code> 的角色。打开 <code>pages/index/index.wxml</code>，你会看到以下的内容:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot;</span>&gt;</span> 获取头像昵称 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span> <span class="attr">background-size</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-nickname&quot;</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;usermotto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;user-motto&quot;</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：</p><p>标签名字有点不一样</p><p>往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。</p><p>从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。</p><p>更多详细的组件讲述参考下个章节 小程序的能力</p><p>在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。</p><p>小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。</p><h2 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h2><p><code>WXSS</code> 具有 <code>CSS</code> 大部分的特性，小程序在 <code>WXSS</code> 也做了一些扩充和修改。</p><ol><li>新增了尺寸单位。在写 <code>CSS</code> 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。<code>WXSS</code> 在底层支持新的尺寸单位 <code>rpx</code> ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</li><li>提供了全局的样式和局部样式。和前边 <code>app.json</code>, <code>page.json</code> 的概念相同，你可以写一个 <code>app.wxss</code> 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 <code>page.wxss</code> 仅对当前页面生效。</li><li>此外 <code>WXSS</code> 仅支持部分 <code>CSS</code> 选择器</li></ol><p>更详细的文档可以参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">WXSS</a> 。</p><h2 id="JS-逻辑交互"><a href="#JS-逻辑交互" class="headerlink" title="JS 逻辑交互"></a>JS 逻辑交互</h2><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 <code>JS</code> 脚本文件来处理用户的操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 <code>button</code> 按钮的时候，我们希望把界面上 <code>msg</code> 显示成 <code>&quot;Hello World&quot;</code>，于是我们在 <code>button</code> 上声明一个属性: <code>bindtap</code> ，在 JS 文件里边声明了 <code>clickMe</code> 方法来响应这次点击操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">clickMe</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123; <span class="attr">msg</span>: <span class="string">&quot;Hello World&quot;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>响应用户的操作就是这么简单，更详细的事件可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">WXML - 事件</a> 。</p><p>此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 <code>pages/index/index.js</code> 就调用了 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html">wx.getUserInfo</a> 获取微信用户的头像和昵称，最后通过 <code>setData</code> 把获取到的信息显示到界面上。更多 API 可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html">小程序的API</a> 。</p><h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><p>云函数即在云端（服务器端）运行的函数。在物理设计上，一个云函数可由多个文件组成，占用一定量的 CPU 内存等计算资源；各云函数完全独立；可分别部署在不同的地区。开发者无需购买、搭建服务器，只需编写函数代码并部署到云端即可在小程序端调用，同时云函数之间也可互相调用。</p><p>一个云函数的写法与一个在本地定义的 JavaScript 方法无异，代码运行在云端 Node.js 中。当云函数被小程序端调用时，定义的代码会被放在 Node.js 运行环境中执行。我们可以如在 Node.js 环境中使用 JavaScript 一样在云函数中进行网络请求等操作，而且我们还可以通过云函数后端 SDK 搭配使用多种服务，比如使用云函数 SDK 中提供的数据库和存储 API 进行数据库和存储的操作，这部分可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Database.html">数据库</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/Cloud.uploadFile.html">存储</a>后端 API 文档。</p><p>云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。</p><h2 id="渲染层和逻辑层"><a href="#渲染层和逻辑层" class="headerlink" title="渲染层和逻辑层"></a>渲染层和逻辑层</h2><p>首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p><p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。</p><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png" alt="img"></p><p>有关渲染层和逻辑层的详细文档参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html">小程序框架</a> 。</p><h1 id="逻辑层-App-Service"><a href="#逻辑层-App-Service" class="headerlink" title="逻辑层 App Service"></a>逻辑层 App Service</h1><p>小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</p><p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p><p>在 <code>JavaScript</code> 的基础上，我们增加了一些功能，以方便小程序的开发：</p><ul><li>增加 <code>App</code> 和 <code>Page</code> 方法，进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html">程序注册</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html">页面注册</a>。</li><li>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</li><li>提供丰富的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</li><li>提供<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化</a>能力，每个页面有独立的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>。</li></ul><p><strong>注意：小程序框架的逻辑层并非运行在浏览器中，因此 <code>JavaScript</code> 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等。</strong></p><h1 id="视图层-View"><a href="#视图层-View" class="headerlink" title="视图层 View"></a>视图层 View</h1><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。</p><p>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</p><p>WXML(WeiXin Markup language) 用于描述页面的结构。</p><p>WXS(WeiXin Script) 是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p><p>WXSS(WeiXin Style Sheet) 用于描述页面的样式。</p><p>组件(Component)是视图的基本组成单元。</p><h2 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h2><p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p><p>紧接着通过 <code>app.json</code> 的 <code>pages</code> 字段就可以知道你当前小程序的所有页面路径:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置说明在 QuickStart 项目定义了两个页面，分别位于 <code>pages/index/index</code> 和 <code>pages/logs/logs</code>。而写在 <code>pages</code> 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。</p><p>于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。</p><p>小程序启动之后，在 <code>app.js</code> 定义的 <code>App</code> 实例的 <code>onLaunch</code> 回调会被执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html">注册程序 App</a> 。</p><p>接下来我们简单看看小程序的一个页面是怎么写的。</p><p>你可以观察到 <code>pages/logs/logs</code> 下其实是包括了4种文件的，微信客户端会先根据 <code>logs.json</code> 配置生成一个界面，顶部的颜色和文字你都可以在这个 <code>json</code> 文件里边定义好。紧接着客户端就会装载这个页面的 <code>WXML</code> 结构和 <code>WXSS</code> 样式。最后客户端会装载 <code>logs.js</code>，你可以看到 <code>logs.js</code> 的大体内容就是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="comment">// 参与页面渲染的数据</span></span><br><span class="line">    <span class="attr">logs</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 页面渲染后 执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Page</code> 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 <code>data</code> 数据和 <code>index.wxml</code> 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。</p><p>在渲染完界面之后，页面实例就会收到一个 <code>onLoad</code> 的回调，你可以在这个回调处理你的逻辑。</p><p>有关于 <code>Page</code> 构造器更多详细的文档参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html">注册页面 Page</a> 。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p><p>就像 <code>HTML</code> 的 <code>div</code>, <code>p</code> 等标签一样，在小程序里边，你只需要在 <code>WXML</code> 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">longitude</span>=<span class="string">&quot;广州经度&quot;</span> <span class="attr">latitude</span>=<span class="string">&quot;广州纬度&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 <code>js</code> 编写 <code>markertap</code> 函数来处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">bindmarkertap</span>=<span class="string">&quot;markertap&quot;</span> <span class="attr">longitude</span>=<span class="string">&quot;广州经度&quot;</span> <span class="attr">latitude</span>=<span class="string">&quot;广州纬度&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然你也可以通过 <code>style</code> 或者 <code>class</code> 来控制组件的外层样式，以便适应你的界面宽度高度等等。</p><p>更多的组件可以参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/">小程序的组件</a>。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。</p><p>要获取用户的地理位置时，只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;wgs84&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude = res.latitude <span class="comment">// 纬度</span></span><br><span class="line">    <span class="keyword">var</span> longitude = res.longitude <span class="comment">// 经度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用微信扫一扫能力，只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.scanCode(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</p><p>更多的 API 能力见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html">小程序的API</a>。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p><p>整个小程序框架系统分为两部分：**<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/">逻辑层</a>**（App Service）和 **<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/">视图层</a>**（View）。小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p><h2 id="响应的数据绑定"><a href="#响应的数据绑定" class="headerlink" title="响应的数据绑定"></a>响应的数据绑定</h2><p>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p><p>通过这个简单的例子来看：</p><p><a href="https://developers.weixin.qq.com/s/l0gLEKmv6gZa">在开发者工具中预览效果</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This is our View --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> Hello &#123;&#123;name&#125;&#125;! <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span> Click me! <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// This is our App Service.</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line">  name: &#x27;Weixin&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Register a Page.</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: helloData,</span><br><span class="line">  changeName: function(e) &#123;</span><br><span class="line">    // sent data change to view</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      name: &#x27;MINA&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>开发者通过框架将逻辑层数据中的 <code>name</code> 与视图层的 <code>name</code> 进行了绑定，所以在页面一打开的时候会显示 <code>Hello Weixin!</code>；</li><li>当点击按钮的时候，视图层会发送 <code>changeName</code> 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；</li><li>回调函数触发后，逻辑层执行 <code>setData</code> 的操作，将 <code>data</code> 中的 <code>name</code> 从 <code>Weixin</code> 变为 <code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为 <code>Hello MINA!</code>。</li></ul><h2 id="页面管理"><a href="#页面管理" class="headerlink" title="页面管理"></a>页面管理</h2><p>框架 管理了整个<strong>小程序</strong>的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到 框架 中，其他的一切复杂的操作都交由 框架 处理。</p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>框架 提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的<strong>微信小程序</strong> 。</p><h2 id="丰富的-API"><a href="#丰富的-API" class="headerlink" title="丰富的 API"></a>丰富的 API</h2><p>框架 提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p><p>上海电气（新疆）新能源科技发展有限公司</p><p>生产运维管理部</p><p>1、每天对中控室、继电保护室、高压室、SVG、水泵房进行巡检，并对运行状态进行记录，2、记录每天的的电力数据，对其进行总结，汇报，上报OMS平台；3、对光伏厂区设备进行巡检，将数据上报到风光储蓄平台。4、对平台数据进行监控，保障光伏设备发电正常；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统方法学&quot;&gt;&lt;a href=&quot;#传统方法学&quot; class=&quot;headerlink&quot; title=&quot;传统方法学&quot;&gt;&lt;/a&gt;&lt;strong&gt;传统方法学&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;传统方法学又称生命周期方法学或结构化范型。一个软件从开始计划起，到废弃不用 止，称</summary>
      
    
    
    
    <category term="记录" scheme="https://qwertyu212.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="记录" scheme="https://qwertyu212.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://qwertyu212.github.io/2022/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://qwertyu212.github.io/2022/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-12-19T05:33:57.000Z</published>
    <updated>2023-01-17T12:52:51.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://qwertyu212.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PHP</title>
    <link href="https://qwertyu212.github.io/2021/12/23/PHP/"/>
    <id>https://qwertyu212.github.io/2021/12/23/PHP/</id>
    <published>2021-12-22T16:30:47.000Z</published>
    <updated>2021-12-22T16:39:46.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;查询&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">            h1,form&#123;</span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line">            table&#123;</span><br><span class="line">            margin: auto;</span><br><span class="line">            border: 2px solid blue;</span><br><span class="line">            &#125;</span><br><span class="line">            table&#123;</span><br><span class="line">                margin:auto;</span><br><span class="line">                border:2px solid blue;</span><br><span class="line">            &#125;</span><br><span class="line">            tr:nth-child(odd)&#123;</span><br><span class="line">                background: #ccc;</span><br><span class="line">            &#125;</span><br><span class="line">            tr:nth-child(even)&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">.form01&#123;</span><br><span class="line">margin:auto;</span><br><span class="line">height: 74px;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">function check1()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./insert.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">function check2()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./update.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">function check3()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./delete.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;所有老师信息&lt;/h1&gt;</span><br><span class="line">&lt;div class=&quot;form01&quot;&gt;</span><br><span class="line">&lt;form  action=&#x27;./index.php&#x27; method=&#x27;post&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;text&#x27; name=&#x27;query&#x27;/&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;btnQuery&#x27; value=&#x27;搜索&#x27;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;form action=&#x27;&#x27; method=&#x27;post&#x27; id=&#x27;bd&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;insert&#x27; value=&#x27;新增&#x27; onclick=&#x27;check1()&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;&#x27; value=&#x27;编辑&#x27; onclick=&#x27;check2()&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;delete&#x27; value=&#x27;删除&#x27; onclick=&#x27;check3()&#x27;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;table border=&quot;1&quot; width=&#x27;600px&#x27; style=&#x27;text-align:center;&#x27;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;工号&lt;/td&gt;</span><br><span class="line">&lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;td&gt;出生日期&lt;/td&gt;</span><br><span class="line">&lt;td&gt;所在部门&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$query = $_POST[&#x27;query&#x27;];</span><br><span class="line">//$_SESSION[&#x27;query&#x27;]=&quot;$query&quot;;</span><br><span class="line">$db = new mysqli(&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">if(!$db)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_POST[&#x27;btnQuery&#x27;]) &amp;&amp; $query != null)</span><br><span class="line">&#123;</span><br><span class="line">    //session_start();</span><br><span class="line">$sql=&quot;SELECT laoshi.e_id,laoshi.e_name, laoshi.sex, laoshi.date_birth, bumen.dept_name</span><br><span class="line">from laoshi left join bumen on  bumen.dept_no = laoshi.dept_no WHERE laoshi.e_id = &#x27;$query&#x27; or laoshi.e_name = &#x27;$query&#x27; or bumen.dept_name = &#x27;$query&#x27;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$sql=&quot;SELECT e_id,e_name, sex, date_birth, bumen.dept_name from laoshi left join bumen on bumen.dept_no = laoshi.dept_no&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">$res=$db-&gt;query($sql);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">if($res)&#123;</span><br><span class="line"></span><br><span class="line">    while($row=$res-&gt;fetch_assoc()) &#123;</span><br><span class="line">            $gonghao=$row[&#x27;e_id&#x27;];</span><br><span class="line">            $xingming=$row[&#x27;e_name&#x27;];</span><br><span class="line">            $sex=$row[&#x27;sex&#x27;];</span><br><span class="line">            $shengri=$row[&#x27;date_birth&#x27;];</span><br><span class="line">            $suozaibumen=$row[&#x27;dept_name&#x27;];</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;center&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&#x27;checkbox&#x27; name=&#x27;sel[]&#x27; value=&#x27;&quot;.$row[&quot;e_id&quot;].&quot;&#x27;/&gt;&lt;/td&gt;&lt;/center&gt;&quot;.</span><br><span class="line">&quot;&lt;td&gt;$gonghao&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$xingming&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$sex&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$shengri&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$suozaibumen&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放结果集</span><br><span class="line">$res-&gt;close;</span><br><span class="line">&#125;</span><br><span class="line">//关闭连接</span><br><span class="line">$db-&gt;close();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;新增&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        .css-01 </span><br><span class="line">        &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 50px;</span><br><span class="line">                margin: 200px auto;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function myCheck()</span><br><span class="line">    &#123;//遍历所有表单元素</span><br><span class="line">        for(var i=0;i&lt;document.form1.elements.length-1;i++)</span><br><span class="line">        &#123;//判断所有表单值是否为空</span><br><span class="line">        if(document.form1.elements[i].value==&quot;&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">        alert(&quot;当前表单不能有空项&quot;);</span><br><span class="line">           //将光标定位在空表单处</span><br><span class="line">        document.form1.elements[i].focus();</span><br><span class="line">        return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;css-01&quot;&gt;</span><br><span class="line">        &lt;form action=&quot;./insert.php&quot; name=&quot;form1&quot; method=&quot;post&quot; onSubmit=&quot;return myCheck()&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;id&quot; placeholder=&quot;ID&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;birthday&quot; placeholder=&quot;生日&quot;&gt;</span><br><span class="line">            &lt;?php</span><br><span class="line">                echo &quot;&lt;select name=&#x27;department&#x27;&gt;&quot;;</span><br><span class="line">                $db = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">                $sql = &quot;SELECT * FROM bumen WHERE dept=&#x27;xinguan&#x27;&quot;;</span><br><span class="line">                $db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">                $data = $db-&gt;query($sql);</span><br><span class="line">                if($data)&#123;</span><br><span class="line">                    while($row = $data-&gt;fetch_assoc()) &#123;</span><br><span class="line">                        $bumen_id = $row[&#x27;dept_no&#x27;];</span><br><span class="line">                        $bumen_name = $row[&#x27;dept_name&#x27;];</span><br><span class="line">                        echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27;&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        //echo &quot;&lt;input type=&#x27;text&#x27; name=&#x27;department&#x27; placeholder=&#x27;部门&#x27;&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;/select&gt;&quot;;</span><br><span class="line">            ?&gt;</span><br><span class="line">            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男</span><br><span class="line">            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女</span><br><span class="line">            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;新增&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">            $id = $_POST[&quot;id&quot;];</span><br><span class="line">            $name = $_POST[&quot;name&quot;];</span><br><span class="line">            $sex = $_POST[&quot;sex&quot;];</span><br><span class="line">            $birthday = $_POST[&quot;birthday&quot;];</span><br><span class="line">            $department = $_POST[&quot;department&quot;];</span><br><span class="line">            $db = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">            if(!$db)&#123;</span><br><span class="line">                echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            $mysql = &quot;INSERT INTO laoshi VALUES (&#x27;$id&#x27;,&#x27;$name&#x27;,&#x27;$sex&#x27;,&#x27;$birthday&#x27;,&#x27;$department&#x27;)&quot;;</span><br><span class="line">            mysqli_query($db,&quot;SET NAMES utf8&quot;);</span><br><span class="line">            $data  = mysqli_query($db,$mysql);</span><br><span class="line">            if ($data) &#123;</span><br><span class="line">                echo &quot;&lt;script&gt;alert(&#x27;添加成绩成功&#x27;);this.location.href=&#x27;index.php&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                echo &quot;&lt;script&gt;alert(&#x27;添加成绩失败&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            mysqli_close($db);</span><br><span class="line">        &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;删除&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">    if(count($_POST[&#x27;sel&#x27;]) == 0)&#123;</span><br><span class="line">        echo &quot;&lt;script&gt;alert(&#x27;请先选择需要删除或修改的老师信息!&#x27;);history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $db = new  mysqli (&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">        if(!$db)&#123;</span><br><span class="line">                echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for($i=0;$i&lt;count($_POST[&#x27;sel&#x27;]);$i++)&#123;</span><br><span class="line">            $sqlDel =&quot;DELETE FROM laoshi WHERE e_id=&#x27;&quot;.$_POST[&#x27;sel&#x27;][$i].&quot;&#x27;&quot;;</span><br><span class="line">            $db-&gt;query($sqlDel);</span><br><span class="line">        &#125;</span><br><span class="line">        echo &quot;&lt;script&gt;alert(&#x27;删除成功！&#x27;);window.location=&#x27;index.php&#x27;;&lt;/script&gt;&quot;;</span><br><span class="line">        $db-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Conter-Type&quot; content=&quot;text/html; charset=utf8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;更新&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">    if(count($_POST[&#x27;sel&#x27;])==0 &amp;&amp; !isset($_POST[&#x27;update&#x27;]))  //判断是否选择了要删除的选项，并且没有点击本页面的提交按钮</span><br><span class="line">    &#123; </span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;请先选择需要删除或修改的老师信息!&#x27;);history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $db = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">    if($db-&gt;connect_error)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isset($_POST[&#x27;update&#x27;]))&#123;        //点击按钮执行更新</span><br><span class="line">        $gonghao = $_POST[&quot;text1&quot;];</span><br><span class="line">        $xingming = $_POST[&quot;text2&quot;];</span><br><span class="line">        $shengri = $_POST[&quot;text3&quot;];</span><br><span class="line">        $bumen = $_POST[&quot;department&quot;];</span><br><span class="line">        $sex = $_POST[&quot;sex&quot;];</span><br><span class="line">    </span><br><span class="line">        $sql = &quot;UPDATE laoshi SET e_id=&#x27;$gonghao&#x27;,e_name=&#x27;$xingming&#x27;,sex=&#x27;$sex&#x27;,date_birth=&#x27;$shengri&#x27;,dept_no=&#x27;$bumen&#x27; WHERE e_id=&#x27;$gonghao&#x27;&quot;;</span><br><span class="line">        $db-&gt;query(&#x27;SET NAMES UTF8&#x27;);</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        if ($result) &#123;</span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;更新成功&#x27;);this.location.href=&#x27;index.php&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;更新失败&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;      // 查询要更新的数据</span><br><span class="line">        for($i=0;$i&lt;count($_POST[&#x27;sel&#x27;]);$i++)&#123;</span><br><span class="line">            $sqlDel =&quot;SELECT e_id,e_name, sex, date_birth,dept_no</span><br><span class="line">            FROM laoshi  WHERE e_id=&#x27;&quot;.$_POST[&#x27;sel&#x27;][$i].&quot;&#x27;&quot;;</span><br><span class="line">            $db-&gt;query(&#x27;SET NAMES UTF8&#x27;);</span><br><span class="line">            $res=$db-&gt;query($sqlDel);</span><br><span class="line">        if($res)&#123;</span><br><span class="line">                while($row=$res-&gt;fetch_assoc()) </span><br><span class="line">                &#123;</span><br><span class="line">                    $gonghao=$row[&#x27;e_id&#x27;];</span><br><span class="line">                    $xingming=$row[&#x27;e_name&#x27;];</span><br><span class="line">                    $sex=$row[&#x27;sex&#x27;];</span><br><span class="line">                    $shengri=$row[&#x27;date_birth&#x27;];</span><br><span class="line">                    $suozaibumen=$row[&#x27;dept_no&#x27;];</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;form action=&#x27;./update.php&#x27; method=&#x27;post&#x27;&gt;&quot;;</span><br><span class="line">                echo  &quot;&lt;div style=&#x27;margin: 200px auto;width: 100px;height: 50px;&#x27;&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;工号&#x27; name=&#x27;text1&#x27; value=&#x27;$gonghao&#x27; readonly=&#x27;readonly&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;姓名&#x27; name=&#x27;text2&#x27; value=&#x27;$xingming&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;生日&#x27; name=&#x27;text3&#x27; value=&#x27;$shengri&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;&quot;;</span><br><span class="line">                 // 下拉框</span><br><span class="line">                echo &quot;&lt;select name=&#x27;department&#x27;&gt;&quot;;</span><br><span class="line">                $sql = &quot;SELECT * FROM bumen WHERE dept=&#x27;xinguan&#x27;&quot;;</span><br><span class="line">                $db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">                $data = $db-&gt;query($sql);</span><br><span class="line">                if($data)&#123;</span><br><span class="line">                    while($row = $data-&gt;fetch_assoc()) &#123;</span><br><span class="line">                        $bumen_id = $row[&#x27;dept_no&#x27;];</span><br><span class="line">                        $bumen_name = $row[&#x27;dept_name&#x27;];</span><br><span class="line">                        if($bumen_id == $suozaibumen)&#123;</span><br><span class="line">                            echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27; selected&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27;&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;/select&gt;&quot;;</span><br><span class="line"></span><br><span class="line">                if($sex == &quot;男&quot;)</span><br><span class="line">                &#123;  </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;男&#x27; checked&gt;男&quot;; </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;女&#x27;&gt;女&quot;; </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                &#123; </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;男&#x27;&gt;男&quot;;</span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;女&#x27; checked&gt;女&quot;; </span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo &quot;&lt;input type=&#x27;submit&#x27; name=&#x27;update&#x27; value=&#x27;提交&#x27;&gt;&quot;; </span><br><span class="line">                echo &quot;&lt;/div&gt;&quot;;</span><br><span class="line">            echo &quot;&lt;/form&gt;&quot;;</span><br><span class="line">            //释放结果集</span><br><span class="line">            $res-&gt;close;</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭连接  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    $db-&gt;close();</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="双色球"><a href="#双色球" class="headerlink" title="双色球"></a>双色球</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;双色球&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 50px;</span><br><span class="line">        float: left;</span><br><span class="line">        margin: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .red&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    .blue&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">    $num=range(1,10);//生成数组</span><br><span class="line">    $red=array_rand($num,4);//随机选多少个数</span><br><span class="line">    shuffle($red); //打乱数组</span><br><span class="line">    $blue=rand(1,10);//生成随机数</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;div class=&#x27;blue&#x27;&gt;$blue&lt;/div&gt;&quot;;</span><br><span class="line"></span><br><span class="line">    foreach($red as &amp;$value)&#123;</span><br><span class="line">        echo &quot;&lt;div class=&#x27;red&#x27;&gt;$value&lt;/div&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="空心菱形"><a href="#空心菱形" class="headerlink" title="空心菱形"></a>空心菱形</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    //$n=5;</span><br><span class="line">    for($i=1;$i&lt;=5;$i++)&#123;</span><br><span class="line">        //打印空格</span><br><span class="line">        for($j=1;$j&lt;=5-$i;$j++)&#123;</span><br><span class="line">            echo &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //打印*号</span><br><span class="line">        for($k=1;$k&lt;=2*$i-1;$k++)&#123;</span><br><span class="line">        //打印第一行后最后一行都打*连接($i==1 || $i==5) </span><br><span class="line">            if($i==1)&#123; //去掉$i==5 把中间抛空</span><br><span class="line">                echo &quot;*&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //怎么打空格和*号的问题</span><br><span class="line">                if($k==1 || $k==2*$i-1)&#123;</span><br><span class="line">                    echo &quot;*&quot;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    echo &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //倒转 抛空</span><br><span class="line">    for($i=5;$i&gt;=0;$i--)&#123;</span><br><span class="line">        //打印空格</span><br><span class="line">        for($j=0;$j&lt;=5-$i;$j++)&#123;</span><br><span class="line">            echo &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //打印*号</span><br><span class="line">        for($k=1;$k&lt;=2*$i-3;$k++)&#123;</span><br><span class="line">            //怎么打空格和*号的问题</span><br><span class="line">            if($k==2*$i-3 || $k==1)&#123;</span><br><span class="line">                echo &quot;*&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                echo &quot; &quot;;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;form action=&quot;./denglu.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;用户名&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">if(isset($_POST[&quot;submit&quot;]))&#123;</span><br><span class="line">$db = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;teacher&quot;);</span><br><span class="line">if(!$db)&#123;</span><br><span class="line">echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$name = $_POST[&quot;name&quot;];</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line">$sql = &quot;SELECT * FROM user WHERE name=&#x27;$name&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">mysqli_query($db,&quot;SET NAMES utf8&quot;);</span><br><span class="line">$data = mysqli_query($db,$sql);</span><br><span class="line">$row=mysqli_num_rows($data);</span><br><span class="line">if($row)&#123;</span><br><span class="line">echo &quot;登录成功。&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;账号密码错误！！!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查询&quot;&gt;&lt;a href=&quot;#查询&quot; class=&quot;headerlink&quot; title=&quot;查询&quot;&gt;&lt;/a&gt;查询&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PHP" scheme="https://qwertyu212.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>随记</title>
    <link href="https://qwertyu212.github.io/2021/12/14/%E9%9A%8F%E8%AE%B0/"/>
    <id>https://qwertyu212.github.io/2021/12/14/%E9%9A%8F%E8%AE%B0/</id>
    <published>2021-12-14T03:52:13.000Z</published>
    <updated>2023-01-18T13:27:03.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo常用命令详解"><a href="#Hexo常用命令详解" class="headerlink" title="Hexo常用命令详解"></a><a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a>常用命令详解</h2><h3 id="1、hexo-init"><a href="#1、hexo-init" class="headerlink" title="1、hexo init"></a>1、hexo init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init 命令用于初始化一个本地文件夹为网站的根目录</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="2、hexo-new"><a href="#2、hexo-new" class="headerlink" title="2、hexo new"></a>2、hexo new</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new title 新建一篇文章</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="3、hexo-generate"><a href="#3、hexo-generate" class="headerlink" title="3、hexo generate"></a>3、hexo generate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate 可以简写成 hexo g</span><br><span class="line">该命令用于生成静态文件</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="4、hexo-server"><a href="#4、hexo-server" class="headerlink" title="4、hexo server"></a>4、hexo server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s</span><br><span class="line">可以加一些参数</span><br><span class="line">-p    选项，指定服务器端口，默认为 4000</span><br><span class="line">-i    选项，指定服务器 IP 地址，默认为 0.0.0.0</span><br><span class="line">-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><h3 id="5、hexo-deploy"><a href="#5、hexo-deploy" class="headerlink" title="5、hexo deploy"></a>5、hexo deploy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="6、hexo-clean"><a href="#6、hexo-clean" class="headerlink" title="6、hexo clean"></a>6、hexo clean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="7、hexo-–safe"><a href="#7、hexo-–safe" class="headerlink" title="7、hexo –safe"></a>7、hexo –safe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe 表示安全模式，用于禁用加载插件和脚本</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="8、hexo-–debug"><a href="#8、hexo-–debug" class="headerlink" title="8、hexo –debug"></a>8、hexo –debug</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="9、hexo-–silent"><a href="#9、hexo-–silent" class="headerlink" title="9、hexo –silent"></a>9、hexo –silent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent  表示静默模式，用于静默输出到终端</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hexo常用命令详解&quot;&gt;&lt;a href=&quot;#Hexo常用命令详解&quot; class=&quot;headerlink&quot; title=&quot;Hexo常用命令详解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Hexo&amp;spm=1001.2</summary>
      
    
    
    
    <category term="随记" scheme="https://qwertyu212.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://qwertyu212.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>测试四</title>
    <link href="https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E5%9B%9B/"/>
    <id>https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E5%9B%9B/</id>
    <published>2021-12-11T15:25:11.000Z</published>
    <updated>2021-12-12T01:39:27.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-NexT主题内加入动态背景"><a href="#Hexo-NexT主题内加入动态背景" class="headerlink" title="Hexo NexT主题内加入动态背景"></a><a href="https://www.cnblogs.com/brady-wang/p/11304530.html">Hexo NexT主题内加入动态背景</a></h1><p>主题内新添加内容</p><h1 id="layout-swig"><a href="#layout-swig" class="headerlink" title="_layout.swig"></a>_layout.swig</h1><p>找到<code>themes\next\layout\_layout.swig</code>文件，添加内容：<br>在<code>&lt;body&gt;</code>里添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg_content&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仍是该文件，在末尾添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/dynamic_bg.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="dynamic-bg-js"><a href="#dynamic-bg-js" class="headerlink" title="dynamic_bg.js"></a>dynamic_bg.js</h1><p>在<code>themes\next\source\js\src</code>中新建文件<code>dynamic_bg.js</code>，代码链接中可见：<a href="https://github.com/asdfv1929/asdfv1929.github.io/blob/master/js/src/dynamic_bg.js">dynamic_bg.js</a></p><h1 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a>custom.styl</h1><p>在<code>themes\next\source\css\_custom\custom.styl</code>文件末尾添加内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg_content</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="●-添加背景动态彩带效果"><a href="#●-添加背景动态彩带效果" class="headerlink" title="● 添加背景动态彩带效果"></a>● 添加背景动态彩带效果</h2><p>样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带：</p><p><img src="https://pic1.zhimg.com/80/v2-b2ce46e5efeebd6b68a6cdce80de032c_720w.jpg" alt="img"></p><p>实现方法：在 \themes\material-x\layout\layout.ejs 文件的body前面添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 样式一（鼠标点击更换样式） --&gt;</span><br><span class="line">&lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 样式二（飘动的彩带） --&gt;</span><br><span class="line">&lt;script src=&quot;https://g.joyinshare.com/hc/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="●-添加背景代码雨特效"><a href="#●-添加背景代码雨特效" class="headerlink" title="● 添加背景代码雨特效"></a>● 添加背景代码雨特效</h2><p>新建 <code>DigitalRain.js</code>，写入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取画布对象</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">    <span class="comment">//获取画布的上下文</span></span><br><span class="line">    <span class="keyword">var</span> context =canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">window</span>.screen;</span><br><span class="line">    <span class="keyword">var</span> W = canvas.width = s.width;</span><br><span class="line">    <span class="keyword">var</span> H = canvas.height;</span><br><span class="line">    <span class="comment">//获取浏览器屏幕的宽度和高度</span></span><br><span class="line">    <span class="comment">//var W = window.innerWidth;</span></span><br><span class="line">    <span class="comment">//var H = window.innerHeight;</span></span><br><span class="line">    <span class="comment">//设置canvas的宽度和高度</span></span><br><span class="line">    canvas.width = W;</span><br><span class="line">    canvas.height = H;</span><br><span class="line">    <span class="comment">//每个文字的字体大小</span></span><br><span class="line">    <span class="keyword">var</span> fontSize = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//计算列</span></span><br><span class="line">    <span class="keyword">var</span> colunms = <span class="built_in">Math</span>.floor(W /fontSize);  </span><br><span class="line">    <span class="comment">//记录每列文字的y轴坐标</span></span><br><span class="line">    <span class="keyword">var</span> drops = [];</span><br><span class="line">    <span class="comment">//给每一个文字初始化一个起始点的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;colunms;i++)&#123;</span><br><span class="line">        drops.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运动的文字</span></span><br><span class="line">    <span class="keyword">var</span> str =<span class="string">&quot;WELCOME TO WWW.ITRHX.COM&quot;</span>;</span><br><span class="line">    <span class="comment">//4:fillText(str,x,y);原理就是去更改y的坐标位置</span></span><br><span class="line">    <span class="comment">//绘画的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context.fillStyle = <span class="string">&quot;rgba(238,238,238,.08)&quot;</span>;<span class="comment">//遮盖层</span></span><br><span class="line">        context.fillRect(<span class="number">0</span>,<span class="number">0</span>,W,H);</span><br><span class="line">        <span class="comment">//给字体设置样式</span></span><br><span class="line">        context.font = <span class="string">&quot;600 &quot;</span>+fontSize+<span class="string">&quot;px  Georgia&quot;</span>;</span><br><span class="line">        <span class="comment">//给字体添加颜色</span></span><br><span class="line">        context.fillStyle = [<span class="string">&quot;#33B5E5&quot;</span>, <span class="string">&quot;#0099CC&quot;</span>, <span class="string">&quot;#AA66CC&quot;</span>, <span class="string">&quot;#9933CC&quot;</span>, <span class="string">&quot;#99CC00&quot;</span>, <span class="string">&quot;#669900&quot;</span>, <span class="string">&quot;#FFBB33&quot;</span>, <span class="string">&quot;#FF8800&quot;</span>, <span class="string">&quot;#FF4444&quot;</span>, <span class="string">&quot;#CC0000&quot;</span>][<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10</span>)];<span class="comment">//randColor();可以rgb,hsl, 标准色，十六进制颜色</span></span><br><span class="line">        <span class="comment">//写入画布中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;colunms;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * str.length);</span><br><span class="line">            <span class="keyword">var</span> x = i*fontSize;</span><br><span class="line">            <span class="keyword">var</span> y = drops[i] *fontSize;</span><br><span class="line">            context.fillText(str[index],x,y);</span><br><span class="line">            <span class="comment">//如果要改变时间，肯定就是改变每次他的起点</span></span><br><span class="line">            <span class="keyword">if</span>(y &gt;= canvas.height &amp;&amp; <span class="built_in">Math</span>.random() &gt; <span class="number">0.99</span>)&#123;</span><br><span class="line">                drops[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            drops[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">randColor</span>(<span class="params"></span>)</span>&#123;<span class="comment">//随机颜色</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">    <span class="built_in">setInterval</span>(draw,<span class="number">35</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\themes\material-x-1.2.1\source\less_main.less 文件末尾）添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主题的 <a href="https://www.zhihu.com/search?q=layout.ejs&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:69211731%7D">layout.ejs</a> 文件中引入即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数字雨 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1440&quot;</span> <span class="attr">height</span>=<span class="string">&quot;900&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/DigitalRain.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果：</p><p><img src="https://pic3.zhimg.com/80/v2-179064aa7d24fcbc0eabc4e4125a65c6_720w.jpg" alt="img"></p><p>代码来源：<a href="https://link.zhihu.com/?target=http://www.lxl8800.cn/Main/Resource">http://www.lxl8800.cn/Main/Resourc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-NexT主题内加入动态背景&quot;&gt;&lt;a href=&quot;#Hexo-NexT主题内加入动态背景&quot; class=&quot;headerlink&quot; title=&quot;Hexo NexT主题内加入动态背景&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com</summary>
      
    
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试三</title>
    <link href="https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%B8%89/"/>
    <id>https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%B8%89/</id>
    <published>2021-12-11T14:56:43.000Z</published>
    <updated>2021-12-12T01:40:17.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="美化-特效"><a href="#美化-特效" class="headerlink" title="美化/特效"></a>美化/特效</h2><h3 id="自定义主题色"><a href="#自定义主题色" class="headerlink" title="自定义主题色"></a>自定义主题色</h3><p>可以修改大部分UI颜色</p><p>修改 <code>主题配置文件</code>，比如：</p><blockquote><p>颜色值必须被双引号包裹，就像<code>&quot;#000&quot;</code>而不是<code>#000</code>。否则将会在构建的时候报错！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">theme_color:</span><br><span class="line">  enable: true</span><br><span class="line">  main: &quot;#49B1F5&quot;</span><br><span class="line">  paginator: &quot;#00c4b6&quot;</span><br><span class="line">  button_hover: &quot;#FF7242&quot;</span><br><span class="line">  text_selection: &quot;#00c4b6&quot;</span><br><span class="line">  link_color: &quot;#99a9bf&quot;</span><br><span class="line">  meta_color: &quot;#858585&quot;</span><br><span class="line">  hr_color: &quot;#A4D8FA&quot;</span><br><span class="line">  code_foreground: &quot;#F47466&quot;</span><br><span class="line">  code_background: &quot;rgba(27, 31, 35, .05)&quot;</span><br><span class="line">  toc_color: &quot;#00c4b6&quot;</span><br><span class="line">  blockquote_padding_color: &quot;#49b1f5&quot;</span><br><span class="line">  blockquote_background_color: &quot;#49b1f5&quot;</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_1.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_1.png" alt="img"></a><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_2.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-color_2.png" alt="img"></a></p><h3 id="网站背景"><a href="#网站背景" class="headerlink" title="网站背景"></a>网站背景</h3><p>默认显示白色，可设置图片或者颜色</p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># 图片格式 url(http://xxxxxx.com/xxx.jpg)</span><br><span class="line"># 颜色（HEX值/RGB值/顔色单词/渐变色)</span><br><span class="line"># 留空 不显示背景</span><br><span class="line">background:</span><br></pre></td></tr></table></figure><p><em>留意:</em> 如果你的网站根目录不是’/‘,使用本地图片时，需加上你的根目录。<br>例如：网站是 <code>https://yoursite.com/blog</code>,引用一张<code>img/xx.png</code>图片，则设置background为 `url(/blog/img/xx.png)</p><blockquote><p>background:’#49B202’</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-color.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-color.png" alt="img"></a></p><blockquote><p>background: url(<a href="https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png">https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png</a>)</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-img.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-set-body-background-img.png" alt="img"></a></p><h3 id="footer-背景"><a href="#footer-背景" class="headerlink" title="footer 背景"></a>footer 背景</h3><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># footer是否显示图片背景(与top_img一致)</span><br><span class="line">footer_bg: true</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置的值</th><th>效果</th></tr></thead><tbody><tr><td>留空/false</td><td>显示默认的顔色</td></tr><tr><td>img链接</td><td>图片的链接，显示所配置的图片</td></tr><tr><td>顔色( HEX值 - #0000FF RGB值 - rgb(0,0,255) 顔色单词 - orange 渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%) ）</td><td>对应的顔色</td></tr><tr><td>true</td><td>显示跟 top_img 一样</td></tr></tbody></table><blockquote><p>true</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-img.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-img.png" alt="img"></a></p><h3 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a>打字效果</h3><p>打字效果<a href="https://github.com/disjukr/activate-power-mode">activate-power-mode</a></p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Typewriter Effect (打字效果)</span><br><span class="line"># https://github.com/disjukr/activate-power-mode</span><br><span class="line">activate_power_mode:</span><br><span class="line">  enable: true</span><br><span class="line">  colorful: true # open particle animation (冒光特效)</span><br><span class="line">  shake: true #  open shake (抖动特效)</span><br><span class="line">  mobile: false</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-type-animation.gif"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-type-animation.gif" alt="img"></a></p><h3 id="背景特效"><a href="#背景特效" class="headerlink" title="背景特效"></a>背景特效</h3><ul><li>静止綵带</li><li>动态綵带</li><li>canvas-nest</li></ul><p>好看的綵带背景，可设置每次刷新更换綵带，或者每次点击更换綵带<br>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br><span class="line">  size: 150</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br><span class="line">  click_to_change: false  #设置是否每次点击都更换綵带</span><br><span class="line">  mobile: false # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><p>相关配置可查看<a href="https://github.com/hustcc/ribbon.js">canvas_ribbon</a></p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-canvas-ribbon.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-canvas-ribbon.png" alt="img"></a></p><h3 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h3><ul><li>烟花</li><li>爱心</li><li>文字</li></ul><p><code>zIndex</code>建议只在<code>-1</code>和<code>9999</code>上选<br><code>-1</code> 代表烟火效果在底部<br><code>9999</code> 代表烟火效果在前面</p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">fireworks:</span><br><span class="line">  enable: true</span><br><span class="line">  zIndex: 9999 # -1 or 9999</span><br><span class="line">  mobile: false</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-firewall.gif"><img src="https://butterfly.js.org/img/loading.gif" alt="img"></a></p><h3 id="页面美化"><a href="#页面美化" class="headerlink" title="页面美化"></a>页面美化</h3><p>会改变ol、ul、h1-h5的样式</p><p><code>field</code>配置生效的区域</p><ul><li><code>post</code> 只在文章页生效</li><li><code>site</code> 在全站生效</li></ul><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># 美化页面显示</span><br><span class="line">beautify:</span><br><span class="line">  enable: true</span><br><span class="line">  field: site # site/post</span><br><span class="line">  title-prefix-icon: &#x27;\f0c1&#x27;</span><br><span class="line">  title-prefix-icon-color: &quot;#F47466&quot;</span><br></pre></td></tr></table></figure><p><code>title-prefix-icon</code>填写的是fontawesome的icon的Unicode数。<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-fontwesome-unicode.png"><img src="https://butterfly.js.org/img/loading.gif" alt="img"></a></p><blockquote><p>未开启美化</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautify.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautify.png" alt="img"></a></p><blockquote><p>开启美化</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautif.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-beautif.png" alt="img"></a></p><h3 id="自定义字体和字体大小"><a href="#自定义字体和字体大小" class="headerlink" title="自定义字体和字体大小"></a>自定义字体和字体大小</h3><h4 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h4><p>可自行设置字体的<code>font-family</code><br><strong>如不需要配置，请留空</strong></p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Global font settings</span><br><span class="line"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span><br><span class="line">font:</span><br><span class="line">  global-font-size:</span><br><span class="line">  code-font-size:</span><br><span class="line">  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Helvetica Neue&quot;, Lato, Roboto, &quot;PingFang SC&quot;, &quot;Microsoft JhengHei&quot;, &quot;Microsoft YaHei&quot;, sans-serif</span><br><span class="line">  code-font-family: consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft JhengHei&quot;, &quot;Microsoft YaHei&quot;, sans-serif</span><br></pre></td></tr></table></figure><h4 id="Blog-标题字体"><a href="#Blog-标题字体" class="headerlink" title="Blog 标题字体"></a>Blog 标题字体</h4><p>可自行设置字体的<code>font-family</code><br><strong>如不需要配置，请留空。</strong><br><strong>如不需要使用网络字体，只需要把font_link留空就行</strong></p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Font settings for the site title and site subtitle</span><br><span class="line"># 左上角网站名字 主页居中网站名字</span><br><span class="line">blog_title_font:</span><br><span class="line">  font_link: https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap</span><br><span class="line">  font-family: Titillium Web, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Microsoft JhengHei&#x27;, &#x27;Microsoft YaHei&#x27;, sans-serif</span><br></pre></td></tr></table></figure><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h3><p>可设置主页中显示的网站副标题或者喜欢的座右铭。</p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"></span><br><span class="line"># 主页subtitle</span><br><span class="line">subtitle:</span><br><span class="line">  enable: true</span><br><span class="line">  # 打字效果</span><br><span class="line">  effect: true</span><br><span class="line">  # 循环或者只打字一次</span><br><span class="line">  loop: false</span><br><span class="line">  # source调用第三方服务</span><br><span class="line">  # source: false 关闭调用</span><br><span class="line">  # source: 1  调用搏天api的随机语录（简体） </span><br><span class="line">  # source: 2  调用一言网的一句话（简体） </span><br><span class="line">  # source: 3  调用一句网（简体） </span><br><span class="line">  # source: 4  调用今日诗词（简体</span><br><span class="line">  # subtitle 会先显示 source , 再显示 sub 的内容</span><br><span class="line">  source: false</span><br><span class="line">  # 如果有英文逗号&#x27; , &#x27;,请使用转义字元 &amp;#44;</span><br><span class="line">  # 如果有英文双引号&#x27; &quot; &#x27;,请使用转义字元 &amp;quot;</span><br><span class="line">  # 开头不允许转义字元，如需要，请把整个句子用双引号包住</span><br><span class="line">  # 例如 ”&amp;quotNever put off till tomorrow what you can do today&amp;quot&quot;</span><br><span class="line">  # 如果关闭打字效果，subtitle只会显示sub的第一行文字</span><br><span class="line">  sub:</span><br><span class="line">    - 今日事&amp;#44;今日毕</span><br><span class="line">    - Never put off till tomorrow what you can do today</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-index-subtitle.gif"><img src="https://butterfly.js.org/img/loading.gif" alt="img"></a></p><h3 id="主页top-img显示大小"><a href="#主页top-img显示大小" class="headerlink" title="主页top_img显示大小"></a>主页top_img显示大小</h3><blockquote><p>适用于 版本号 &gt;= V1.2.0</p></blockquote><p>默认的显示为全屏。site-info的区域会居中显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># 主页设置</span><br><span class="line"># 默认top_img全屏，site_info在中间</span><br><span class="line"># 使用默认, 都无需填写（建议默认）</span><br><span class="line">index_site_info_top: # 主页标题距离顶部距离  例如 300px/300em/300rem/10%</span><br><span class="line">index_top_img_height:  #主页top_img高度 例如 300px/300em/300rem  不能使用百分比</span><br></pre></td></tr></table></figure><p>注意：<code>index_top_img_height</code>的值不能使用百分比。<br>2个都不填的话，会使用默认值</p><p>举例，当</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">index_top_img_height: 400px</span><br></pre></td></tr></table></figure><p>效果</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-index-top-img-setting.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-index-top-img-setting.png" alt="img"></a></p><h3 id="页面加载动画preloader"><a href="#页面加载动画preloader" class="headerlink" title="页面加载动画preloader"></a>页面加载动画preloader</h3><p>当进入网页时，因为加载速度的问题，可能会导致top_img图片出现断层显示，或者网页加载不全而出现等待时间，开启preloader后，会显示加载动画，等页面加载完，加载动画会消失。</p><p>配置<code>butterly.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># 加载动画 Loading Animation</span><br><span class="line">preloader: true</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-preloader.gif"><img src="https://butterfly.js.org/img/loading.gif" alt="img"></a></p><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>要为<code>Butterfly</code>配上 PWA 特性, 你需要如下几个步骤:</p><ol><li>打开 hexo 工作目录</li><li><code>npm install hexo-offline --save</code> 或者 <code>yarn add hexo-offline</code></li><li>在根目录创建 <code>hexo-offline.config.cjs</code> 文件，并增加以下内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">// offline config passed to workbox-build.</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  globPatterns: [&#x27;**/*.&#123;js,html,css,png,jpg,gif,svg,webp,eot,ttf,woff,woff2&#125;&#x27;],</span><br><span class="line">  // 静态文件合集，如果你的站点使用了例如 webp 格式的文件，请将文件类型添加进去。</span><br><span class="line">  globDirectory: &#x27;public&#x27;,</span><br><span class="line">  swDest: &#x27;public/service-worker.js&#x27;,</span><br><span class="line">  maximumFileSizeToCacheInBytes: 10485760, // 缓存的最大文件大小，以字节为单位。</span><br><span class="line">  skipWaiting: true,</span><br><span class="line">  clientsClaim: true,</span><br><span class="line">  runtimeCaching: [ // 如果你需要加载 CDN 资源，请配置该选项，如果没有，可以不配置。</span><br><span class="line">    // CDNs - should be CacheFirst, since they should be used specific versions so should not change</span><br><span class="line">    &#123;</span><br><span class="line">      urlPattern: /^https:\/\/cdn\.example\.com\/.*/, // 可替换成你的 URL</span><br><span class="line">      handler: &#x27;CacheFirst&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容请查看 <a href="https://github.com/JLHwung/hexo-offline">hexo-offline</a>的官方文档</p><ol><li>在<code>主题配置文件</code>中开启 pwa 选项。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">pwa:</span><br><span class="line">  enable: true</span><br><span class="line">  manifest: /img/pwa/manifest.json</span><br><span class="line">  apple_touch_icon: /img/pwa/apple-touch-icon.png</span><br><span class="line">  favicon_32_32: /img/pwa/32.png</span><br><span class="line">  favicon_16_16: /img/pwa/16.png</span><br><span class="line">  mask_icon: /img/pwa/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure><ol><li>在创建<code>source/</code>目录中创建<code>manifest.json</code>文件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">JSON</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;short_name&quot;: &quot;Junzhou&quot;,</span><br><span class="line">    &quot;theme_color&quot;: &quot;#49b1f5&quot;,</span><br><span class="line">    &quot;background_color&quot;: &quot;#49b1f5&quot;,</span><br><span class="line">    &quot;display&quot;: &quot;standalone&quot;,</span><br><span class="line">    &quot;scope&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;start_url&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;icons&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/36.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;36x36&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images/pwaicons/48.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/72.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/96.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/144.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images/pwaicons/192.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images/pwaicons/512.png&quot;,</span><br><span class="line">            &quot;sizes&quot;: &quot;512x512&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;image/png&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;splash_pages&quot;: null</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>你也可以通过 <a href="https://app-manifest.firebaseapp.com/">Web App Manifest</a>快速创建<code>manifest.json</code>。（Web App Manifest 要求至少包含一个 512*512 像素的图标）</p><ol><li><p>可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chrome</span><br></pre></td></tr></table></figure><p>插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lighthouse</span><br></pre></td></tr></table></figure><p>检查 PWA 配置是否生效以及配置是否正确。</p><ul><li>打开博客页面</li><li>启动<code>Lighthouse</code>插件 (<code>Lighthouse</code>插件要求至少包含一个 512*512 像素的图标)</li></ul></li></ol><p>关于 PWA（渐进式增强 Web 应用）的更多内容请参閲 <a href="https://developers.google.com/web/tools/lighthouse/audits/address-bar">Google Tools for Web Developers</a></p><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>要为<code>Butterfly</code>配上字数统计特性, 你需要如下几个步骤:</p><ol><li>打开 hexo 工作目录</li><li><code>npm install hexo-wordcount --save</code> or <code>yarn add hexo-wordcount</code></li><li>修改 <code>主题配置文件</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">wordcount:</span><br><span class="line">  enable: true</span><br><span class="line">  post_wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  total_wordcount: true</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-word-count.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-word-count.png" alt="img"></a><br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-wordcount-totalcount.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-wordcount-totalcount.png" alt="img"></a></p><h2 id="图片大图查看模式"><a href="#图片大图查看模式" class="headerlink" title="图片大图查看模式"></a>图片大图查看模式</h2><p>只能开启一个</p><ul><li>fancybox</li><li>medium_zoom</li></ul><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># fancybox http://fancyapps.com/fancybox/3/</span><br><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/fancybox.gif"><img src="https://butterfly.js.org/img/loading.gif" alt="fancybox.gif"></a></p><h2 id="Snackbar-弹窗"><a href="#Snackbar-弹窗" class="headerlink" title="Snackbar 弹窗"></a>Snackbar 弹窗</h2><p>Snackbar 弹窗,根据自己爱好开启</p><p>修改 <code>主题配置文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Snackbar 弹窗</span><br><span class="line"># https://github.com/polonel/SnackBar</span><br><span class="line"># position 弹窗位置</span><br><span class="line"># 可选 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right</span><br><span class="line">snackbar:</span><br><span class="line">  enable: true</span><br><span class="line">  position: bottom-left</span><br><span class="line">  bg_light: &#x27;#49b1f5&#x27; #light mode时弹窗背景</span><br><span class="line">  bg_dark: &#x27;#2d3035&#x27; #dark mode时弹窗背景</span><br></pre></td></tr></table></figure><blockquote><p>未开启Snackbar</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/snackbar_false.gif"><img src="https://butterfly.js.org/img/loading.gif" alt="snackbar_false.gif"></a></p><blockquote><p>开启Snackbar</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/snackbar_true.gif"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/snackbar_true.gif" alt="snackbar_true.gif"></a></p><h2 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h2><h3 id="CSS-前缀"><a href="#CSS-前缀" class="headerlink" title="CSS 前缀"></a>CSS 前缀</h3><p>有些 CSS 并不是所有浏览器都支持，需要增加对应的前缀才会生效。</p><p>开启 <code>css_prefix</code> 后，会自动为一些 CSS 增加前缀。（会增加 20%的体积）</p><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Add the vendor prefixes to ensure compatibility</span><br><span class="line">css_prefix: true</span><br></pre></td></tr></table></figure><h3 id="Open-Graph"><a href="#Open-Graph" class="headerlink" title="Open Graph"></a>Open Graph</h3><p>在 <code>head</code> 里增加一些 meta 资料，例如缩略图、标题、时间等等。当你分享网页到一些平台时，平台会读取 Open Graph 的内容，展示缩略图，标题等等信息。</p><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Open graph meta tags</span><br><span class="line"># https://developers.facebook.com/docs/sharing/webmasters/</span><br><span class="line">Open_Graph_meta: true</span><br></pre></td></tr></table></figure><h3 id="Instantpage"><a href="#Instantpage" class="headerlink" title="Instantpage"></a>Instantpage</h3><p>当鼠标悬停到链接上超过 65 毫秒时，Instantpage 会对该链接进行预加载，可以提升访问速度。</p><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># https://instant.page/</span><br><span class="line"># prefetch (预加载)</span><br><span class="line">instantpage: true</span><br></pre></td></tr></table></figure><h3 id="Pangu"><a href="#Pangu" class="headerlink" title="Pangu"></a>Pangu</h3><blockquote><p>如果你跟我一样，每次看到网页上的中文字和英文、数字、符号挤在一块，就会坐立难安，忍不住想在它们之间加个空格。这个外挂正是你在网路世界走跳所需要的东西，它会自动替你在网页中所有的中文字和半形的英文、数字、符号之间插入空白。</p></blockquote><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># https://github.com/vinta/pangu.js</span><br><span class="line"># Insert a space between Chinese character and English character (中英文之间添加空格)</span><br><span class="line">pangu:</span><br><span class="line">  enable: false</span><br><span class="line">  field: post # site/post</span><br></pre></td></tr></table></figure><p><code>field</code>只支持两个参数，<code>post</code>(只在文章页生效)和<code>site</code>(全站生效)</p><h2 id="Pjax"><a href="#Pjax" class="headerlink" title="Pjax"></a>Pjax</h2><p>当用户点击链接，通过ajax更新页面需要变化的部分，然后使用HTML5的pushState修改浏览器的URL地址。</p><p>这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line"># Pjax [Beta]</span><br><span class="line"># It may contain bugs and unstable, give feedback when you find the bugs.</span><br><span class="line"># https://github.com/MoOx/pjax</span><br><span class="line">pjax: </span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - /music/</span><br><span class="line">    - /no-pjax/</span><br></pre></td></tr></table></figure><p>对于一些第三方插件，有些并不支持 pjax 。<br>你可以把<strong>网页</strong>加入到 <code>exclude</code> 里，这个网页会被 pjax 排除在外。<br>点击该网页会重新加载网站</p><p>使用pjax后，一些自己DIY的js可能会无效，跳转页面时需要重新调用，请参考<a href="https://github.com/MoOx/pjax">Pjax文档</a><br>使用pjax后，一些个别页面加载的js/css，将会改为所有页面都加载</p><p>Butterfly的Pjax目前仍有一些问题，请留意</p><ul><li>使用谷歌广告可能会报错（例如自动广告）</li></ul><p>如果你在使用中发现问题，欢迎反馈Bugs</p><h2 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h2><blockquote><p>2.3.0以上支持</p></blockquote><p>如想添加额外的js/css/meta等等东西，可以在Inject里添加，支持添加到head(<code>&lt;/body&gt;</code>标籤之前)和bottom(<code>&lt;/html&gt;</code>标籤之前)。</p><p>请注意：以标準的html格式添加内容</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  - &lt;link rel=&quot;stylesheet&quot; href=&quot;/self.css&quot;&gt;</span><br><span class="line">  bottom:</span><br><span class="line">  - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><em>留意:</em> 如果你的网站根目录不是’/‘,使用本地图片时，需加上你的根目录。<br>例如：网站是 <code>https://yoursite.com/blog</code>,引用<code>css/xx.css</code>，则设置为<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/blog/css/xx.css&quot;&gt;</code></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>配置文件中最后一部分CDN，里面是主题所引用到的文件，可自行配置CDN。（非必要请勿修改，配置后请确认链接是否能访问）</p><p>以下是一些CDN提供商：</p><ul><li><a href="https://www.jsdelivr.com/">jsdelivr</a> 👍主题使用</li><li><a href="https://www.bootcdn.cn/">bootcdn</a></li><li><a href="https://cdnjs.com/">cdnjs</a></li><li>……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;美化-特效&quot;&gt;&lt;a href=&quot;#美化-特效&quot; class=&quot;headerlink&quot; title=&quot;美化/特效&quot;&gt;&lt;/a&gt;美化/特效&lt;/h2&gt;&lt;h3 id=&quot;自定义主题色&quot;&gt;&lt;a href=&quot;#自定义主题色&quot; class=&quot;headerlink&quot; title=&quot;自</summary>
      
    
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试二</title>
    <link href="https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%BA%8C/"/>
    <id>https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%BA%8C/</id>
    <published>2021-12-11T14:52:58.000Z</published>
    <updated>2021-12-12T01:39:54.316Z</updated>
    
    <content type="html"><![CDATA[<p>适用于 &gt;= 3.8.0</p><p>侧边栏现在支持自定义了，可以添加自己喜欢的 widget。</p><p>可添加自己的 widget，也可以对现有的 widget 进行排序（<code>博客资料</code>和 <code>公告</code>这两个固定，其它的能排序）</p><h2 id="widget-排序"><a href="#widget-排序" class="headerlink" title="widget 排序"></a>widget 排序</h2><p>只需要配置 <code>sort_order</code>就行。（使用了 <code>Flex</code> 佈局的 <code>order</code> 属性，具体可查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Ordering_Flex_Items">mozilla 文档</a>。简单来讲，就是配置<strong>数字</strong>来实现排序，如果不配置，则默认为 0。数字越小，排序越靠前。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">aside:</span><br><span class="line"> ...</span><br><span class="line">  card_recent_post:</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_categories:</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_tags:</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_archives:</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line">  card_webinfo:</span><br><span class="line">    sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br><span class="line"></span><br><span class="line">newest_comments:</span><br><span class="line">  enable: true</span><br><span class="line">  sort_order: # Don&#x27;t modify the setting unless you know how it works</span><br></pre></td></tr></table></figure><h2 id="自定义-widget"><a href="#自定义-widget" class="headerlink" title="自定义 widget"></a>自定义 widget</h2><p>如果你想添加自己的内容到侧边栏去，你可以自定义。</p><h3 id="创建-widget-yml"><a href="#创建-widget-yml" class="headerlink" title="创建 widget.yml"></a>创建 widget.yml</h3><p>在Hexo博客目录中的<code>source/_data</code>（如果没有 _data 文件夹，请自行创建），创建一个文件 <code>widget.yml</code></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">top:</span><br><span class="line">  - class_name:</span><br><span class="line">    id_name:</span><br><span class="line">    name:</span><br><span class="line">    icon:</span><br><span class="line">    html:</span><br><span class="line"></span><br><span class="line">bottom:</span><br><span class="line">  - class_name:</span><br><span class="line">    id_name:</span><br><span class="line">    name:</span><br><span class="line">    icon:</span><br><span class="line">    order:</span><br><span class="line">    html:</span><br></pre></td></tr></table></figure><blockquote><p>参数详解</p></blockquote><p><strong>top</strong>: 创建的 widget 会出现在非 sticky 区域（即所有页面都会显示)</p><p><strong>bottom</strong>: 创建的 widget 会出现在 sticky 区域（除了文章页都会显示)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>class_name</td><td>所创建的 widget 父类 class 名 （可选）</td></tr><tr><td>id_name</td><td>所创建的 widget 父类 id 名（可选）</td></tr><tr><td>name</td><td>所创建的 widget 标题</td></tr><tr><td>icon</td><td>所创建的 widget 图标</td></tr><tr><td>order</td><td>所创建的 widget 排序 （可选）</td></tr><tr><td>html</td><td>所创建的 widget 相关代码</td></tr></tbody></table><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/adside-diy-parameter.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/adside-diy-parameter.png" alt="image-20201230223506507"></a></p><p>生成的 代码 为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;div class=&quot;card-widget 所写的 class_name&quot; id=&quot;所写的 id_name&quot; style=&quot;order: 所写的 order&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item-headline&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;所写的 icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span&gt;所写的 name&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item-content&quot;&gt;</span><br><span class="line">        所写的 html</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果你需要对添加的 widget 进行 UI 调整，请自行添加 css 到 inject 去。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以 <a href="https://clustrmaps.com/profile/1b7ep/widget/code/globe">访客地图</a> 为例子</p><ol><li><p>获取访客地图的 html 代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建 widget.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">bottom:</span><br><span class="line">    - class_name: user-map</span><br><span class="line">      id_name: user-map</span><br><span class="line">      name: 访客地图</span><br><span class="line">      icon: fas fa-heartbeat</span><br><span class="line">      order:</span><br><span class="line">      html: &#x27;&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8&quot;&gt;&lt;/script&gt;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>运行 hexo</p><p><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/aside-diy-sample.png"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/aside-diy-sample.png" alt="image-20201230224442356"></a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;适用于 &amp;gt;= 3.8.0&lt;/p&gt;
&lt;p&gt;侧边栏现在支持自定义了，可以添加自己喜欢的 widget。&lt;/p&gt;
&lt;p&gt;可添加自己的 widget，也可以对现有的 widget 进行排序（&lt;code&gt;博客资料&lt;/code&gt;和 &lt;code&gt;公告&lt;/code&gt;这两个固定，其它的</summary>
      
    
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试一</title>
    <link href="https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%B8%80/"/>
    <id>https://qwertyu212.github.io/2021/12/11/%E6%B5%8B%E8%AF%95%E4%B8%80/</id>
    <published>2021-12-11T14:46:35.000Z</published>
    <updated>2021-12-12T01:39:02.945Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><strong>Front-matter 是 markdown 文件最上方以 <code>---</code> 分隔的区域，用于指定个别档案的变数。</strong></p><ul><li>Page Front-matter 用于<code>页面</code>配置</li><li>Post Front-matter 用于<code>文章页</code>配置</li></ul><p>如果标注<code>可选</code>的参数，可根据自己需要添加，不用全部都写在markdown里</p><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的<code>音乐</code> 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">複製成功</span><br><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的<code>文章作者</code></td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的<code>文章作者</code>链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的<code>文章连结</code>链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的<code>版权声明</code>文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的<code>音乐</code> 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><h2 id="标籤页"><a href="#标籤页" class="headerlink" title="标籤页"></a>标籤页</h2><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入<code>hexo new page tags</code></p></li><li><p>你会找到<code>source/tags/index.md</code>这个文件</p></li><li><p>修改这个文件：</p><p><strong>记得添加 <code>type: &quot;tags&quot;</code></strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">---</span><br><span class="line">title: 标籤</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入<code>hexo new page categories</code></p></li><li><p>你会找到<code>source/categories/index.md</code>这个文件</p></li><li><p>修改这个文件：</p><p><strong>记得添加 <code>type: &quot;categories&quot;</code></strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>为你的博客创建一个友情链接！</p><h3 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建友情链接页面</h3><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入 <code>hexo new page link</code></p></li><li><p>你会找到<code>source/link/index.md</code>这个文件</p></li><li><p>修改这个文件：</p><p>记得添加 <code>type: &quot;link&quot;</code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2018-06-07 22:17:49</span><br><span class="line">type: &quot;link&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h3><p>在Hexo博客目录中的<code>source/_data</code>（如果没有 _data 文件夹，请自行创建），创建一个文件<code>link.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line"></span><br><span class="line">- class_name: 友情链接</span><br><span class="line">  class_desc: 那些人，那些事</span><br><span class="line">  link_list:</span><br><span class="line">    - name: Hexo</span><br><span class="line">      link: https://hexo.io/zh-tw/</span><br><span class="line">      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span><br><span class="line">      descr: 快速、简单且强大的网誌框架</span><br><span class="line"></span><br><span class="line">- class_name: 网站</span><br><span class="line">  class_desc: 值得推荐的网站</span><br><span class="line">  link_list:</span><br><span class="line">    - name: Youtube</span><br><span class="line">      link: https://www.youtube.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span><br><span class="line">      descr: 视频网站</span><br><span class="line">    - name: Weibo</span><br><span class="line">      link: https://www.weibo.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span><br><span class="line">      descr: 中国最大社交分享平台</span><br><span class="line">    - name: Twitter</span><br><span class="line">      link: https://twitter.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span><br><span class="line">      descr: 社交分享平台</span><br></pre></td></tr></table></figure><p><code>class_name</code>和<code>class_desc</code>支持html格式书写，如不需要，也可以留空。</p><h3 id="友情链接界面设置"><a href="#友情链接界面设置" class="headerlink" title="友情链接界面设置"></a>友情链接界面设置</h3><p>由 2.2.0 起，友情链接界面可以由用户自己自定义，只需要在友情链接的md档设置就行，以普通的Markdown格式书写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;Front-matter&quot;&gt;&lt;a href=&quot;#Front-matter&quot; class=&quot;headerlink&quot; title=&quot;Front-matter&quot;&gt;&lt;/a&gt;Front-matter&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Front-matter 是 ma</summary>
      
    
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://qwertyu212.github.io/2021/12/07/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://qwertyu212.github.io/2021/12/07/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-12-07T14:15:31.000Z</published>
    <updated>2021-12-12T01:40:53.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h2 id="PHP-JSP"><a href="#PHP-JSP" class="headerlink" title="PHP,JSP"></a>PHP,JSP</h2><h2 id="HTML-CSS-JS"><a href="#HTML-CSS-JS" class="headerlink" title="HTML + CSS + JS"></a>HTML + CSS + JS</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="网络基础，网络安全"><a href="#网络基础，网络安全" class="headerlink" title="网络基础，网络安全"></a>网络基础，网络安全</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL语句&quot;&gt;&lt;a href=&quot;#SQL语句&quot; class=&quot;headerlink&quot; title=&quot;SQL语句&quot;&gt;&lt;/a&gt;SQL语句&lt;/h2&gt;&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习计划" scheme="https://qwertyu212.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>php连接数据库的增删改查</title>
    <link href="https://qwertyu212.github.io/2021/11/30/php%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://qwertyu212.github.io/2021/11/30/php%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</id>
    <published>2021-11-29T16:00:01.000Z</published>
    <updated>2021-12-11T16:08:29.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php连接数据库的增删改查"><a href="#php连接数据库的增删改查" class="headerlink" title="php连接数据库的增删改查"></a>php连接数据库的增删改查</h1><h3 id="php的连接数据库查询"><a href="#php的连接数据库查询" class="headerlink" title="php的连接数据库查询"></a>php的连接数据库查询</h3><p>index.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;查询&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">            h1,form&#123;</span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line">            table&#123;</span><br><span class="line">            margin: auto;</span><br><span class="line">            border: 2px solid blue;</span><br><span class="line">            &#125;</span><br><span class="line">            table&#123;</span><br><span class="line">                margin:auto;</span><br><span class="line">                border:2px solid blue;</span><br><span class="line">            &#125;</span><br><span class="line">            tr:nth-child(odd)&#123;</span><br><span class="line">                background: #ccc;</span><br><span class="line">            &#125;</span><br><span class="line">            tr:nth-child(even)&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">.form01&#123;</span><br><span class="line">margin:auto;</span><br><span class="line">height: 74px;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">function check1()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./insert.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">function check2()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./update.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">function check3()&#123;</span><br><span class="line">var db = document.getElementById(&quot;bd&quot;);</span><br><span class="line">db.action = &quot;./delete.php&quot;;</span><br><span class="line">db.submit();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;所有老师信息&lt;/h1&gt;</span><br><span class="line">&lt;div class=&quot;form01&quot;&gt;</span><br><span class="line">&lt;form  action=&#x27;./index.php&#x27; method=&#x27;post&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;text&#x27; name=&#x27;query&#x27;/&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;btnQuery&#x27; value=&#x27;搜索&#x27;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;form action=&#x27;&#x27; method=&#x27;post&#x27; id=&#x27;bd&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;insert&#x27; value=&#x27;新增&#x27; onclick=&#x27;check1()&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;&#x27; value=&#x27;编辑&#x27; onclick=&#x27;check2()&#x27;&gt;</span><br><span class="line">&lt;input type=&#x27;submit&#x27; name=&#x27;delete&#x27; value=&#x27;删除&#x27; onclick=&#x27;check3()&#x27;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;table border=&quot;1&quot; width=&#x27;600px&#x27; style=&#x27;text-align:center;&#x27;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;工号&lt;/td&gt;</span><br><span class="line">&lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;td&gt;出生日期&lt;/td&gt;</span><br><span class="line">&lt;td&gt;所在部门&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">$query = $_POST[&#x27;query&#x27;];</span><br><span class="line">//$_SESSION[&#x27;query&#x27;]=&quot;$query&quot;;</span><br><span class="line">$db = new mysqli(&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">if(!$db)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_POST[&#x27;btnQuery&#x27;]) &amp;&amp; $query != null)</span><br><span class="line">&#123;</span><br><span class="line">    //session_start();</span><br><span class="line">$sql=&quot;SELECT laoshi.e_id,laoshi.e_name, laoshi.sex, laoshi.date_birth, bumen.dept_name</span><br><span class="line">from laoshi left join bumen on  bumen.dept_no = laoshi.dept_no WHERE laoshi.e_id = &#x27;$query&#x27; or laoshi.e_name = &#x27;$query&#x27; or bumen.dept_name = &#x27;$query&#x27;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$sql=&quot;SELECT e_id,e_name, sex, date_birth, bumen.dept_name from laoshi left join bumen on bumen.dept_no = laoshi.dept_no&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">$res=$db-&gt;query($sql);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">if($res)&#123;</span><br><span class="line"></span><br><span class="line">    while($row=$res-&gt;fetch_assoc()) &#123;</span><br><span class="line">            $gonghao=$row[&#x27;e_id&#x27;];</span><br><span class="line">            $xingming=$row[&#x27;e_name&#x27;];</span><br><span class="line">            $sex=$row[&#x27;sex&#x27;];</span><br><span class="line">            $shengri=$row[&#x27;date_birth&#x27;];</span><br><span class="line">            $suozaibumen=$row[&#x27;dept_name&#x27;];</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;center&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&#x27;checkbox&#x27; name=&#x27;sel[]&#x27; value=&#x27;&quot;.$row[&quot;e_id&quot;].&quot;&#x27;/&gt;&lt;/td&gt;&lt;/center&gt;&quot;.</span><br><span class="line">&quot;&lt;td&gt;$gonghao&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$xingming&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$sex&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$shengri&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$suozaibumen&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放结果集</span><br><span class="line">$res-&gt;close;</span><br><span class="line">&#125;</span><br><span class="line">//关闭连接</span><br><span class="line">$db-&gt;close();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="php连接数据库插入"><a href="#php连接数据库插入" class="headerlink" title="php连接数据库插入"></a>php连接数据库插入</h3><p>insert.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;新增&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        .css-01 </span><br><span class="line">        &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 50px;</span><br><span class="line">                margin: 200px auto;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function myCheck()</span><br><span class="line">    &#123;//遍历所有表单元素</span><br><span class="line">        for(var i=0;i&lt;document.form1.elements.length-1;i++)</span><br><span class="line">        &#123;//判断所有表单值是否为空</span><br><span class="line">        if(document.form1.elements[i].value==&quot;&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">        alert(&quot;当前表单不能有空项&quot;);</span><br><span class="line">           //将光标定位在空表单处</span><br><span class="line">        document.form1.elements[i].focus();</span><br><span class="line">        return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;css-01&quot;&gt;</span><br><span class="line">        &lt;form action=&quot;./insert.php&quot; name=&quot;form1&quot; method=&quot;post&quot; onSubmit=&quot;return myCheck()&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;id&quot; placeholder=&quot;ID&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;birthday&quot; placeholder=&quot;生日&quot;&gt;</span><br><span class="line">            &lt;?php</span><br><span class="line">                echo &quot;&lt;select name=&#x27;department&#x27;&gt;&quot;;</span><br><span class="line">                $db = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">                $sql = &quot;SELECT * FROM bumen WHERE dept=&#x27;xinguan&#x27;&quot;;</span><br><span class="line">                $db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">                $data = $db-&gt;query($sql);</span><br><span class="line">                if($data)&#123;</span><br><span class="line">                    while($row = $data-&gt;fetch_assoc()) &#123;</span><br><span class="line">                        $bumen_id = $row[&#x27;dept_no&#x27;];</span><br><span class="line">                        $bumen_name = $row[&#x27;dept_name&#x27;];</span><br><span class="line">                        echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27;&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        //echo &quot;&lt;input type=&#x27;text&#x27; name=&#x27;department&#x27; placeholder=&#x27;部门&#x27;&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;/select&gt;&quot;;</span><br><span class="line">            ?&gt;</span><br><span class="line">            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男</span><br><span class="line">            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女</span><br><span class="line">            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;新增&quot;&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">            $id = $_POST[&quot;id&quot;];</span><br><span class="line">            $name = $_POST[&quot;name&quot;];</span><br><span class="line">            $sex = $_POST[&quot;sex&quot;];</span><br><span class="line">            $birthday = $_POST[&quot;birthday&quot;];</span><br><span class="line">            $department = $_POST[&quot;department&quot;];</span><br><span class="line">            $db = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">            if(!$db)&#123;</span><br><span class="line">                echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            $mysql = &quot;INSERT INTO laoshi VALUES (&#x27;$id&#x27;,&#x27;$name&#x27;,&#x27;$sex&#x27;,&#x27;$birthday&#x27;,&#x27;$department&#x27;)&quot;;</span><br><span class="line">            mysqli_query($db,&quot;SET NAMES utf8&quot;);</span><br><span class="line">            $data  = mysqli_query($db,$mysql);</span><br><span class="line">            if ($data) &#123;</span><br><span class="line">                echo &quot;&lt;script&gt;alert(&#x27;添加成绩成功&#x27;);this.location.href=&#x27;index.php&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                echo &quot;&lt;script&gt;alert(&#x27;添加成绩失败&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            mysqli_close($db);</span><br><span class="line">        &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="php连接数据库删除"><a href="#php连接数据库删除" class="headerlink" title="php连接数据库删除"></a>php连接数据库删除</h2><p>delete.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;删除&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">    if(count($_POST[&#x27;sel&#x27;]) == 0)&#123;</span><br><span class="line">        echo &quot;&lt;script&gt;alert(&#x27;请先选择需要删除或修改的老师信息!&#x27;);history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $db = new  mysqli (&quot;localhost&quot;, &quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">        if(!$db)&#123;</span><br><span class="line">                echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for($i=0;$i&lt;count($_POST[&#x27;sel&#x27;]);$i++)&#123;</span><br><span class="line">            $sqlDel =&quot;DELETE FROM laoshi WHERE e_id=&#x27;&quot;.$_POST[&#x27;sel&#x27;][$i].&quot;&#x27;&quot;;</span><br><span class="line">            $db-&gt;query($sqlDel);</span><br><span class="line">        &#125;</span><br><span class="line">        echo &quot;&lt;script&gt;alert(&#x27;删除成功！&#x27;);window.location=&#x27;index.php&#x27;;&lt;/script&gt;&quot;;</span><br><span class="line">        $db-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="php连接数据库编辑"><a href="#php连接数据库编辑" class="headerlink" title="php连接数据库编辑"></a>php连接数据库编辑</h3><p>update.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Conter-Type&quot; content=&quot;text/html; charset=utf8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;更新&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">    if(count($_POST[&#x27;sel&#x27;])==0 &amp;&amp; !isset($_POST[&#x27;update&#x27;]))  //判断是否选择了要删除的选项，并且没有点击本页面的提交按钮</span><br><span class="line">    &#123; </span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;请先选择需要删除或修改的老师信息!&#x27;);history.go(-1);&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $db = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;studentmis&quot;);</span><br><span class="line">    if($db-&gt;connect_error)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;数据库连接失败！！！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isset($_POST[&#x27;update&#x27;]))&#123;        //点击按钮执行更新</span><br><span class="line">        $gonghao = $_POST[&quot;text1&quot;];</span><br><span class="line">        $xingming = $_POST[&quot;text2&quot;];</span><br><span class="line">        $shengri = $_POST[&quot;text3&quot;];</span><br><span class="line">        $bumen = $_POST[&quot;department&quot;];</span><br><span class="line">        $sex = $_POST[&quot;sex&quot;];</span><br><span class="line">    </span><br><span class="line">        $sql = &quot;UPDATE laoshi SET e_id=&#x27;$gonghao&#x27;,e_name=&#x27;$xingming&#x27;,sex=&#x27;$sex&#x27;,date_birth=&#x27;$shengri&#x27;,dept_no=&#x27;$bumen&#x27; WHERE e_id=&#x27;$gonghao&#x27;&quot;;</span><br><span class="line">        $db-&gt;query(&#x27;SET NAMES UTF8&#x27;);</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        if ($result) &#123;</span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;更新成功&#x27;);this.location.href=&#x27;index.php&#x27;&lt;/script&gt;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo &quot;&lt;script&gt;alert(&#x27;更新失败&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;      // 查询要更新的数据</span><br><span class="line">        for($i=0;$i&lt;count($_POST[&#x27;sel&#x27;]);$i++)&#123;</span><br><span class="line">            $sqlDel =&quot;SELECT e_id,e_name, sex, date_birth,dept_no</span><br><span class="line">            FROM laoshi  WHERE e_id=&#x27;&quot;.$_POST[&#x27;sel&#x27;][$i].&quot;&#x27;&quot;;</span><br><span class="line">            $db-&gt;query(&#x27;SET NAMES UTF8&#x27;);</span><br><span class="line">            $res=$db-&gt;query($sqlDel);</span><br><span class="line">        if($res)&#123;</span><br><span class="line">                while($row=$res-&gt;fetch_assoc()) </span><br><span class="line">                &#123;</span><br><span class="line">                    $gonghao=$row[&#x27;e_id&#x27;];</span><br><span class="line">                    $xingming=$row[&#x27;e_name&#x27;];</span><br><span class="line">                    $sex=$row[&#x27;sex&#x27;];</span><br><span class="line">                    $shengri=$row[&#x27;date_birth&#x27;];</span><br><span class="line">                    $suozaibumen=$row[&#x27;dept_no&#x27;];</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;form action=&#x27;./update.php&#x27; method=&#x27;post&#x27;&gt;&quot;;</span><br><span class="line">                echo  &quot;&lt;div style=&#x27;margin: 200px auto;width: 100px;height: 50px;&#x27;&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;工号&#x27; name=&#x27;text1&#x27; value=&#x27;$gonghao&#x27; readonly=&#x27;readonly&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;姓名&#x27; name=&#x27;text2&#x27; value=&#x27;$xingming&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;input type=&#x27;text&#x27; placeholder=&#x27;生日&#x27; name=&#x27;text3&#x27; value=&#x27;$shengri&#x27;&gt;</span><br><span class="line">                    &lt;br&gt;&quot;;</span><br><span class="line">                 // 下拉框</span><br><span class="line">                echo &quot;&lt;select name=&#x27;department&#x27;&gt;&quot;;</span><br><span class="line">                $sql = &quot;SELECT * FROM bumen WHERE dept=&#x27;xinguan&#x27;&quot;;</span><br><span class="line">                $db-&gt;query(&quot;SET NAMES utf8&quot;);</span><br><span class="line">                $data = $db-&gt;query($sql);</span><br><span class="line">                if($data)&#123;</span><br><span class="line">                    while($row = $data-&gt;fetch_assoc()) &#123;</span><br><span class="line">                        $bumen_id = $row[&#x27;dept_no&#x27;];</span><br><span class="line">                        $bumen_name = $row[&#x27;dept_name&#x27;];</span><br><span class="line">                        if($bumen_id == $suozaibumen)&#123;</span><br><span class="line">                            echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27; selected&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            echo &quot;&lt;option name=&#x27;bumen&#x27; value=&#x27;$bumen_id&#x27;&gt;$bumen_name&lt;/option&gt;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;/select&gt;&quot;;</span><br><span class="line"></span><br><span class="line">                if($sex == &quot;男&quot;)</span><br><span class="line">                &#123;  </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;男&#x27; checked&gt;男&quot;; </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;女&#x27;&gt;女&quot;; </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                &#123; </span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;男&#x27;&gt;男&quot;;</span><br><span class="line">                    echo &quot;&lt;input type=radio name=sex value=&#x27;女&#x27; checked&gt;女&quot;; </span><br><span class="line">                &#125;</span><br><span class="line">                echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo &quot;&lt;input type=&#x27;submit&#x27; name=&#x27;update&#x27; value=&#x27;提交&#x27;&gt;&quot;; </span><br><span class="line">                echo &quot;&lt;/div&gt;&quot;;</span><br><span class="line">            echo &quot;&lt;/form&gt;&quot;;</span><br><span class="line">            //释放结果集</span><br><span class="line">            $res-&gt;close;</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭连接  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    $db-&gt;close();</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是对PHP连接数据库的增删改查操作的学习</summary>
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PHP" scheme="https://qwertyu212.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>4.运营商流失用户的分析与预测</title>
    <link href="https://qwertyu212.github.io/2021/11/29/4-%E8%BF%90%E8%90%A5%E5%95%86%E6%B5%81%E5%A4%B1%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E9%A2%84%E6%B5%8B/"/>
    <id>https://qwertyu212.github.io/2021/11/29/4-%E8%BF%90%E8%90%A5%E5%95%86%E6%B5%81%E5%A4%B1%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E9%A2%84%E6%B5%8B/</id>
    <published>2021-11-29T13:56:17.000Z</published>
    <updated>2021-11-29T15:25:14.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运营商流失用户的分析与预测"><a href="#运营商流失用户的分析与预测" class="headerlink" title="运营商流失用户的分析与预测"></a>运营商流失用户的分析与预测</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运营商流失用户的分析与预测&quot;&gt;&lt;a href=&quot;#运营商流失用户的分析与预测&quot; class=&quot;headerlink&quot; title=&quot;运营商流失用户的分析与预测&quot;&gt;&lt;/a&gt;运营商流失用户的分析与预测&lt;/h1&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="https://qwertyu212.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>3.全国汽车销量可视化</title>
    <link href="https://qwertyu212.github.io/2021/11/29/3-%E5%85%A8%E5%9B%BD%E6%B1%BD%E8%BD%A6%E9%94%80%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://qwertyu212.github.io/2021/11/29/3-%E5%85%A8%E5%9B%BD%E6%B1%BD%E8%BD%A6%E9%94%80%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2021-11-29T13:55:54.000Z</published>
    <updated>2021-12-07T14:14:30.913Z</updated>
    
    <content type="html"><![CDATA[<p>全国汽车销量可视化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;全国汽车销量可视化&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="https://qwertyu212.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2.财政收入预测分析</title>
    <link href="https://qwertyu212.github.io/2021/11/29/%E8%B4%A2%E6%94%BF%E6%94%B6%E5%85%A5%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
    <id>https://qwertyu212.github.io/2021/11/29/%E8%B4%A2%E6%94%BF%E6%94%B6%E5%85%A5%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-11-29T13:42:06.000Z</published>
    <updated>2021-11-30T02:05:50.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="财政收入预测分析"><a href="#财政收入预测分析" class="headerlink" title="财政收入预测分析"></a>财政收入预测分析</h1><p>读取数据<br>求相关系数<br>关键特征提取：Lasso回归（防止过拟合），降维，缩小特征集。<br>                         相关系数不为0的<br>数据预处理<br>灰色预测模型GM（1，1）：<br>添加财政收入列<br>数据预处理<br>训练数据标准差标椎化<br>线性支持向量回归模型：<br>        模型训练<br>        预测数据标准差标椎化<br>        模型预测<br>        标椎化值还原<br>        添加入列表<br>        可视化呈现</p><h3 id="Pearson相关系数"><a href="#Pearson相关系数" class="headerlink" title="Pearson相关系数"></a>Pearson相关系数</h3><p><img src="/2021/11/29/%E8%B4%A2%E6%94%BF%E6%94%B6%E5%85%A5%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/image-20211129125338196.jpg" alt="image-20211129125338196"></p><p>Lasso以缩小特征集（降阶）为思想，是一种收缩估计方法。<br>Lasso方法可以将特征的系数进行压缩并使某些回归系数变为0，进而达到特征选择的目的，可以广泛地应用于模型改进与选择。<br>通过选择惩罚函数，借用Lasso思想和方法实现特征选择的目的。这种过程可以通过优化一个“损失”＋“惩罚”的函数问题来完成。<br><img src="/2021/11/29/%E8%B4%A2%E6%94%BF%E6%94%B6%E5%85%A5%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/image-20211129125657821.png" alt="image-20211129125657821">当原始特征中存在多重共线性时，Lasso回归不失为一种很好的处理共线性的方法，它可以有效地对存在多重共线性的特征进行筛选。</p><h2 id="了解灰色预测算法"><a href="#了解灰色预测算法" class="headerlink" title="了解灰色预测算法"></a>了解灰色预测算法</h2><p>灰色预测法是一种对含有不确定因素的系统进行预测的方法。<br><img src="/2021/11/29/%E8%B4%A2%E6%94%BF%E6%94%B6%E5%85%A5%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/image-20211129213021543.png" alt="image-20211129213021543"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;财政收入预测分析&quot;&gt;&lt;a href=&quot;#财政收入预测分析&quot; class=&quot;headerlink&quot; title=&quot;财政收入预测分析&quot;&gt;&lt;/a&gt;财政收入预测分析&lt;/h1&gt;&lt;p&gt;读取数据&lt;br&gt;求相关系数&lt;br&gt;关键特征提取：Lasso回归（防止过拟合），降维，缩小特征</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="https://qwertyu212.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>1.航空公司客户价值分析</title>
    <link href="https://qwertyu212.github.io/2021/11/29/%E8%88%AA%E7%A9%BA%E5%85%AC%E5%8F%B8%E5%AE%A2%E6%88%B7%E4%BB%B7%E5%80%BC%E5%88%86%E6%9E%90/"/>
    <id>https://qwertyu212.github.io/2021/11/29/%E8%88%AA%E7%A9%BA%E5%85%AC%E5%8F%B8%E5%AE%A2%E6%88%B7%E4%BB%B7%E5%80%BC%E5%88%86%E6%9E%90/</id>
    <published>2021-11-29T13:40:08.000Z</published>
    <updated>2021-11-30T01:58:38.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="航空公司客户价值分析"><a href="#航空公司客户价值分析" class="headerlink" title="航空公司客户价值分析"></a>航空公司客户价值分析</h1><p>数据预处理：<br>丢弃数据为空的数据。<br>丢弃异常数据<br>构建 L RFMC 模型<br>构建L指标（会员入会时间距观测窗口结束的月数)<br>合并特征，进行拼接数据<br>数据标准化处理<br>聚类分析<br>绘图：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;航空公司客户价值分析&quot;&gt;&lt;a href=&quot;#航空公司客户价值分析&quot; class=&quot;headerlink&quot; title=&quot;航空公司客户价值分析&quot;&gt;&lt;/a&gt;航空公司客户价值分析&lt;/h1&gt;&lt;p&gt;数据预处理：&lt;br&gt;丢弃数据为空的数据。&lt;br&gt;丢弃异常数据&lt;br&gt;构建 L</summary>
      
    
    
    
    <category term="学习" scheme="https://qwertyu212.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Python" scheme="https://qwertyu212.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="https://qwertyu212.github.io/2021/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://qwertyu212.github.io/2021/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2021-11-13T13:14:05.000Z</published>
    <updated>2021-12-14T03:52:25.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地图片导入"><a href="#本地图片导入" class="headerlink" title="本地图片导入"></a>本地图片导入</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片名](./与博文同名的文件名/1.PNG)</span><br></pre></td></tr></table></figure><p>测试：<img src="/2021/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/test_01.jpg" alt="test_01"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地图片导入&quot;&gt;&lt;a href=&quot;#本地图片导入&quot; class=&quot;headerlink&quot; title=&quot;本地图片导入&quot;&gt;&lt;/a&gt;本地图片导入&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="test" scheme="https://qwertyu212.github.io/categories/test/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://qwertyu212.github.io/2021/11/12/My-Gallery/"/>
    <id>https://qwertyu212.github.io/2021/11/12/My-Gallery/</id>
    <published>2021-11-11T16:00:00.000Z</published>
    <updated>2021-11-14T02:56:15.944Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="test" scheme="https://qwertyu212.github.io/categories/test/"/>
    
    
    <category term="测试" scheme="https://qwertyu212.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
